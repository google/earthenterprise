#!/usr/bin/env python
#
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# -*- coding: utf-8 -*-

#
# Generated Wed Aug 31 14:02:20 2011 by generateDS.py version 2.5a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
  # lxml
  from lxml import etree as etree_
  XMLParser_import_library = XMLParser_import_lxml
  if Verbose_import_:
    print("running with lxml.etree")
except ImportError:
  try:
    # cElementTree from Python 2.5+
    import xml.etree.cElementTree as etree_
    XMLParser_import_library = XMLParser_import_elementtree
    if Verbose_import_:
      print("running with cElementTree on Python 2.5+")
  except ImportError:
    try:
      # ElementTree from Python 2.5+
      import xml.etree.ElementTree as etree_
      XMLParser_import_library = XMLParser_import_elementtree
      if Verbose_import_:
        print("running with ElementTree on Python 2.5+")
    except ImportError:
      try:
        # normal cElementTree install
        import cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
          print("running with cElementTree")
      except ImportError:
        try:
          # normal ElementTree install
          import elementtree.ElementTree as etree_
          XMLParser_import_library = XMLParser_import_elementtree
          if Verbose_import_:
            print("running with ElementTree")
        except ImportError:
          raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
  if (XMLParser_import_library == XMLParser_import_lxml and
      'parser' not in kwargs):
    # Use the lxml ElementTree compatible parser so that, e.g.,
    #   we ignore comments.
    kwargs['parser'] = etree_.ETCompatXMLParser()
  doc = etree_.parse(*args, **kwargs)
  return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
  from generatedssuper import GeneratedsSuper
except ImportError, exp:

  class GeneratedsSuper(object):
    def gds_format_string(self, input_data, input_name=''):
      return input_data
    def gds_validate_string(self, input_data, node, input_name=''):
      return input_data
    def gds_format_integer(self, input_data, input_name=''):
      return '%d' % input_data
    def gds_validate_integer(self, input_data, node, input_name=''):
      return input_data
    def gds_format_integer_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_integer_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of integers')
      return input_data
    def gds_format_float(self, input_data, input_name=''):
      return '%f' % input_data
    def gds_validate_float(self, input_data, node, input_name=''):
      return input_data
    def gds_format_float_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_float_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of floats')
      return input_data
    def gds_format_double(self, input_data, input_name=''):
      return '%e' % input_data
    def gds_validate_double(self, input_data, node, input_name=''):
      return input_data
    def gds_format_double_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_double_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of doubles')
      return input_data
    def gds_format_boolean(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_boolean(self, input_data, node, input_name=''):
      return input_data
    def gds_format_boolean_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_boolean_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        if value not in ('true', '1', 'false', '0', ):
          raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
      return input_data
    def gds_str_lower(self, instring):
      return instring.lower()
    def get_path_(self, node):
      path_list = []
      self.get_path_list_(node, path_list)
      path_list.reverse()
      path = '/'.join(path_list)
      return path
    Tag_strip_pattern_ = re_.compile(r'\{.*\}')
    def get_path_list_(self, node, path_list):
      if node is None:
        return
      tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
      if tag:
        path_list.append(tag)
      self.get_path_list_(node.getparent(), path_list)


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
  for idx in range(level):
    outfile.write('    ')

def quote_xml(inStr):
  if not inStr:
    return ''
  s1 = (isinstance(inStr, basestring) and inStr or
        '%s' % inStr)
  s1 = s1.replace('&', '&amp;')
  s1 = s1.replace('<', '&lt;')
  s1 = s1.replace('>', '&gt;')
  return s1

def quote_attrib(inStr):
  s1 = (isinstance(inStr, basestring) and inStr or
        '%s' % inStr)
  s1 = s1.replace('&', '&amp;')
  s1 = s1.replace('<', '&lt;')
  s1 = s1.replace('>', '&gt;')
  if '"' in s1:
    if "'" in s1:
      s1 = '"%s"' % s1.replace('"', "&quot;")
    else:
      s1 = "'%s'" % s1
  else:
    s1 = '"%s"' % s1
  return s1

def quote_python(inStr):
  s1 = inStr
  if s1.find("'") == -1:
    if s1.find('\n') == -1:
      return "'%s'" % s1
    else:
      return "'''%s'''" % s1
  else:
    if s1.find('"') != -1:
      s1 = s1.replace('"', '\\"')
    if s1.find('\n') == -1:
      return '"%s"' % s1
    else:
      return '"""%s"""' % s1

def get_all_text_(node):
  if node.text is not None:
    text = node.text
  else:
    text = ''
  for child in node:
    if child.tail is not None:
      text += child.tail
  return text

def find_attr_value_(attr_name, node):
  attrs = node.attrib
  # First try with no namespace.
  value = attrs.get(attr_name)
  if value is None:
    # Now try the other possible namespaces.
    namespaces = node.nsmap.itervalues()
    for namespace in namespaces:
      value = attrs.get('{%s}%s' % (namespace, attr_name, ))
      if value is not None:
        break
  return value


class GDSParseError(Exception):
  pass

def raise_parse_error(node, msg):
  if XMLParser_import_library == XMLParser_import_lxml:
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
  else:
    msg = '%s (element %s)' % (msg, node.tag, )
  raise GDSParseError(msg)


class MixedContainer:
  # Constants for category:
  CategoryNone = 0
  CategoryText = 1
  CategorySimple = 2
  CategoryComplex = 3
  # Constants for content_type:
  TypeNone = 0
  TypeText = 1
  TypeString = 2
  TypeInteger = 3
  TypeFloat = 4
  TypeDecimal = 5
  TypeDouble = 6
  TypeBoolean = 7
  def __init__(self, category, content_type, name, value):
    self.category = category
    self.content_type = content_type
    self.name = name
    self.value = value
  def getCategory(self):
    return self.category
  def getContenttype(self, content_type):
    return self.content_type
  def getValue(self):
    return self.value
  def getName(self):
    return self.name
  def export(self, outfile, level, name, namespace):
    if self.category == MixedContainer.CategoryText:
      # Prevent exporting empty content as empty lines.
      if self.value.strip():
        outfile.write(self.value)
    elif self.category == MixedContainer.CategorySimple:
      self.exportSimple(outfile, level, name)
    else:    # category == MixedContainer.CategoryComplex
      self.value.export(outfile, level, namespace,name)
  def exportSimple(self, outfile, level, name):
    if self.content_type == MixedContainer.TypeString:
      outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeInteger or \
            self.content_type == MixedContainer.TypeBoolean:
      outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeFloat or \
            self.content_type == MixedContainer.TypeDecimal:
      outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeDouble:
      outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
  def exportLiteral(self, outfile, level, name):
    if self.category == MixedContainer.CategoryText:
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
          (self.category, self.content_type, self.name, self.value))
    elif self.category == MixedContainer.CategorySimple:
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
          (self.category, self.content_type, self.name, self.value))
    else:    # category == MixedContainer.CategoryComplex
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
          (self.category, self.content_type, self.name,))
      self.value.exportLiteral(outfile, level + 1)
      showIndent(outfile, level)
      outfile.write(')\n')


class MemberSpec_(object):
  def __init__(self, name='', data_type='', container=0):
    self.name = name
    self.data_type = data_type
    self.container = container
  def set_name(self, name): self.name = name
  def get_name(self): return self.name
  def set_data_type(self, data_type): self.data_type = data_type
  def get_data_type_chain(self): return self.data_type
  def get_data_type(self):
    if isinstance(self.data_type, list):
      if len(self.data_type) > 0:
        return self.data_type[-1]
      else:
        return 'xs:string'
    else:
      return self.data_type
  def set_container(self, container): self.container = container
  def get_container(self): return self.container

def _cast(typ, value):
  if typ is None or value is None:
    return value
  return typ(value)

#
# Data representation classes.
#

class TileMatrixSetLink(GeneratedsSuper):
  """Metadata about the TileMatrixSet reference."""
  subclass = None
  superclass = None
  def __init__(self, TileMatrixSet=None, TileMatrixSetLimits=None):
    self.TileMatrixSet = TileMatrixSet
    self.TileMatrixSetLimits = TileMatrixSetLimits
  def factory(*args_, **kwargs_):
    if TileMatrixSetLink.subclass:
      return TileMatrixSetLink.subclass(*args_, **kwargs_)
    else:
      return TileMatrixSetLink(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_TileMatrixSet(self): return self.TileMatrixSet
  def set_TileMatrixSet(self, TileMatrixSet): self.TileMatrixSet = TileMatrixSet
  def get_TileMatrixSetLimits(self): return self.TileMatrixSetLimits
  def set_TileMatrixSetLimits(self, TileMatrixSetLimits): self.TileMatrixSetLimits = TileMatrixSetLimits
  def export(self, outfile, level, namespace_='', name_='TileMatrixSetLink', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='TileMatrixSetLink')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TileMatrixSetLink'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='TileMatrixSetLink', fromsubclass_=False):
    if self.TileMatrixSet is not None:
      showIndent(outfile, level)
      outfile.write('<%sTileMatrixSet>%s</%sTileMatrixSet>\n' % (namespace_, self.gds_format_string(quote_xml(self.TileMatrixSet).encode(ExternalEncoding), input_name='TileMatrixSet'), namespace_))
    if self.TileMatrixSetLimits:
      self.TileMatrixSetLimits.export(outfile, level, namespace_, name_='TileMatrixSetLimits')
  def hasContent_(self):
    if (
        self.TileMatrixSet is not None or
        self.TileMatrixSetLimits is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='TileMatrixSetLink'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.TileMatrixSet is not None:
      showIndent(outfile, level)
      outfile.write('TileMatrixSet=%s,\n' % quote_python(self.TileMatrixSet).encode(ExternalEncoding))
    if self.TileMatrixSetLimits is not None:
      showIndent(outfile, level)
      outfile.write('TileMatrixSetLimits=model_.TileMatrixSetLimits(\n')
      self.TileMatrixSetLimits.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'TileMatrixSet':
      TileMatrixSet_ = child_.text
      TileMatrixSet_ = self.gds_validate_string(TileMatrixSet_, node, 'TileMatrixSet')
      self.TileMatrixSet = TileMatrixSet_
    elif nodeName_ == 'TileMatrixSetLimits':
      obj_ = TileMatrixSetLimits.factory()
      obj_.build(child_)
      self.set_TileMatrixSetLimits(obj_)
# end class TileMatrixSetLink


class TileMatrixSetLimits(GeneratedsSuper):
  """Metadata about a the limits of the tile row and tile col indices."""
  subclass = None
  superclass = None
  def __init__(self, TileMatrixLimits=None):
    if TileMatrixLimits is None:
      self.TileMatrixLimits = []
    else:
      self.TileMatrixLimits = TileMatrixLimits
  def factory(*args_, **kwargs_):
    if TileMatrixSetLimits.subclass:
      return TileMatrixSetLimits.subclass(*args_, **kwargs_)
    else:
      return TileMatrixSetLimits(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_TileMatrixLimits(self): return self.TileMatrixLimits
  def set_TileMatrixLimits(self, TileMatrixLimits): self.TileMatrixLimits = TileMatrixLimits
  def add_TileMatrixLimits(self, value): self.TileMatrixLimits.append(value)
  def insert_TileMatrixLimits(self, index, value): self.TileMatrixLimits[index] = value
  def export(self, outfile, level, namespace_='', name_='TileMatrixSetLimits', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='TileMatrixSetLimits')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TileMatrixSetLimits'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='TileMatrixSetLimits', fromsubclass_=False):
    for TileMatrixLimits_ in self.TileMatrixLimits:
      TileMatrixLimits_.export(outfile, level, namespace_, name_='TileMatrixLimits')
  def hasContent_(self):
    if (
        self.TileMatrixLimits
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='TileMatrixSetLimits'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('TileMatrixLimits=[\n')
    level += 1
    for TileMatrixLimits_ in self.TileMatrixLimits:
      showIndent(outfile, level)
      outfile.write('model_.TileMatrixLimits(\n')
      TileMatrixLimits_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'TileMatrixLimits':
      obj_ = TileMatrixLimits.factory()
      obj_.build(child_)
      self.TileMatrixLimits.append(obj_)
# end class TileMatrixSetLimits


class TileMatrixLimits(GeneratedsSuper):
  """Metadata describing the limits of a TileMatrix for this layer."""
  subclass = None
  superclass = None
  def __init__(self, TileMatrix=None, MinTileRow=None, MaxTileRow=None, MinTileCol=None, MaxTileCol=None):
    self.TileMatrix = TileMatrix
    self.MinTileRow = MinTileRow
    self.MaxTileRow = MaxTileRow
    self.MinTileCol = MinTileCol
    self.MaxTileCol = MaxTileCol
  def factory(*args_, **kwargs_):
    if TileMatrixLimits.subclass:
      return TileMatrixLimits.subclass(*args_, **kwargs_)
    else:
      return TileMatrixLimits(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_TileMatrix(self): return self.TileMatrix
  def set_TileMatrix(self, TileMatrix): self.TileMatrix = TileMatrix
  def get_MinTileRow(self): return self.MinTileRow
  def set_MinTileRow(self, MinTileRow): self.MinTileRow = MinTileRow
  def get_MaxTileRow(self): return self.MaxTileRow
  def set_MaxTileRow(self, MaxTileRow): self.MaxTileRow = MaxTileRow
  def get_MinTileCol(self): return self.MinTileCol
  def set_MinTileCol(self, MinTileCol): self.MinTileCol = MinTileCol
  def get_MaxTileCol(self): return self.MaxTileCol
  def set_MaxTileCol(self, MaxTileCol): self.MaxTileCol = MaxTileCol
  def export(self, outfile, level, namespace_='', name_='TileMatrixLimits', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='TileMatrixLimits')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TileMatrixLimits'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='TileMatrixLimits', fromsubclass_=False):
    if self.TileMatrix is not None:
      showIndent(outfile, level)
      outfile.write('<%sTileMatrix>%s</%sTileMatrix>\n' % (namespace_, self.gds_format_string(quote_xml(self.TileMatrix).encode(ExternalEncoding), input_name='TileMatrix'), namespace_))
    if self.MinTileRow is not None:
      showIndent(outfile, level)
      outfile.write('<%sMinTileRow>%s</%sMinTileRow>\n' % (namespace_, self.gds_format_integer(self.MinTileRow, input_name='MinTileRow'), namespace_))
    if self.MaxTileRow is not None:
      showIndent(outfile, level)
      outfile.write('<%sMaxTileRow>%s</%sMaxTileRow>\n' % (namespace_, self.gds_format_integer(self.MaxTileRow, input_name='MaxTileRow'), namespace_))
    if self.MinTileCol is not None:
      showIndent(outfile, level)
      outfile.write('<%sMinTileCol>%s</%sMinTileCol>\n' % (namespace_, self.gds_format_integer(self.MinTileCol, input_name='MinTileCol'), namespace_))
    if self.MaxTileCol is not None:
      showIndent(outfile, level)
      outfile.write('<%sMaxTileCol>%s</%sMaxTileCol>\n' % (namespace_, self.gds_format_integer(self.MaxTileCol, input_name='MaxTileCol'), namespace_))
  def hasContent_(self):
    if (
        self.TileMatrix is not None or
        self.MinTileRow is not None or
        self.MaxTileRow is not None or
        self.MinTileCol is not None or
        self.MaxTileCol is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='TileMatrixLimits'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.TileMatrix is not None:
      showIndent(outfile, level)
      outfile.write('TileMatrix=%s,\n' % quote_python(self.TileMatrix).encode(ExternalEncoding))
    if self.MinTileRow is not None:
      showIndent(outfile, level)
      outfile.write('MinTileRow=%d,\n' % self.MinTileRow)
    if self.MaxTileRow is not None:
      showIndent(outfile, level)
      outfile.write('MaxTileRow=%d,\n' % self.MaxTileRow)
    if self.MinTileCol is not None:
      showIndent(outfile, level)
      outfile.write('MinTileCol=%d,\n' % self.MinTileCol)
    if self.MaxTileCol is not None:
      showIndent(outfile, level)
      outfile.write('MaxTileCol=%d,\n' % self.MaxTileCol)
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'TileMatrix':
      TileMatrix_ = child_.text
      TileMatrix_ = self.gds_validate_string(TileMatrix_, node, 'TileMatrix')
      self.TileMatrix = TileMatrix_
    elif nodeName_ == 'MinTileRow':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'MinTileRow')
      self.MinTileRow = ival_
    elif nodeName_ == 'MaxTileRow':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'MaxTileRow')
      self.MaxTileRow = ival_
    elif nodeName_ == 'MinTileCol':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'MinTileCol')
      self.MinTileCol = ival_
    elif nodeName_ == 'MaxTileCol':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'MaxTileCol')
      self.MaxTileCol = ival_
# end class TileMatrixLimits


class URLTemplateType(GeneratedsSuper):
  """Format of the resource representation that can be retrieved one
  resolved the URL template.Resource type to be retrieved. It can
  only be "tile" or "FeatureInfo"URL template. A template
  processor will be applied to substitute some variables between
  {} for their values and get a URL to a resource. We cound not
  use a anyURI type (that conforms the character restrictions
  specified in RFC2396 and excludes '{' '}' characters in some XML
  parsers) because this attribute must accept the '{' '}'
  caracters."""
  subclass = None
  superclass = None
  def __init__(self, resourceType=None, template=None, format=None, valueOf_=None):
    self.resourceType = _cast(None, resourceType)
    self.template = _cast(None, template)
    self.format = _cast(None, format)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if URLTemplateType.subclass:
      return URLTemplateType.subclass(*args_, **kwargs_)
    else:
      return URLTemplateType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_resourceType(self): return self.resourceType
  def set_resourceType(self, resourceType): self.resourceType = resourceType
  def get_template(self): return self.template
  def set_template(self, template): self.template = template
  def get_format(self): return self.format
  def set_format(self, format): self.format = format
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='URLTemplateType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='URLTemplateType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLTemplateType'):
    if self.resourceType is not None and 'resourceType' not in already_processed:
      already_processed.append('resourceType')
      outfile.write(' resourceType=%s' % (self.gds_format_string(quote_attrib(self.resourceType).encode(ExternalEncoding), input_name='resourceType'), ))
    if self.template is not None and 'template' not in already_processed:
      already_processed.append('template')
      outfile.write(' template=%s' % (self.gds_format_string(quote_attrib(self.template).encode(ExternalEncoding), input_name='template'), ))
    if self.format is not None and 'format' not in already_processed:
      already_processed.append('format')
      outfile.write(' format=%s' % (quote_attrib(self.format), ))
  def exportChildren(self, outfile, level, namespace_='', name_='URLTemplateType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='URLTemplateType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.resourceType is not None and 'resourceType' not in already_processed:
      already_processed.append('resourceType')
      showIndent(outfile, level)
      outfile.write('resourceType = "%s",\n' % (self.resourceType,))
    if self.template is not None and 'template' not in already_processed:
      already_processed.append('template')
      showIndent(outfile, level)
      outfile.write('template = "%s",\n' % (self.template,))
    if self.format is not None and 'format' not in already_processed:
      already_processed.append('format')
      showIndent(outfile, level)
      outfile.write('format = %s,\n' % (self.format,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('resourceType', node)
    if value is not None and 'resourceType' not in already_processed:
      already_processed.append('resourceType')
      self.resourceType = value
    value = find_attr_value_('template', node)
    if value is not None and 'template' not in already_processed:
      already_processed.append('template')
      self.template = value
    value = find_attr_value_('format', node)
    if value is not None and 'format' not in already_processed:
      already_processed.append('format')
      self.format = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class URLTemplateType


class Themes(GeneratedsSuper):
  """Provides a set of hierarchical themes that the client can use to
  categorize the layers by."""
  subclass = None
  superclass = None
  def __init__(self, Theme=None):
    if Theme is None:
      self.Theme = []
    else:
      self.Theme = Theme
  def factory(*args_, **kwargs_):
    if Themes.subclass:
      return Themes.subclass(*args_, **kwargs_)
    else:
      return Themes(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Theme(self): return self.Theme
  def set_Theme(self, Theme): self.Theme = Theme
  def add_Theme(self, value): self.Theme.append(value)
  def insert_Theme(self, index, value): self.Theme[index] = value
  def export(self, outfile, level, namespace_='', name_='Themes', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Themes')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Themes'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Themes', fromsubclass_=False):
    for Theme_ in self.Theme:
      Theme_.export(outfile, level, namespace_, name_='Theme')
  def hasContent_(self):
    if (
        self.Theme
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Themes'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Theme=[\n')
    level += 1
    for Theme_ in self.Theme:
      showIndent(outfile, level)
      outfile.write('model_.Theme(\n')
      Theme_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Theme':
      obj_ = Theme.factory()
      obj_.build(child_)
      self.Theme.append(obj_)
# end class Themes


class Resource(GeneratedsSuper):
  """XML encoded GetResourceByID operation response. The complexType used
  by this element shall be specified by each specific OWS."""
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None):
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Resource.subclass:
      return Resource.subclass(*args_, **kwargs_)
    else:
      return Resource(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Resource', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Resource')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Resource'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Resource', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Resource'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class Resource


class GetResourceByIdType(GeneratedsSuper):
  """Request to a service to perform the GetResourceByID operation. This
  operation allows a client to retrieve one or more identified
  resources, including datasets and resources that describe
  datasets or parameters. In this XML encoding, no "request"
  parameter is included, since the element name specifies the
  specific operation."""
  subclass = None
  superclass = None
  def __init__(self, version=None, service=None, ResourceID=None, OutputFormat=None):
    self.version = _cast(None, version)
    self.service = _cast(None, service)
    if ResourceID is None:
      self.ResourceID = []
    else:
      self.ResourceID = ResourceID
    self.OutputFormat = OutputFormat
  def factory(*args_, **kwargs_):
    if GetResourceByIdType.subclass:
      return GetResourceByIdType.subclass(*args_, **kwargs_)
    else:
      return GetResourceByIdType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ResourceID(self): return self.ResourceID
  def set_ResourceID(self, ResourceID): self.ResourceID = ResourceID
  def add_ResourceID(self, value): self.ResourceID.append(value)
  def insert_ResourceID(self, index, value): self.ResourceID[index] = value
  def get_OutputFormat(self): return self.OutputFormat
  def set_OutputFormat(self, OutputFormat): self.OutputFormat = OutputFormat
  def get_version(self): return self.version
  def set_version(self, version): self.version = version
  def get_service(self): return self.service
  def set_service(self, service): self.service = service
  def export(self, outfile, level, namespace_='', name_='GetResourceByIdType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetResourceByIdType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetResourceByIdType'):
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      outfile.write(' version=%s' % (quote_attrib(self.version), ))
    if self.service is not None and 'service' not in already_processed:
      already_processed.append('service')
      outfile.write(' service=%s' % (quote_attrib(self.service), ))
  def exportChildren(self, outfile, level, namespace_='', name_='GetResourceByIdType', fromsubclass_=False):
    for ResourceID_ in self.ResourceID:
      showIndent(outfile, level)
      outfile.write('<%sResourceID>%s</%sResourceID>\n' % (namespace_, self.gds_format_string(quote_xml(ResourceID_).encode(ExternalEncoding), input_name='ResourceID'), namespace_))
    if self.OutputFormat is not None:
      showIndent(outfile, level)
      outfile.write('<%sOutputFormat>%s</%sOutputFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.OutputFormat).encode(ExternalEncoding), input_name='OutputFormat'), namespace_))
  def hasContent_(self):
    if (
        self.ResourceID or
        self.OutputFormat is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetResourceByIdType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      showIndent(outfile, level)
      outfile.write('version = %s,\n' % (self.version,))
    if self.service is not None and 'service' not in already_processed:
      already_processed.append('service')
      showIndent(outfile, level)
      outfile.write('service = %s,\n' % (self.service,))
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('ResourceID=[\n')
    level += 1
    for ResourceID_ in self.ResourceID:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(ResourceID_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.OutputFormat is not None:
      showIndent(outfile, level)
      outfile.write('OutputFormat=%s,\n' % quote_python(self.OutputFormat).encode(ExternalEncoding))
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('version', node)
    if value is not None and 'version' not in already_processed:
      already_processed.append('version')
      self.version = value
    value = find_attr_value_('service', node)
    if value is not None and 'service' not in already_processed:
      already_processed.append('service')
      self.service = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ResourceID':
      ResourceID_ = child_.text
      ResourceID_ = self.gds_validate_string(ResourceID_, node, 'ResourceID')
      self.ResourceID.append(ResourceID_)
    elif nodeName_ == 'OutputFormat':
      OutputFormat_ = child_.text
      OutputFormat_ = self.gds_validate_string(OutputFormat_, node, 'OutputFormat')
      self.OutputFormat = OutputFormat_
# end class GetResourceByIdType


class DescriptionType(GeneratedsSuper):
  """Human-readable descriptive information for the object it is included
  within. This type shall be extended if needed for specific OWS
  use to include additional metadata for each type of information.
  This type shall not be restricted for a specific OWS to change
  the multiplicity (or optionality) of some elements. If the
  xml:lang attribute is not included in a Title, Abstract or
  Keyword element, then no language is specified for that element
  unless specified by another means. All Title, Abstract and
  Keyword elements in the same Description that share the same
  xml:lang attribute value represent the description of the parent
  object in that language. Multiple Title or Abstract elements
  shall not exist in the same Description with the same xml:lang
  attribute value unless otherwise specified."""
  subclass = None
  superclass = None
  def __init__(self, Title=None, Abstract=None, Keywords=None):
    if Title is None:
      self.Title = []
    else:
      self.Title = Title
    if Abstract is None:
      self.Abstract = []
    else:
      self.Abstract = Abstract
    if Keywords is None:
      self.Keywords = []
    else:
      self.Keywords = Keywords
  def factory(*args_, **kwargs_):
    if DescriptionType.subclass:
      return DescriptionType.subclass(*args_, **kwargs_)
    else:
      return DescriptionType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Title(self): return self.Title
  def set_Title(self, Title): self.Title = Title
  def add_Title(self, value): self.Title.append(value)
  def insert_Title(self, index, value): self.Title[index] = value
  def get_Abstract(self): return self.Abstract
  def set_Abstract(self, Abstract): self.Abstract = Abstract
  def add_Abstract(self, value): self.Abstract.append(value)
  def insert_Abstract(self, index, value): self.Abstract[index] = value
  def get_Keywords(self): return self.Keywords
  def set_Keywords(self, Keywords): self.Keywords = Keywords
  def add_Keywords(self, value): self.Keywords.append(value)
  def insert_Keywords(self, index, value): self.Keywords[index] = value
  def export(self, outfile, level, namespace_='', name_='DescriptionType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DescriptionType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DescriptionType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='DescriptionType', fromsubclass_=False):
    for Title_ in self.Title:
      Title_.export(outfile, level, namespace_, name_='Title')
    for Abstract_ in self.Abstract:
      Abstract_.export(outfile, level, namespace_, name_='Abstract')
    for Keywords_ in self.Keywords:
      Keywords_.export(outfile, level, namespace_, name_='Keywords')
  def hasContent_(self):
    if (
        self.Title or
        self.Abstract or
        self.Keywords
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DescriptionType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Title=[\n')
    level += 1
    for Title_ in self.Title:
      showIndent(outfile, level)
      outfile.write('model_.Title(\n')
      Title_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Abstract=[\n')
    level += 1
    for Abstract_ in self.Abstract:
      showIndent(outfile, level)
      outfile.write('model_.Abstract(\n')
      Abstract_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Keywords=[\n')
    level += 1
    for Keywords_ in self.Keywords:
      showIndent(outfile, level)
      outfile.write('model_.Keywords(\n')
      Keywords_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Title':
      obj_ = LanguageStringType.factory()
      obj_.build(child_)
      self.Title.append(obj_)
    elif nodeName_ == 'Abstract':
      obj_ = LanguageStringType.factory()
      obj_.build(child_)
      self.Abstract.append(obj_)
    elif nodeName_ == 'Keywords':
      obj_ = KeywordsType.factory()
      obj_.build(child_)
      self.Keywords.append(obj_)
# end class DescriptionType


class BasicIdentificationType(DescriptionType):
  """Basic metadata identifying and describing a set of data."""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, Metadata=None):
    super(BasicIdentificationType, self).__init__(Title, Abstract, Keywords, )
    self.Identifier = Identifier
    if Metadata is None:
      self.Metadata = []
    else:
      self.Metadata = Metadata
  def factory(*args_, **kwargs_):
    if BasicIdentificationType.subclass:
      return BasicIdentificationType.subclass(*args_, **kwargs_)
    else:
      return BasicIdentificationType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_Metadata(self): return self.Metadata
  def set_Metadata(self, Metadata): self.Metadata = Metadata
  def add_Metadata(self, value): self.Metadata.append(value)
  def insert_Metadata(self, index, value): self.Metadata[index] = value
  def export(self, outfile, level, namespace_='', name_='BasicIdentificationType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='BasicIdentificationType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="BasicIdentificationType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasicIdentificationType'):
    super(BasicIdentificationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BasicIdentificationType')
  def exportChildren(self, outfile, level, namespace_='', name_='BasicIdentificationType', fromsubclass_=False):
    super(BasicIdentificationType, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier')
    for Metadata_ in self.Metadata:
      Metadata_.export(outfile, level, namespace_, name_='Metadata')
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.Metadata or
        super(BasicIdentificationType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='BasicIdentificationType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(BasicIdentificationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(BasicIdentificationType, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('Metadata=[\n')
    level += 1
    for Metadata_ in self.Metadata:
      showIndent(outfile, level)
      outfile.write('model_.Metadata(\n')
      Metadata_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(BasicIdentificationType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'Metadata':
      obj_ = MetadataType.factory()
      obj_.build(child_)
      self.Metadata.append(obj_)
    super(BasicIdentificationType, self).buildChildren(child_, node, nodeName_, True)
# end class BasicIdentificationType


class IdentificationType(BasicIdentificationType):
  """Extended metadata identifying and describing a set of data. This
  type shall be extended if needed for each specific OWS to
  include additional metadata for each type of dataset. If needed,
  this type should first be restricted for each specific OWS to
  change the multiplicity (or optionality) of some elements."""
  subclass = None
  superclass = BasicIdentificationType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, Metadata=None, BoundingBox=None, OutputFormat=None, AvailableCRS=None):
    super(IdentificationType, self).__init__(Title, Abstract, Keywords, Identifier, Metadata, )
    if BoundingBox is None:
      self.BoundingBox = []
    else:
      self.BoundingBox = BoundingBox
    if OutputFormat is None:
      self.OutputFormat = []
    else:
      self.OutputFormat = OutputFormat
    if AvailableCRS is None:
      self.AvailableCRS = []
    else:
      self.AvailableCRS = AvailableCRS
  def factory(*args_, **kwargs_):
    if IdentificationType.subclass:
      return IdentificationType.subclass(*args_, **kwargs_)
    else:
      return IdentificationType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_BoundingBox(self): return self.BoundingBox
  def set_BoundingBox(self, BoundingBox): self.BoundingBox = BoundingBox
  def add_BoundingBox(self, value): self.BoundingBox.append(value)
  def insert_BoundingBox(self, index, value): self.BoundingBox[index] = value
  def get_OutputFormat(self): return self.OutputFormat
  def set_OutputFormat(self, OutputFormat): self.OutputFormat = OutputFormat
  def add_OutputFormat(self, value): self.OutputFormat.append(value)
  def insert_OutputFormat(self, index, value): self.OutputFormat[index] = value
  def get_AvailableCRS(self): return self.AvailableCRS
  def set_AvailableCRS(self, AvailableCRS): self.AvailableCRS = AvailableCRS
  def add_AvailableCRS(self, value): self.AvailableCRS.append(value)
  def insert_AvailableCRS(self, index, value): self.AvailableCRS[index] = value
  def export(self, outfile, level, namespace_='', name_='IdentificationType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='IdentificationType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="IdentificationType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentificationType'):
    super(IdentificationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentificationType')
  def exportChildren(self, outfile, level, namespace_='', name_='IdentificationType', fromsubclass_=False):
    super(IdentificationType, self).exportChildren(outfile, level, namespace_, name_, True)
    for BoundingBox_ in self.BoundingBox:
      BoundingBox_.export(outfile, level, namespace_, name_='BoundingBox')
    for OutputFormat_ in self.OutputFormat:
      showIndent(outfile, level)
      outfile.write('<%sOutputFormat>%s</%sOutputFormat>\n' % (namespace_, self.gds_format_string(quote_xml(OutputFormat_).encode(ExternalEncoding), input_name='OutputFormat'), namespace_))
    for AvailableCRS_ in self.AvailableCRS:
      showIndent(outfile, level)
      outfile.write('<%sAvailableCRS>%s</%sAvailableCRS>\n' % (namespace_, self.gds_format_string(quote_xml(AvailableCRS_).encode(ExternalEncoding), input_name='AvailableCRS'), namespace_))
  def hasContent_(self):
    if (
        self.BoundingBox or
        self.OutputFormat or
        self.AvailableCRS or
        super(IdentificationType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='IdentificationType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(IdentificationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(IdentificationType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('BoundingBox=[\n')
    level += 1
    for BoundingBox_ in self.BoundingBox:
      showIndent(outfile, level)
      outfile.write('model_.BoundingBox(\n')
      BoundingBox_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('OutputFormat=[\n')
    level += 1
    for OutputFormat_ in self.OutputFormat:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(OutputFormat_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('AvailableCRS=[\n')
    level += 1
    for AvailableCRS_ in self.AvailableCRS:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(AvailableCRS_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(IdentificationType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'BoundingBox':
      obj_ = BoundingBoxType.factory()
      obj_.build(child_)
      self.BoundingBox.append(obj_)
    elif nodeName_ == 'OutputFormat':
      OutputFormat_ = child_.text
      OutputFormat_ = self.gds_validate_string(OutputFormat_, node, 'OutputFormat')
      self.OutputFormat.append(OutputFormat_)
    elif nodeName_ == 'AvailableCRS':
      AvailableCRS_ = child_.text
      AvailableCRS_ = self.gds_validate_string(AvailableCRS_, node, 'AvailableCRS')
      self.AvailableCRS.append(AvailableCRS_)
    super(IdentificationType, self).buildChildren(child_, node, nodeName_, True)
# end class IdentificationType


class MetadataType(GeneratedsSuper):
  """This element either references or contains more metadata about the
  element that includes this element. To reference metadata stored
  remotely, at least the xlinks:href attribute in xlink:simpleLink
  shall be included. Either at least one of the attributes in
  xlink:simpleLink or a substitute for the AbstractMetaData
  element shall be included, but not both. An Implementation
  Specification can restrict the contents of this element to
  always be a reference or always contain metadata. (Informative:
  This element was adapted from the metaDataProperty element in
  GML 3.0.) Reference to metadata recorded elsewhere, either
  external to this XML document or within it. Whenever practical,
  the xlink:href attribute with type anyURI should include a URL
  from which this metadata can be electronically retrieved.
  Optional reference to the aspect of the element which includes
  this "metadata" element that this metadata provides more
  information about."""
  subclass = None
  superclass = None
  def __init__(self, about=None, title=None, show=None, actuate=None, href=None, role=None, arcrole=None, type_=None, AbstractMetaData=None):
    self.about = _cast(None, about)
    self.title = _cast(None, title)
    self.show = _cast(None, show)
    self.actuate = _cast(None, actuate)
    self.href = _cast(None, href)
    self.role = _cast(None, role)
    self.arcrole = _cast(None, arcrole)
    self.type_ = _cast(None, type_)
    self.AbstractMetaData = AbstractMetaData
  def factory(*args_, **kwargs_):
    if MetadataType.subclass:
      return MetadataType.subclass(*args_, **kwargs_)
    else:
      return MetadataType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_AbstractMetaData(self): return self.AbstractMetaData
  def set_AbstractMetaData(self, AbstractMetaData): self.AbstractMetaData = AbstractMetaData
  def get_about(self): return self.about
  def set_about(self, about): self.about = about
  def get_title(self): return self.title
  def set_title(self, title): self.title = title
  def get_show(self): return self.show
  def set_show(self, show): self.show = show
  def get_actuate(self): return self.actuate
  def set_actuate(self, actuate): self.actuate = actuate
  def get_href(self): return self.href
  def set_href(self, href): self.href = href
  def get_role(self): return self.role
  def set_role(self, role): self.role = role
  def get_arcrole(self): return self.arcrole
  def set_arcrole(self, arcrole): self.arcrole = arcrole
  def get_type(self): return self.type_
  def set_type(self, type_): self.type_ = type_
  def export(self, outfile, level, namespace_='', name_='MetadataType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='MetadataType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataType'):
    if self.about is not None and 'about' not in already_processed:
      already_processed.append('about')
      outfile.write(' about=%s' % (self.gds_format_string(quote_attrib(self.about).encode(ExternalEncoding), input_name='about'), ))
    if self.title is not None and 'title' not in already_processed:
      already_processed.append('title')
      outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
    if self.show is not None and 'show' not in already_processed:
      already_processed.append('show')
      outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
    if self.actuate is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
    if self.href is not None and 'href' not in already_processed:
      already_processed.append('href')
      outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    if self.role is not None and 'role' not in already_processed:
      already_processed.append('role')
      outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
    if self.arcrole is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='MetadataType', fromsubclass_=False):
    AbstractMetaData_.export(outfile, level, namespace_, name_='AbstractMetaData')
  def hasContent_(self):
    if (
        self.AbstractMetaData is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='MetadataType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.about is not None and 'about' not in already_processed:
      already_processed.append('about')
      showIndent(outfile, level)
      outfile.write('about = "%s",\n' % (self.about,))
    if self.title is not None and 'title' not in already_processed:
      already_processed.append('title')
      showIndent(outfile, level)
      outfile.write('title = "%s",\n' % (self.title,))
    if self.show is not None and 'show' not in already_processed:
      already_processed.append('show')
      showIndent(outfile, level)
      outfile.write('show = "%s",\n' % (self.show,))
    if self.actuate is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      showIndent(outfile, level)
      outfile.write('actuate = "%s",\n' % (self.actuate,))
    if self.href is not None and 'href' not in already_processed:
      already_processed.append('href')
      showIndent(outfile, level)
      outfile.write('href = "%s",\n' % (self.href,))
    if self.role is not None and 'role' not in already_processed:
      already_processed.append('role')
      showIndent(outfile, level)
      outfile.write('role = "%s",\n' % (self.role,))
    if self.arcrole is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      showIndent(outfile, level)
      outfile.write('arcrole = "%s",\n' % (self.arcrole,))
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      showIndent(outfile, level)
      outfile.write('type_ = "%s",\n' % (self.type_,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.AbstractMetaData is not None:
      showIndent(outfile, level)
      outfile.write('AbstractMetaData=model_.AbstractMetaData(\n')
      self.AbstractMetaData.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('about', node)
    if value is not None and 'about' not in already_processed:
      already_processed.append('about')
      self.about = value
    value = find_attr_value_('title', node)
    if value is not None and 'title' not in already_processed:
      already_processed.append('title')
      self.title = value
    value = find_attr_value_('show', node)
    if value is not None and 'show' not in already_processed:
      already_processed.append('show')
      self.show = value
    value = find_attr_value_('actuate', node)
    if value is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      self.actuate = value
    value = find_attr_value_('href', node)
    if value is not None and 'href' not in already_processed:
      already_processed.append('href')
      self.href = value
    value = find_attr_value_('role', node)
    if value is not None and 'role' not in already_processed:
      already_processed.append('role')
      self.role = value
    value = find_attr_value_('arcrole', node)
    if value is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      self.arcrole = value
    value = find_attr_value_('type', node)
    if value is not None and 'type' not in already_processed:
      already_processed.append('type')
      self.type_ = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'AbstractMetaData':
      type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
      if type_name_ is None:
        type_name_ = child_.attrib.get('type')
      if type_name_ is not None:
        type_names_ = type_name_.split(':')
        if len(type_names_) == 1:
          type_name_ = type_names_[0]
        else:
          type_name_ = type_names_[1]
        class_ = globals()[type_name_]
        obj_ = class_.factory()
        obj_.build(child_)
      else:
        raise NotImplementedError(
            'Class not implemented for <AbstractMetaData> element')
      self.set_AbstractMetaData(obj_)
# end class MetadataType


class AbstractMetaData(GeneratedsSuper):
  """Abstract element containing more metadata about the element that
  includes the containing "metadata" element. A specific server
  implementation, or an Implementation Specification, can define
  concrete elements in the AbstractMetaData substitution group."""
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None):
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if AbstractMetaData.subclass:
      return AbstractMetaData.subclass(*args_, **kwargs_)
    else:
      return AbstractMetaData(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='AbstractMetaData', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AbstractMetaData')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMetaData'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AbstractMetaData', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AbstractMetaData'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class AbstractMetaData


class BoundingBoxType(GeneratedsSuper):
  """XML encoded minimum rectangular bounding box (or region) parameter,
  surrounding all the associated data. This type is adapted from
  the EnvelopeType of GML 3.1, with modified contents and
  documentation for encoding a MINIMUM size box SURROUNDING all
  associated data. Usually references the definition of a CRS, as
  specified in [OGC Topic 2]. Such a CRS definition can be XML
  encoded using the gml:CoordinateReferenceSystemType in [GML
  3.1]. For well known references, it is not required that a CRS
  definition exist at the location the URI points to. If no anyURI
  value is included, the applicable CRS must be either: a)
  Specified outside the bounding box, but inside a data structure
  that includes this bounding box, as specified for a specific OWS
  use of this bounding box type. b) Fixed and specified in the
  Implementation Specification for a specific OWS use of the
  bounding box type. The number of dimensions in this CRS (the
  length of a coordinate sequence in this use of the
  PositionType). This number is specified by the CRS definition,
  but can also be specified here."""
  subclass = None
  superclass = None
  def __init__(self, crs=None, dimensions=None, LowerCorner=None, UpperCorner=None):
    self.crs = _cast(None, crs)
    self.dimensions = _cast(int, dimensions)
    self.LowerCorner = LowerCorner
    self.UpperCorner = UpperCorner
  def factory(*args_, **kwargs_):
    if BoundingBoxType.subclass:
      return BoundingBoxType.subclass(*args_, **kwargs_)
    else:
      return BoundingBoxType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_LowerCorner(self): return self.LowerCorner
  def set_LowerCorner(self, LowerCorner): self.LowerCorner = LowerCorner
  def validate_PositionType(self, value):
    # Validate type PositionType, a restriction on double.
    pass
  def get_UpperCorner(self): return self.UpperCorner
  def set_UpperCorner(self, UpperCorner): self.UpperCorner = UpperCorner
  def get_crs(self): return self.crs
  def set_crs(self, crs): self.crs = crs
  def get_dimensions(self): return self.dimensions
  def set_dimensions(self, dimensions): self.dimensions = dimensions
  def export(self, outfile, level, namespace_='', name_='BoundingBoxType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='BoundingBoxType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundingBoxType'):
    if self.crs is not None and 'crs' not in already_processed:
      already_processed.append('crs')
      outfile.write(' crs=%s' % (self.gds_format_string(quote_attrib(self.crs).encode(ExternalEncoding), input_name='crs'), ))
    if self.dimensions is not None and 'dimensions' not in already_processed:
      already_processed.append('dimensions')
      outfile.write(' dimensions="%s"' % self.gds_format_integer(self.dimensions, input_name='dimensions'))
  def exportChildren(self, outfile, level, namespace_='', name_='BoundingBoxType', fromsubclass_=False):
    if self.LowerCorner is not None:
      showIndent(outfile, level)
      outfile.write('<%sLowerCorner>%s</%sLowerCorner>\n' % (namespace_, self.gds_format_double_list(self.LowerCorner, input_name='LowerCorner'), namespace_))
    if self.UpperCorner is not None:
      showIndent(outfile, level)
      outfile.write('<%sUpperCorner>%s</%sUpperCorner>\n' % (namespace_, self.gds_format_double_list(self.UpperCorner, input_name='UpperCorner'), namespace_))
  def hasContent_(self):
    if (
        self.LowerCorner is not None or
        self.UpperCorner is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='BoundingBoxType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.crs is not None and 'crs' not in already_processed:
      already_processed.append('crs')
      showIndent(outfile, level)
      outfile.write('crs = "%s",\n' % (self.crs,))
    if self.dimensions is not None and 'dimensions' not in already_processed:
      already_processed.append('dimensions')
      showIndent(outfile, level)
      outfile.write('dimensions = %d,\n' % (self.dimensions,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.LowerCorner is not None:
      showIndent(outfile, level)
      outfile.write('LowerCorner=%e,\n' % self.LowerCorner)
    if self.UpperCorner is not None:
      showIndent(outfile, level)
      outfile.write('UpperCorner=%e,\n' % self.UpperCorner)
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('crs', node)
    if value is not None and 'crs' not in already_processed:
      already_processed.append('crs')
      self.crs = value
    value = find_attr_value_('dimensions', node)
    if value is not None and 'dimensions' not in already_processed:
      already_processed.append('dimensions')
      try:
        self.dimensions = int(value)
      except ValueError, exp:
        raise_parse_error(node, 'Bad integer attribute: %s' % exp)
      if self.dimensions <= 0:
        raise_parse_error(node, 'Invalid PositiveInteger')
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'LowerCorner':
      LowerCorner_ = child_.text
      LowerCorner_ = self.gds_validate_double_list(LowerCorner_, node, 'LowerCorner')
      self.LowerCorner = LowerCorner_
      self.LowerCorner = self.LowerCorner.split()
      self.validate_PositionType(self.LowerCorner)    # validate type PositionType
    elif nodeName_ == 'UpperCorner':
      UpperCorner_ = child_.text
      UpperCorner_ = self.gds_validate_double_list(UpperCorner_, node, 'UpperCorner')
      self.UpperCorner = UpperCorner_
      self.UpperCorner = self.UpperCorner.split()
      self.validate_PositionType(self.UpperCorner)    # validate type PositionType
# end class BoundingBoxType


class WGS84BoundingBoxType(GeneratedsSuper):
  """XML encoded minimum rectangular bounding box (or region) parameter,
  surrounding all the associated data. This box is specialized for
  use with the 2D WGS 84 coordinate reference system with decimal
  values of longitude and latitude. This type is adapted from the
  general BoundingBoxType, with modified contents and
  documentation for use with the 2D WGS 84 coordinate reference
  system. This attribute can be included when considered useful.
  When included, this attribute shall reference the 2D WGS 84
  coordinate reference system with longitude before latitude and
  decimal values of longitude and latitude. The number of
  dimensions in this CRS (the length of a coordinate sequence in
  this use of the PositionType). This number is specified by the
  CRS definition, but can also be specified here."""
  subclass = None
  superclass = None
  def __init__(self, crs=None, dimensions=None, LowerCorner=None, UpperCorner=None):
    self.crs = _cast(None, crs)
    self.dimensions = _cast(int, dimensions)
    self.LowerCorner = LowerCorner
    self.UpperCorner = UpperCorner
  def factory(*args_, **kwargs_):
    if WGS84BoundingBoxType.subclass:
      return WGS84BoundingBoxType.subclass(*args_, **kwargs_)
    else:
      return WGS84BoundingBoxType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_LowerCorner(self): return self.LowerCorner
  def set_LowerCorner(self, LowerCorner): self.LowerCorner = LowerCorner
  def validate_PositionType2D(self, value):
    # Validate type PositionType2D, a restriction on ows:PositionType.
    pass
  def get_UpperCorner(self): return self.UpperCorner
  def set_UpperCorner(self, UpperCorner): self.UpperCorner = UpperCorner
  def get_crs(self): return self.crs
  def set_crs(self, crs): self.crs = crs
  def get_dimensions(self): return self.dimensions
  def set_dimensions(self, dimensions): self.dimensions = dimensions
  def export(self, outfile, level, namespace_='', name_='WGS84BoundingBoxType', namespacedef_=''):
    if namespace_ == '':
      namespace_ = 'ows:'

    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='WGS84BoundingBoxType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WGS84BoundingBoxType'):
    if self.crs is not None and 'crs' not in already_processed:
      already_processed.append('crs')
      outfile.write(' crs=%s' % (self.gds_format_string(quote_attrib(self.crs).encode(ExternalEncoding), input_name='crs'), ))
    if self.dimensions is not None and 'dimensions' not in already_processed:
      already_processed.append('dimensions')
      outfile.write(' dimensions="%s"' % self.gds_format_integer(self.dimensions, input_name='dimensions'))
  def exportChildren(self, outfile, level, namespace_='', name_='WGS84BoundingBoxType', fromsubclass_=False):
    if self.LowerCorner is not None:
      showIndent(outfile, level)
      outfile.write('<%sLowerCorner>%s</%sLowerCorner>\n' % (namespace_, self.gds_format_string(quote_xml(self.LowerCorner).encode(ExternalEncoding), input_name='LowerCorner'), namespace_))
    if self.UpperCorner is not None:
      showIndent(outfile, level)
      outfile.write('<%sUpperCorner>%s</%sUpperCorner>\n' % (namespace_, self.gds_format_string(quote_xml(self.UpperCorner).encode(ExternalEncoding), input_name='UpperCorner'), namespace_))
  def hasContent_(self):
    if (
        self.LowerCorner is not None or
        self.UpperCorner is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='WGS84BoundingBoxType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.crs is not None and 'crs' not in already_processed:
      already_processed.append('crs')
      showIndent(outfile, level)
      outfile.write('crs = "%s",\n' % (self.crs,))
    if self.dimensions is not None and 'dimensions' not in already_processed:
      already_processed.append('dimensions')
      showIndent(outfile, level)
      outfile.write('dimensions = %d,\n' % (self.dimensions,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.LowerCorner is not None:
      showIndent(outfile, level)
      outfile.write('LowerCorner=model_.ows_PositionType(\n')
      self.LowerCorner.exportLiteral(outfile, level, name_='LowerCorner')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.UpperCorner is not None:
      showIndent(outfile, level)
      outfile.write('UpperCorner=model_.ows_PositionType(\n')
      self.UpperCorner.exportLiteral(outfile, level, name_='UpperCorner')
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('crs', node)
    if value is not None and 'crs' not in already_processed:
      already_processed.append('crs')
      self.crs = value
    value = find_attr_value_('dimensions', node)
    if value is not None and 'dimensions' not in already_processed:
      already_processed.append('dimensions')
      try:
        self.dimensions = int(value)
      except ValueError, exp:
        raise_parse_error(node, 'Bad integer attribute: %s' % exp)
      if self.dimensions <= 0:
        raise_parse_error(node, 'Invalid PositiveInteger')
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'LowerCorner':
      obj_ = None
      self.set_LowerCorner(obj_)
      self.validate_PositionType2D(self.LowerCorner)    # validate type PositionType2D
    elif nodeName_ == 'UpperCorner':
      obj_ = None
      self.set_UpperCorner(obj_)
      self.validate_PositionType2D(self.UpperCorner)    # validate type PositionType2D
# end class WGS84BoundingBoxType


class LanguageStringType(GeneratedsSuper):
  """Text string with the language of the string identified as
  recommended in the XML 1.0 W3C Recommendation, section 2.12."""
  subclass = None
  superclass = None
  def __init__(self, lang=None, valueOf_=None):
    self.lang = _cast(None, lang)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if LanguageStringType.subclass:
      return LanguageStringType.subclass(*args_, **kwargs_)
    else:
      return LanguageStringType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_lang(self): return self.lang
  def set_lang(self, lang): self.lang = lang
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='LanguageStringType', namespacedef_=''):
    if namespace_ == '':
      namespace_ = 'ows:'

    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='LanguageStringType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LanguageStringType'):
    if self.lang is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='LanguageStringType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='LanguageStringType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.lang is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      showIndent(outfile, level)
      outfile.write('lang = "%s",\n' % (self.lang,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('lang', node)
    if value is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      self.lang = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class LanguageStringType


class KeywordsType(GeneratedsSuper):
  """Unordered list of one or more commonly used or formalised word(s) or
  phrase(s) used to describe the subject. When needed, the
  optional "type" can name the type of the associated list of
  keywords that shall all have the same type. Also when needed,
  the codeSpace attribute of that "type" can reference the type
  name authority and/or thesaurus. If the xml:lang attribute is
  not included in a Keyword element, then no language is specified
  for that element unless specified by another means. All Keyword
  elements in the same Keywords element that share the same
  xml:lang attribute value represent different keywords in that
  language. For OWS use, the optional thesaurusName element was
  omitted as being complex information that could be referenced by
  the codeSpace attribute of the Type element."""
  subclass = None
  superclass = None
  def __init__(self, Keyword=None, Type=None):
    if Keyword is None:
      self.Keyword = []
    else:
      self.Keyword = Keyword
    self.Type = Type
  def factory(*args_, **kwargs_):
    if KeywordsType.subclass:
      return KeywordsType.subclass(*args_, **kwargs_)
    else:
      return KeywordsType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Keyword(self): return self.Keyword
  def set_Keyword(self, Keyword): self.Keyword = Keyword
  def add_Keyword(self, value): self.Keyword.append(value)
  def insert_Keyword(self, index, value): self.Keyword[index] = value
  def get_Type(self): return self.Type
  def set_Type(self, Type): self.Type = Type
  def export(self, outfile, level, namespace_='', name_='KeywordsType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='KeywordsType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeywordsType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='KeywordsType', fromsubclass_=False):
    for Keyword_ in self.Keyword:
      Keyword_.export(outfile, level, namespace_, name_='Keyword')
    if self.Type:
      self.Type.export(outfile, level, namespace_, name_='Type')
  def hasContent_(self):
    if (
        self.Keyword or
        self.Type is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='KeywordsType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Keyword=[\n')
    level += 1
    for Keyword_ in self.Keyword:
      showIndent(outfile, level)
      outfile.write('model_.LanguageStringType(\n')
      Keyword_.exportLiteral(outfile, level, name_='LanguageStringType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.Type is not None:
      showIndent(outfile, level)
      outfile.write('Type=model_.CodeType(\n')
      self.Type.exportLiteral(outfile, level, name_='Type')
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Keyword':
      obj_ = LanguageStringType.factory()
      obj_.build(child_)
      self.Keyword.append(obj_)
    elif nodeName_ == 'Type':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Type(obj_)
# end class KeywordsType


class CodeType(GeneratedsSuper):
  """Name or code with an (optional) authority. If the codeSpace
  attribute is present, its value shall reference a dictionary,
  thesaurus, or authority for the name or code, such as the
  organisation who assigned the value, or the dictionary from
  which it is taken. Type copied from basicTypes.xsd of GML 3 with
  documentation edited, for possible use outside the
  ServiceIdentification section of a service metadata document."""
  subclass = None
  superclass = None
  def __init__(self, codeSpace=None, valueOf_=None):
    self.codeSpace = _cast(None, codeSpace)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if CodeType.subclass:
      return CodeType.subclass(*args_, **kwargs_)
    else:
      return CodeType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_codeSpace(self): return self.codeSpace
  def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='CodeType', namespacedef_=''):
    if namespace_ == '':
      namespace_ = 'ows:'

    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='CodeType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeType'):
    if self.codeSpace is not None and 'codeSpace' not in already_processed:
      already_processed.append('codeSpace')
      outfile.write(' codeSpace=%s' % (self.gds_format_string(quote_attrib(self.codeSpace).encode(ExternalEncoding), input_name='codeSpace'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='CodeType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='CodeType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.codeSpace is not None and 'codeSpace' not in already_processed:
      already_processed.append('codeSpace')
      showIndent(outfile, level)
      outfile.write('codeSpace = "%s",\n' % (self.codeSpace,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('codeSpace', node)
    if value is not None and 'codeSpace' not in already_processed:
      already_processed.append('codeSpace')
      self.codeSpace = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class CodeType


class ResponsiblePartyType(GeneratedsSuper):
  """Identification of, and means of communication with, person
  responsible for the server. At least one of IndividualName,
  OrganisationName, or PositionName shall be included."""
  subclass = None
  superclass = None
  def __init__(self, IndividualName=None, OrganisationName=None, PositionName=None, ContactInfo=None, Role=None):
    self.IndividualName = IndividualName
    self.OrganisationName = OrganisationName
    self.PositionName = PositionName
    self.ContactInfo = ContactInfo
    self.Role = Role
  def factory(*args_, **kwargs_):
    if ResponsiblePartyType.subclass:
      return ResponsiblePartyType.subclass(*args_, **kwargs_)
    else:
      return ResponsiblePartyType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_IndividualName(self): return self.IndividualName
  def set_IndividualName(self, IndividualName): self.IndividualName = IndividualName
  def get_OrganisationName(self): return self.OrganisationName
  def set_OrganisationName(self, OrganisationName): self.OrganisationName = OrganisationName
  def get_PositionName(self): return self.PositionName
  def set_PositionName(self, PositionName): self.PositionName = PositionName
  def get_ContactInfo(self): return self.ContactInfo
  def set_ContactInfo(self, ContactInfo): self.ContactInfo = ContactInfo
  def get_Role(self): return self.Role
  def set_Role(self, Role): self.Role = Role
  def export(self, outfile, level, namespace_='', name_='ResponsiblePartyType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ResponsiblePartyType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponsiblePartyType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ResponsiblePartyType', fromsubclass_=False):
    if self.IndividualName is not None:
      showIndent(outfile, level)
      outfile.write('<%sIndividualName>%s</%sIndividualName>\n' % (namespace_, self.gds_format_string(quote_xml(self.IndividualName).encode(ExternalEncoding), input_name='IndividualName'), namespace_))
    if self.OrganisationName is not None:
      showIndent(outfile, level)
      outfile.write('<%sOrganisationName>%s</%sOrganisationName>\n' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationName).encode(ExternalEncoding), input_name='OrganisationName'), namespace_))
    if self.PositionName is not None:
      showIndent(outfile, level)
      outfile.write('<%sPositionName>%s</%sPositionName>\n' % (namespace_, self.gds_format_string(quote_xml(self.PositionName).encode(ExternalEncoding), input_name='PositionName'), namespace_))
    if self.ContactInfo:
      self.ContactInfo.export(outfile, level, namespace_, name_='ContactInfo')
    if self.Role:
      self.Role.export(outfile, level, namespace_, name_='Role', )
  def hasContent_(self):
    if (
        self.IndividualName is not None or
        self.OrganisationName is not None or
        self.PositionName is not None or
        self.ContactInfo is not None or
        self.Role is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ResponsiblePartyType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.IndividualName is not None:
      showIndent(outfile, level)
      outfile.write('IndividualName=%s,\n' % quote_python(self.IndividualName).encode(ExternalEncoding))
    if self.OrganisationName is not None:
      showIndent(outfile, level)
      outfile.write('OrganisationName=%s,\n' % quote_python(self.OrganisationName).encode(ExternalEncoding))
    if self.PositionName is not None:
      showIndent(outfile, level)
      outfile.write('PositionName=%s,\n' % quote_python(self.PositionName).encode(ExternalEncoding))
    if self.ContactInfo is not None:
      showIndent(outfile, level)
      outfile.write('ContactInfo=model_.ContactInfo(\n')
      self.ContactInfo.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Role is not None:
      showIndent(outfile, level)
      outfile.write('Role=model_.Role(\n')
      self.Role.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'IndividualName':
      IndividualName_ = child_.text
      IndividualName_ = self.gds_validate_string(IndividualName_, node, 'IndividualName')
      self.IndividualName = IndividualName_
    elif nodeName_ == 'OrganisationName':
      OrganisationName_ = child_.text
      OrganisationName_ = self.gds_validate_string(OrganisationName_, node, 'OrganisationName')
      self.OrganisationName = OrganisationName_
    elif nodeName_ == 'PositionName':
      PositionName_ = child_.text
      PositionName_ = self.gds_validate_string(PositionName_, node, 'PositionName')
      self.PositionName = PositionName_
    elif nodeName_ == 'ContactInfo':
      obj_ = ContactType.factory()
      obj_.build(child_)
      self.set_ContactInfo(obj_)
    elif nodeName_ == 'Role':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Role(obj_)
# end class ResponsiblePartyType


class ResponsiblePartySubsetType(GeneratedsSuper):
  """Identification of, and means of communication with, person
  responsible for the server. For OWS use in the ServiceProvider
  section of a service metadata document, the optional
  organizationName element was removed, since this type is always
  used with the ProviderName element which provides that
  information. The mandatory "role" element was changed to
  optional, since no clear use of this information is known in the
  ServiceProvider section."""
  subclass = None
  superclass = None
  def __init__(self, IndividualName=None, PositionName=None, ContactInfo=None, Role=None):
    self.IndividualName = IndividualName
    self.PositionName = PositionName
    self.ContactInfo = ContactInfo
    self.Role = Role
  def factory(*args_, **kwargs_):
    if ResponsiblePartySubsetType.subclass:
      return ResponsiblePartySubsetType.subclass(*args_, **kwargs_)
    else:
      return ResponsiblePartySubsetType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_IndividualName(self): return self.IndividualName
  def set_IndividualName(self, IndividualName): self.IndividualName = IndividualName
  def get_PositionName(self): return self.PositionName
  def set_PositionName(self, PositionName): self.PositionName = PositionName
  def get_ContactInfo(self): return self.ContactInfo
  def set_ContactInfo(self, ContactInfo): self.ContactInfo = ContactInfo
  def get_Role(self): return self.Role
  def set_Role(self, Role): self.Role = Role
  def export(self, outfile, level, namespace_='', name_='ResponsiblePartySubsetType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ResponsiblePartySubsetType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponsiblePartySubsetType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ResponsiblePartySubsetType', fromsubclass_=False):
    if self.IndividualName is not None:
      showIndent(outfile, level)
      outfile.write('<%sIndividualName>%s</%sIndividualName>\n' % (namespace_, self.gds_format_string(quote_xml(self.IndividualName).encode(ExternalEncoding), input_name='IndividualName'), namespace_))
    if self.PositionName is not None:
      showIndent(outfile, level)
      outfile.write('<%sPositionName>%s</%sPositionName>\n' % (namespace_, self.gds_format_string(quote_xml(self.PositionName).encode(ExternalEncoding), input_name='PositionName'), namespace_))
    if self.ContactInfo:
      self.ContactInfo.export(outfile, level, namespace_, name_='ContactInfo')
    if self.Role:
      self.Role.export(outfile, level, namespace_, name_='Role')
  def hasContent_(self):
    if (
        self.IndividualName is not None or
        self.PositionName is not None or
        self.ContactInfo is not None or
        self.Role is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ResponsiblePartySubsetType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.IndividualName is not None:
      showIndent(outfile, level)
      outfile.write('IndividualName=%s,\n' % quote_python(self.IndividualName).encode(ExternalEncoding))
    if self.PositionName is not None:
      showIndent(outfile, level)
      outfile.write('PositionName=%s,\n' % quote_python(self.PositionName).encode(ExternalEncoding))
    if self.ContactInfo is not None:
      showIndent(outfile, level)
      outfile.write('ContactInfo=model_.ContactInfo(\n')
      self.ContactInfo.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Role is not None:
      showIndent(outfile, level)
      outfile.write('Role=model_.Role(\n')
      self.Role.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'IndividualName':
      IndividualName_ = child_.text
      IndividualName_ = self.gds_validate_string(IndividualName_, node, 'IndividualName')
      self.IndividualName = IndividualName_
    elif nodeName_ == 'PositionName':
      PositionName_ = child_.text
      PositionName_ = self.gds_validate_string(PositionName_, node, 'PositionName')
      self.PositionName = PositionName_
    elif nodeName_ == 'ContactInfo':
      obj_ = ContactType.factory()
      obj_.build(child_)
      self.set_ContactInfo(obj_)
    elif nodeName_ == 'Role':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Role(obj_)
# end class ResponsiblePartySubsetType


class ContactType(GeneratedsSuper):
  """Information required to enable contact with the responsible person
  and/or organization. For OWS use in the service metadata
  document, the optional hoursOfService and contactInstructions
  elements were retained, as possibly being useful in the
  ServiceProvider section."""
  subclass = None
  superclass = None
  def __init__(self, Phone=None, Address=None, OnlineResource=None, HoursOfService=None, ContactInstructions=None):
    self.Phone = Phone
    self.Address = Address
    self.OnlineResource = OnlineResource
    self.HoursOfService = HoursOfService
    self.ContactInstructions = ContactInstructions
  def factory(*args_, **kwargs_):
    if ContactType.subclass:
      return ContactType.subclass(*args_, **kwargs_)
    else:
      return ContactType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Phone(self): return self.Phone
  def set_Phone(self, Phone): self.Phone = Phone
  def get_Address(self): return self.Address
  def set_Address(self, Address): self.Address = Address
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_HoursOfService(self): return self.HoursOfService
  def set_HoursOfService(self, HoursOfService): self.HoursOfService = HoursOfService
  def get_ContactInstructions(self): return self.ContactInstructions
  def set_ContactInstructions(self, ContactInstructions): self.ContactInstructions = ContactInstructions
  def export(self, outfile, level, namespace_='', name_='ContactType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactType', fromsubclass_=False):
    if self.Phone:
      self.Phone.export(outfile, level, namespace_, name_='Phone')
    if self.Address:
      self.Address.export(outfile, level, namespace_, name_='Address')
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource')
    if self.HoursOfService is not None:
      showIndent(outfile, level)
      outfile.write('<%sHoursOfService>%s</%sHoursOfService>\n' % (namespace_, self.gds_format_string(quote_xml(self.HoursOfService).encode(ExternalEncoding), input_name='HoursOfService'), namespace_))
    if self.ContactInstructions is not None:
      showIndent(outfile, level)
      outfile.write('<%sContactInstructions>%s</%sContactInstructions>\n' % (namespace_, self.gds_format_string(quote_xml(self.ContactInstructions).encode(ExternalEncoding), input_name='ContactInstructions'), namespace_))
  def hasContent_(self):
    if (
        self.Phone is not None or
        self.Address is not None or
        self.OnlineResource is not None or
        self.HoursOfService is not None or
        self.ContactInstructions is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Phone is not None:
      showIndent(outfile, level)
      outfile.write('Phone=model_.TelephoneType(\n')
      self.Phone.exportLiteral(outfile, level, name_='Phone')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Address is not None:
      showIndent(outfile, level)
      outfile.write('Address=model_.AddressType(\n')
      self.Address.exportLiteral(outfile, level, name_='Address')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResourceType(\n')
      self.OnlineResource.exportLiteral(outfile, level, name_='OnlineResource')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.HoursOfService is not None:
      showIndent(outfile, level)
      outfile.write('HoursOfService=%s,\n' % quote_python(self.HoursOfService).encode(ExternalEncoding))
    if self.ContactInstructions is not None:
      showIndent(outfile, level)
      outfile.write('ContactInstructions=%s,\n' % quote_python(self.ContactInstructions).encode(ExternalEncoding))
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Phone':
      obj_ = TelephoneType.factory()
      obj_.build(child_)
      self.set_Phone(obj_)
    elif nodeName_ == 'Address':
      obj_ = AddressType.factory()
      obj_.build(child_)
      self.set_Address(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResourceType.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
    elif nodeName_ == 'HoursOfService':
      HoursOfService_ = child_.text
      HoursOfService_ = self.gds_validate_string(HoursOfService_, node, 'HoursOfService')
      self.HoursOfService = HoursOfService_
    elif nodeName_ == 'ContactInstructions':
      ContactInstructions_ = child_.text
      ContactInstructions_ = self.gds_validate_string(ContactInstructions_, node, 'ContactInstructions')
      self.ContactInstructions = ContactInstructions_
# end class ContactType


class OnlineResourceType(GeneratedsSuper):
  """Reference to on-line resource from which data can be obtained. For
  OWS use in the service metadata document, the CI_OnlineResource
  class was XML encoded as the attributeGroup "xlink:simpleLink",
  as used in GML."""
  subclass = None
  superclass = None
  def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None, valueOf_=None):
    self.title = _cast(None, title)
    self.arcrole = _cast(None, arcrole)
    self.actuate = _cast(None, actuate)
    self.href = _cast(None, href)
    self.role = _cast(None, role)
    self.show = _cast(None, show)
    self.type_ = _cast(None, type_)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if OnlineResourceType.subclass:
      return OnlineResourceType.subclass(*args_, **kwargs_)
    else:
      return OnlineResourceType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_title(self): return self.title
  def set_title(self, title): self.title = title
  def get_arcrole(self): return self.arcrole
  def set_arcrole(self, arcrole): self.arcrole = arcrole
  def get_actuate(self): return self.actuate
  def set_actuate(self, actuate): self.actuate = actuate
  def get_href(self): return self.href
  def set_href(self, href): self.href = href
  def get_role(self): return self.role
  def set_role(self, role): self.role = role
  def get_show(self): return self.show
  def set_show(self, show): self.show = show
  def get_type(self): return self.type_
  def set_type(self, type_): self.type_ = type_
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='OnlineResourceType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='OnlineResourceType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnlineResourceType'):
    if self.title is not None and 'title' not in already_processed:
      already_processed.append('title')
      outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
    if self.arcrole is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
    if self.actuate is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
    if self.href is not None and 'href' not in already_processed:
      already_processed.append('href')
      outfile.write(' xlink:href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='xlink:href'), ))
    if self.role is not None and 'role' not in already_processed:
      already_processed.append('role')
      outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
    if self.show is not None and 'show' not in already_processed:
      already_processed.append('show')
      outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='OnlineResourceType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='OnlineResourceType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.title is not None and 'title' not in already_processed:
      already_processed.append('title')
      showIndent(outfile, level)
      outfile.write('title = "%s",\n' % (self.title,))
    if self.arcrole is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      showIndent(outfile, level)
      outfile.write('arcrole = "%s",\n' % (self.arcrole,))
    if self.actuate is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      showIndent(outfile, level)
      outfile.write('actuate = "%s",\n' % (self.actuate,))
    if self.href is not None and 'href' not in already_processed:
      already_processed.append('href')
      showIndent(outfile, level)
      outfile.write('href = "%s",\n' % (self.href,))
    if self.role is not None and 'role' not in already_processed:
      already_processed.append('role')
      showIndent(outfile, level)
      outfile.write('role = "%s",\n' % (self.role,))
    if self.show is not None and 'show' not in already_processed:
      already_processed.append('show')
      showIndent(outfile, level)
      outfile.write('show = "%s",\n' % (self.show,))
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      showIndent(outfile, level)
      outfile.write('type_ = "%s",\n' % (self.type_,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('title', node)
    if value is not None and 'title' not in already_processed:
      already_processed.append('title')
      self.title = value
    value = find_attr_value_('arcrole', node)
    if value is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      self.arcrole = value
    value = find_attr_value_('actuate', node)
    if value is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      self.actuate = value
    value = find_attr_value_('href', node)
    if value is not None and 'href' not in already_processed:
      already_processed.append('href')
      self.href = value
    value = find_attr_value_('role', node)
    if value is not None and 'role' not in already_processed:
      already_processed.append('role')
      self.role = value
    value = find_attr_value_('show', node)
    if value is not None and 'show' not in already_processed:
      already_processed.append('show')
      self.show = value
    value = find_attr_value_('type', node)
    if value is not None and 'type' not in already_processed:
      already_processed.append('type')
      self.type_ = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class OnlineResourceType


class TelephoneType(GeneratedsSuper):
  """Telephone numbers for contacting the responsible individual or
  organization."""
  subclass = None
  superclass = None
  def __init__(self, Voice=None, Facsimile=None):
    if Voice is None:
      self.Voice = []
    else:
      self.Voice = Voice
    if Facsimile is None:
      self.Facsimile = []
    else:
      self.Facsimile = Facsimile
  def factory(*args_, **kwargs_):
    if TelephoneType.subclass:
      return TelephoneType.subclass(*args_, **kwargs_)
    else:
      return TelephoneType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Voice(self): return self.Voice
  def set_Voice(self, Voice): self.Voice = Voice
  def add_Voice(self, value): self.Voice.append(value)
  def insert_Voice(self, index, value): self.Voice[index] = value
  def get_Facsimile(self): return self.Facsimile
  def set_Facsimile(self, Facsimile): self.Facsimile = Facsimile
  def add_Facsimile(self, value): self.Facsimile.append(value)
  def insert_Facsimile(self, index, value): self.Facsimile[index] = value
  def export(self, outfile, level, namespace_='', name_='TelephoneType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='TelephoneType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TelephoneType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='TelephoneType', fromsubclass_=False):
    for Voice_ in self.Voice:
      showIndent(outfile, level)
      outfile.write('<%sVoice>%s</%sVoice>\n' % (namespace_, self.gds_format_string(quote_xml(Voice_).encode(ExternalEncoding), input_name='Voice'), namespace_))
    for Facsimile_ in self.Facsimile:
      showIndent(outfile, level)
      outfile.write('<%sFacsimile>%s</%sFacsimile>\n' % (namespace_, self.gds_format_string(quote_xml(Facsimile_).encode(ExternalEncoding), input_name='Facsimile'), namespace_))
  def hasContent_(self):
    if (
        self.Voice or
        self.Facsimile
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='TelephoneType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Voice=[\n')
    level += 1
    for Voice_ in self.Voice:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Voice_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Facsimile=[\n')
    level += 1
    for Facsimile_ in self.Facsimile:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Facsimile_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Voice':
      Voice_ = child_.text
      Voice_ = self.gds_validate_string(Voice_, node, 'Voice')
      self.Voice.append(Voice_)
    elif nodeName_ == 'Facsimile':
      Facsimile_ = child_.text
      Facsimile_ = self.gds_validate_string(Facsimile_, node, 'Facsimile')
      self.Facsimile.append(Facsimile_)
# end class TelephoneType


class AddressType(GeneratedsSuper):
  """Location of the responsible individual or organization."""
  subclass = None
  superclass = None
  def __init__(self, DeliveryPoint=None, City=None, AdministrativeArea=None, PostalCode=None, Country=None, ElectronicMailAddress=None):
    if DeliveryPoint is None:
      self.DeliveryPoint = []
    else:
      self.DeliveryPoint = DeliveryPoint
    self.City = City
    self.AdministrativeArea = AdministrativeArea
    self.PostalCode = PostalCode
    self.Country = Country
    if ElectronicMailAddress is None:
      self.ElectronicMailAddress = []
    else:
      self.ElectronicMailAddress = ElectronicMailAddress
  def factory(*args_, **kwargs_):
    if AddressType.subclass:
      return AddressType.subclass(*args_, **kwargs_)
    else:
      return AddressType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_DeliveryPoint(self): return self.DeliveryPoint
  def set_DeliveryPoint(self, DeliveryPoint): self.DeliveryPoint = DeliveryPoint
  def add_DeliveryPoint(self, value): self.DeliveryPoint.append(value)
  def insert_DeliveryPoint(self, index, value): self.DeliveryPoint[index] = value
  def get_City(self): return self.City
  def set_City(self, City): self.City = City
  def get_AdministrativeArea(self): return self.AdministrativeArea
  def set_AdministrativeArea(self, AdministrativeArea): self.AdministrativeArea = AdministrativeArea
  def get_PostalCode(self): return self.PostalCode
  def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
  def get_Country(self): return self.Country
  def set_Country(self, Country): self.Country = Country
  def get_ElectronicMailAddress(self): return self.ElectronicMailAddress
  def set_ElectronicMailAddress(self, ElectronicMailAddress): self.ElectronicMailAddress = ElectronicMailAddress
  def add_ElectronicMailAddress(self, value): self.ElectronicMailAddress.append(value)
  def insert_ElectronicMailAddress(self, index, value): self.ElectronicMailAddress[index] = value
  def export(self, outfile, level, namespace_='', name_='AddressType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AddressType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AddressType', fromsubclass_=False):
    for DeliveryPoint_ in self.DeliveryPoint:
      showIndent(outfile, level)
      outfile.write('<%sDeliveryPoint>%s</%sDeliveryPoint>\n' % (namespace_, self.gds_format_string(quote_xml(DeliveryPoint_).encode(ExternalEncoding), input_name='DeliveryPoint'), namespace_))
    if self.City is not None:
      showIndent(outfile, level)
      outfile.write('<%sCity>%s</%sCity>\n' % (namespace_, self.gds_format_string(quote_xml(self.City).encode(ExternalEncoding), input_name='City'), namespace_))
    if self.AdministrativeArea is not None:
      showIndent(outfile, level)
      outfile.write('<%sAdministrativeArea>%s</%sAdministrativeArea>\n' % (namespace_, self.gds_format_string(quote_xml(self.AdministrativeArea).encode(ExternalEncoding), input_name='AdministrativeArea'), namespace_))
    if self.PostalCode is not None:
      showIndent(outfile, level)
      outfile.write('<%sPostalCode>%s</%sPostalCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.PostalCode).encode(ExternalEncoding), input_name='PostalCode'), namespace_))
    if self.Country is not None:
      showIndent(outfile, level)
      outfile.write('<%sCountry>%s</%sCountry>\n' % (namespace_, self.gds_format_string(quote_xml(self.Country).encode(ExternalEncoding), input_name='Country'), namespace_))
    for ElectronicMailAddress_ in self.ElectronicMailAddress:
      showIndent(outfile, level)
      outfile.write('<%sElectronicMailAddress>%s</%sElectronicMailAddress>\n' % (namespace_, self.gds_format_string(quote_xml(ElectronicMailAddress_).encode(ExternalEncoding), input_name='ElectronicMailAddress'), namespace_))
  def hasContent_(self):
    if (
        self.DeliveryPoint or
        self.City is not None or
        self.AdministrativeArea is not None or
        self.PostalCode is not None or
        self.Country is not None or
        self.ElectronicMailAddress
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AddressType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('DeliveryPoint=[\n')
    level += 1
    for DeliveryPoint_ in self.DeliveryPoint:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(DeliveryPoint_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.City is not None:
      showIndent(outfile, level)
      outfile.write('City=%s,\n' % quote_python(self.City).encode(ExternalEncoding))
    if self.AdministrativeArea is not None:
      showIndent(outfile, level)
      outfile.write('AdministrativeArea=%s,\n' % quote_python(self.AdministrativeArea).encode(ExternalEncoding))
    if self.PostalCode is not None:
      showIndent(outfile, level)
      outfile.write('PostalCode=%s,\n' % quote_python(self.PostalCode).encode(ExternalEncoding))
    if self.Country is not None:
      showIndent(outfile, level)
      outfile.write('Country=%s,\n' % quote_python(self.Country).encode(ExternalEncoding))
    showIndent(outfile, level)
    outfile.write('ElectronicMailAddress=[\n')
    level += 1
    for ElectronicMailAddress_ in self.ElectronicMailAddress:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(ElectronicMailAddress_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'DeliveryPoint':
      DeliveryPoint_ = child_.text
      DeliveryPoint_ = self.gds_validate_string(DeliveryPoint_, node, 'DeliveryPoint')
      self.DeliveryPoint.append(DeliveryPoint_)
    elif nodeName_ == 'City':
      City_ = child_.text
      City_ = self.gds_validate_string(City_, node, 'City')
      self.City = City_
    elif nodeName_ == 'AdministrativeArea':
      AdministrativeArea_ = child_.text
      AdministrativeArea_ = self.gds_validate_string(AdministrativeArea_, node, 'AdministrativeArea')
      self.AdministrativeArea = AdministrativeArea_
    elif nodeName_ == 'PostalCode':
      PostalCode_ = child_.text
      PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
      self.PostalCode = PostalCode_
    elif nodeName_ == 'Country':
      Country_ = child_.text
      Country_ = self.gds_validate_string(Country_, node, 'Country')
      self.Country = Country_
    elif nodeName_ == 'ElectronicMailAddress':
      ElectronicMailAddress_ = child_.text
      ElectronicMailAddress_ = self.gds_validate_string(ElectronicMailAddress_, node, 'ElectronicMailAddress')
      self.ElectronicMailAddress.append(ElectronicMailAddress_)
# end class AddressType


class CapabilitiesBaseType(GeneratedsSuper):
  """XML encoded GetCapabilities operation response. This document
  provides clients with service metadata about a specific service
  instance, usually including metadata about the tightly-coupled
  data served. If the server does not implement the updateSequence
  parameter, the server shall always return the complete
  Capabilities document, without the updateSequence parameter.
  When the server implements the updateSequence parameter and the
  GetCapabilities operation request included the updateSequence
  parameter with the current value, the server shall return this
  element with only the "version" and "updateSequence" attributes.
  Otherwise, all optional elements shall be included or not
  depending on the actual value of the Contents parameter in the
  GetCapabilities operation request. This base type shall be
  extended by each specific OWS to include the additional contents
  needed. Service metadata document version, having values that
  are "increased" whenever any change is made in service metadata
  document. Values are selected by each server, and are always
  opaque to clients. When not supported by server, server shall
  not return this attribute."""
  subclass = None
  superclass = None
  def __init__(self, updateSequence=None, version=None, ServiceIdentification=None, ServiceProvider=None, OperationsMetadata=None):
    self.updateSequence = _cast(None, updateSequence)
    self.version = _cast(None, version)
    self.ServiceIdentification = ServiceIdentification
    self.ServiceProvider = ServiceProvider
    self.OperationsMetadata = OperationsMetadata
  def factory(*args_, **kwargs_):
    if CapabilitiesBaseType.subclass:
      return CapabilitiesBaseType.subclass(*args_, **kwargs_)
    else:
      return CapabilitiesBaseType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ServiceIdentification(self): return self.ServiceIdentification
  def set_ServiceIdentification(self, ServiceIdentification): self.ServiceIdentification = ServiceIdentification
  def get_ServiceProvider(self): return self.ServiceProvider
  def set_ServiceProvider(self, ServiceProvider): self.ServiceProvider = ServiceProvider
  def get_OperationsMetadata(self): return self.OperationsMetadata
  def set_OperationsMetadata(self, OperationsMetadata): self.OperationsMetadata = OperationsMetadata
  def get_updateSequence(self): return self.updateSequence
  def set_updateSequence(self, updateSequence): self.updateSequence = updateSequence
  def get_version(self): return self.version
  def set_version(self, version): self.version = version
  def export(self, outfile, level, namespace_='', name_='CapabilitiesBaseType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='CapabilitiesBaseType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapabilitiesBaseType'):
    if self.updateSequence is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      outfile.write(' updateSequence=%s' % (quote_attrib(self.updateSequence), ))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      outfile.write(' version=%s' % (quote_attrib(self.version), ))
  def exportChildren(self, outfile, level, namespace_='', name_='CapabilitiesBaseType', fromsubclass_=False):
    if self.ServiceIdentification:
      self.ServiceIdentification.export(outfile, level, namespace_, name_='ServiceIdentification')
    if self.ServiceProvider:
      self.ServiceProvider.export(outfile, level, namespace_, name_='ServiceProvider')
    if self.OperationsMetadata:
      self.OperationsMetadata.export(outfile, level, namespace_, name_='OperationsMetadata')
  def hasContent_(self):
    if (
        self.ServiceIdentification is not None or
        self.ServiceProvider is not None or
        self.OperationsMetadata is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='CapabilitiesBaseType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.updateSequence is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      showIndent(outfile, level)
      outfile.write('updateSequence = %s,\n' % (self.updateSequence,))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      showIndent(outfile, level)
      outfile.write('version = %s,\n' % (self.version,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.ServiceIdentification is not None:
      showIndent(outfile, level)
      outfile.write('ServiceIdentification=model_.ServiceIdentification(\n')
      self.ServiceIdentification.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ServiceProvider is not None:
      showIndent(outfile, level)
      outfile.write('ServiceProvider=model_.ServiceProvider(\n')
      self.ServiceProvider.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OperationsMetadata is not None:
      showIndent(outfile, level)
      outfile.write('OperationsMetadata=model_.OperationsMetadata(\n')
      self.OperationsMetadata.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('updateSequence', node)
    if value is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      self.updateSequence = value
    value = find_attr_value_('version', node)
    if value is not None and 'version' not in already_processed:
      already_processed.append('version')
      self.version = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ServiceIdentification':
      obj_ = ServiceIdentification.factory()
      obj_.build(child_)
      self.set_ServiceIdentification(obj_)
    elif nodeName_ == 'ServiceProvider':
      obj_ = ServiceProvider.factory()
      obj_.build(child_)
      self.set_ServiceProvider(obj_)
    elif nodeName_ == 'OperationsMetadata':
      obj_ = OperationsMetadata.factory()
      obj_.build(child_)
      self.set_OperationsMetadata(obj_)
# end class CapabilitiesBaseType


class GetCapabilitiesType(GeneratedsSuper):
  """XML encoded GetCapabilities operation request. This operation allows
  clients to retrieve service metadata about a specific service
  instance. In this XML encoding, no "request" parameter is
  included, since the element name specifies the specific
  operation. This base type shall be extended by each specific OWS
  to include the additional required "service" attribute, with the
  correct value for that OWS. When omitted or not supported by
  server, server shall return latest complete service metadata
  document."""
  subclass = None
  superclass = None
  def __init__(self, updateSequence=None, AcceptVersions=None, Sections=None, AcceptFormats=None):
    self.updateSequence = _cast(None, updateSequence)
    self.AcceptVersions = AcceptVersions
    self.Sections = Sections
    self.AcceptFormats = AcceptFormats
  def factory(*args_, **kwargs_):
    if GetCapabilitiesType.subclass:
      return GetCapabilitiesType.subclass(*args_, **kwargs_)
    else:
      return GetCapabilitiesType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_AcceptVersions(self): return self.AcceptVersions
  def set_AcceptVersions(self, AcceptVersions): self.AcceptVersions = AcceptVersions
  def get_Sections(self): return self.Sections
  def set_Sections(self, Sections): self.Sections = Sections
  def get_AcceptFormats(self): return self.AcceptFormats
  def set_AcceptFormats(self, AcceptFormats): self.AcceptFormats = AcceptFormats
  def get_updateSequence(self): return self.updateSequence
  def set_updateSequence(self, updateSequence): self.updateSequence = updateSequence
  def export(self, outfile, level, namespace_='', name_='GetCapabilitiesType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetCapabilitiesType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetCapabilitiesType'):
    if self.updateSequence is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      outfile.write(' updateSequence=%s' % (quote_attrib(self.updateSequence), ))
  def exportChildren(self, outfile, level, namespace_='', name_='GetCapabilitiesType', fromsubclass_=False):
    if self.AcceptVersions:
      self.AcceptVersions.export(outfile, level, namespace_, name_='AcceptVersions')
    if self.Sections:
      self.Sections.export(outfile, level, namespace_, name_='Sections')
    if self.AcceptFormats:
      self.AcceptFormats.export(outfile, level, namespace_, name_='AcceptFormats')
  def hasContent_(self):
    if (
        self.AcceptVersions is not None or
        self.Sections is not None or
        self.AcceptFormats is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetCapabilitiesType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.updateSequence is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      showIndent(outfile, level)
      outfile.write('updateSequence = %s,\n' % (self.updateSequence,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.AcceptVersions is not None:
      showIndent(outfile, level)
      outfile.write('AcceptVersions=model_.AcceptVersionsType(\n')
      self.AcceptVersions.exportLiteral(outfile, level, name_='AcceptVersions')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Sections is not None:
      showIndent(outfile, level)
      outfile.write('Sections=model_.SectionsType(\n')
      self.Sections.exportLiteral(outfile, level, name_='Sections')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.AcceptFormats is not None:
      showIndent(outfile, level)
      outfile.write('AcceptFormats=model_.AcceptFormatsType(\n')
      self.AcceptFormats.exportLiteral(outfile, level, name_='AcceptFormats')
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('updateSequence', node)
    if value is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      self.updateSequence = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'AcceptVersions':
      obj_ = AcceptVersionsType.factory()
      obj_.build(child_)
      self.set_AcceptVersions(obj_)
    elif nodeName_ == 'Sections':
      obj_ = SectionsType.factory()
      obj_.build(child_)
      self.set_Sections(obj_)
    elif nodeName_ == 'AcceptFormats':
      obj_ = AcceptFormatsType.factory()
      obj_.build(child_)
      self.set_AcceptFormats(obj_)
# end class GetCapabilitiesType


class AcceptVersionsType(GeneratedsSuper):
  """Prioritized sequence of one or more specification versions accepted
  by client, with preferred versions listed first. See Version
  negotiation subclause for more information."""
  subclass = None
  superclass = None
  def __init__(self, Version=None):
    if Version is None:
      self.Version = []
    else:
      self.Version = Version
  def factory(*args_, **kwargs_):
    if AcceptVersionsType.subclass:
      return AcceptVersionsType.subclass(*args_, **kwargs_)
    else:
      return AcceptVersionsType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Version(self): return self.Version
  def set_Version(self, Version): self.Version = Version
  def add_Version(self, value): self.Version.append(value)
  def insert_Version(self, index, value): self.Version[index] = value
  def validate_VersionType(self, value):
    # Validate type VersionType, a restriction on string.
    pass
  def export(self, outfile, level, namespace_='', name_='AcceptVersionsType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AcceptVersionsType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcceptVersionsType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AcceptVersionsType', fromsubclass_=False):
    for Version_ in self.Version:
      showIndent(outfile, level)
      outfile.write('<%sVersion>%s</%sVersion>\n' % (namespace_, self.gds_format_string(quote_xml(Version_).encode(ExternalEncoding), input_name='Version'), namespace_))
  def hasContent_(self):
    if (
        self.Version
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AcceptVersionsType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Version=[\n')
    level += 1
    for Version_ in self.Version:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Version_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Version':
      Version_ = child_.text
      Version_ = self.gds_validate_string(Version_, node, 'Version')
      self.Version.append(Version_)
      self.validate_VersionType(self.Version)    # validate type VersionType
# end class AcceptVersionsType


class SectionsType(GeneratedsSuper):
  """Unordered list of zero or more names of requested sections in
  complete service metadata document. Each Section value shall
  contain an allowed section name as specified by each OWS
  specification. See Sections parameter subclause for more
  information."""
  subclass = None
  superclass = None
  def __init__(self, Section=None):
    if Section is None:
      self.Section = []
    else:
      self.Section = Section
  def factory(*args_, **kwargs_):
    if SectionsType.subclass:
      return SectionsType.subclass(*args_, **kwargs_)
    else:
      return SectionsType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Section(self): return self.Section
  def set_Section(self, Section): self.Section = Section
  def add_Section(self, value): self.Section.append(value)
  def insert_Section(self, index, value): self.Section[index] = value
  def export(self, outfile, level, namespace_='', name_='SectionsType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='SectionsType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SectionsType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='SectionsType', fromsubclass_=False):
    for Section_ in self.Section:
      showIndent(outfile, level)
      outfile.write('<%sSection>%s</%sSection>\n' % (namespace_, self.gds_format_string(quote_xml(Section_).encode(ExternalEncoding), input_name='Section'), namespace_))
  def hasContent_(self):
    if (
        self.Section
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='SectionsType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Section=[\n')
    level += 1
    for Section_ in self.Section:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Section_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Section':
      Section_ = child_.text
      Section_ = self.gds_validate_string(Section_, node, 'Section')
      self.Section.append(Section_)
# end class SectionsType


class AcceptFormatsType(GeneratedsSuper):
  """Prioritized sequence of zero or more GetCapabilities operation
  response formats desired by client, with preferred formats
  listed first. Each response format shall be identified by its
  MIME type. See AcceptFormats parameter use subclause for more
  information."""
  subclass = None
  superclass = None
  def __init__(self, OutputFormat=None):
    if OutputFormat is None:
      self.OutputFormat = []
    else:
      self.OutputFormat = OutputFormat
  def factory(*args_, **kwargs_):
    if AcceptFormatsType.subclass:
      return AcceptFormatsType.subclass(*args_, **kwargs_)
    else:
      return AcceptFormatsType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_OutputFormat(self): return self.OutputFormat
  def set_OutputFormat(self, OutputFormat): self.OutputFormat = OutputFormat
  def add_OutputFormat(self, value): self.OutputFormat.append(value)
  def insert_OutputFormat(self, index, value): self.OutputFormat[index] = value
  def validate_MimeType(self, value):
    # Validate type MimeType, a restriction on string.
    pass
  def export(self, outfile, level, namespace_='', name_='AcceptFormatsType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AcceptFormatsType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcceptFormatsType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AcceptFormatsType', fromsubclass_=False):
    for OutputFormat_ in self.OutputFormat:
      showIndent(outfile, level)
      outfile.write('<%sOutputFormat>%s</%sOutputFormat>\n' % (namespace_, self.gds_format_string(quote_xml(OutputFormat_).encode(ExternalEncoding), input_name='OutputFormat'), namespace_))
  def hasContent_(self):
    if (
        self.OutputFormat
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AcceptFormatsType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('OutputFormat=[\n')
    level += 1
    for OutputFormat_ in self.OutputFormat:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(OutputFormat_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'OutputFormat':
      OutputFormat_ = child_.text
      OutputFormat_ = self.gds_validate_string(OutputFormat_, node, 'OutputFormat')
      self.OutputFormat.append(OutputFormat_)
      self.validate_MimeType(self.OutputFormat)    # validate type MimeType
# end class AcceptFormatsType


class ServiceIdentification(DescriptionType):
  """General metadata for this specific server. This XML Schema of this
  section shall be the same for all OWS."""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, ServiceType=None, ServiceTypeVersion=None, Profile=None, Fees=None, AccessConstraints=None):
    super(ServiceIdentification, self).__init__(Title, Abstract, Keywords, )
    self.ServiceType = ServiceType
    if ServiceTypeVersion is None:
      self.ServiceTypeVersion = []
    else:
      self.ServiceTypeVersion = ServiceTypeVersion
    if Profile is None:
      self.Profile = []
    else:
      self.Profile = Profile
    self.Fees = Fees
    if AccessConstraints is None:
      self.AccessConstraints = []
    else:
      self.AccessConstraints = AccessConstraints
  def factory(*args_, **kwargs_):
    if ServiceIdentification.subclass:
      return ServiceIdentification.subclass(*args_, **kwargs_)
    else:
      return ServiceIdentification(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ServiceType(self): return self.ServiceType
  def set_ServiceType(self, ServiceType): self.ServiceType = ServiceType
  def get_ServiceTypeVersion(self): return self.ServiceTypeVersion
  def set_ServiceTypeVersion(self, ServiceTypeVersion): self.ServiceTypeVersion = ServiceTypeVersion
  def add_ServiceTypeVersion(self, value): self.ServiceTypeVersion.append(value)
  def insert_ServiceTypeVersion(self, index, value): self.ServiceTypeVersion[index] = value
  def validate_VersionType(self, value):
    # Validate type VersionType, a restriction on string.
    pass
  def get_Profile(self): return self.Profile
  def set_Profile(self, Profile): self.Profile = Profile
  def add_Profile(self, value): self.Profile.append(value)
  def insert_Profile(self, index, value): self.Profile[index] = value
  def get_Fees(self): return self.Fees
  def set_Fees(self, Fees): self.Fees = Fees
  def get_AccessConstraints(self): return self.AccessConstraints
  def set_AccessConstraints(self, AccessConstraints): self.AccessConstraints = AccessConstraints
  def add_AccessConstraints(self, value): self.AccessConstraints.append(value)
  def insert_AccessConstraints(self, index, value): self.AccessConstraints[index] = value
  def export(self, outfile, level, namespace_='', name_='ServiceIdentification', namespacedef_=''):
    if namespace_ == '':
      namespace_ = 'ows:'

    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ServiceIdentification')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="ServiceIdentification"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceIdentification'):
    super(ServiceIdentification, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceIdentification')
  def exportChildren(self, outfile, level, namespace_='', name_='ServiceIdentification', fromsubclass_=False):
    super(ServiceIdentification, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.ServiceType:
      self.ServiceType.export(outfile, level, namespace_, name_='ServiceType', )
    for ServiceTypeVersion_ in self.ServiceTypeVersion:
      showIndent(outfile, level)
      outfile.write('<%sServiceTypeVersion>%s</%sServiceTypeVersion>\n' % (namespace_, self.gds_format_string(quote_xml(ServiceTypeVersion_).encode(ExternalEncoding), input_name='ServiceTypeVersion'), namespace_))
    for Profile_ in self.Profile:
      showIndent(outfile, level)
      outfile.write('<%sProfile>%s</%sProfile>\n' % (namespace_, self.gds_format_string(quote_xml(Profile_).encode(ExternalEncoding), input_name='Profile'), namespace_))
    if self.Fees is not None:
      showIndent(outfile, level)
      outfile.write('<%sFees>%s</%sFees>\n' % (namespace_, self.gds_format_string(quote_xml(self.Fees).encode(ExternalEncoding), input_name='Fees'), namespace_))
    for AccessConstraints_ in self.AccessConstraints:
      showIndent(outfile, level)
      outfile.write('<%sAccessConstraints>%s</%sAccessConstraints>\n' % (namespace_, self.gds_format_string(quote_xml(AccessConstraints_).encode(ExternalEncoding), input_name='AccessConstraints'), namespace_))
  def hasContent_(self):
    if (
        self.ServiceType is not None or
        self.ServiceTypeVersion or
        self.Profile or
        self.Fees is not None or
        self.AccessConstraints or
        super(ServiceIdentification, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ServiceIdentification'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(ServiceIdentification, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(ServiceIdentification, self).exportLiteralChildren(outfile, level, name_)
    if self.ServiceType is not None:
      showIndent(outfile, level)
      outfile.write('ServiceType=model_.CodeType(\n')
      self.ServiceType.exportLiteral(outfile, level, name_='ServiceType')
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('ServiceTypeVersion=[\n')
    level += 1
    for ServiceTypeVersion_ in self.ServiceTypeVersion:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(ServiceTypeVersion_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Profile=[\n')
    level += 1
    for Profile_ in self.Profile:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Profile_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.Fees is not None:
      showIndent(outfile, level)
      outfile.write('Fees=%s,\n' % quote_python(self.Fees).encode(ExternalEncoding))
    showIndent(outfile, level)
    outfile.write('AccessConstraints=[\n')
    level += 1
    for AccessConstraints_ in self.AccessConstraints:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(AccessConstraints_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(ServiceIdentification, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ServiceType':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_ServiceType(obj_)
    elif nodeName_ == 'ServiceTypeVersion':
      ServiceTypeVersion_ = child_.text
      ServiceTypeVersion_ = self.gds_validate_string(ServiceTypeVersion_, node, 'ServiceTypeVersion')
      self.ServiceTypeVersion.append(ServiceTypeVersion_)
      self.validate_VersionType(self.ServiceTypeVersion)    # validate type VersionType
    elif nodeName_ == 'Profile':
      Profile_ = child_.text
      Profile_ = self.gds_validate_string(Profile_, node, 'Profile')
      self.Profile.append(Profile_)
    elif nodeName_ == 'Fees':
      Fees_ = child_.text
      Fees_ = self.gds_validate_string(Fees_, node, 'Fees')
      self.Fees = Fees_
    elif nodeName_ == 'AccessConstraints':
      AccessConstraints_ = child_.text
      AccessConstraints_ = self.gds_validate_string(AccessConstraints_, node, 'AccessConstraints')
      self.AccessConstraints.append(AccessConstraints_)
    super(ServiceIdentification, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceIdentification


class ServiceProvider(GeneratedsSuper):
  """Metadata about the organization that provides this specific service
  instance or server."""
  subclass = None
  superclass = None
  def __init__(self, ProviderName=None, ProviderSite=None, ServiceContact=None):
    self.ProviderName = ProviderName
    self.ProviderSite = ProviderSite
    self.ServiceContact = ServiceContact
  def factory(*args_, **kwargs_):
    if ServiceProvider.subclass:
      return ServiceProvider.subclass(*args_, **kwargs_)
    else:
      return ServiceProvider(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ProviderName(self): return self.ProviderName
  def set_ProviderName(self, ProviderName): self.ProviderName = ProviderName
  def get_ProviderSite(self): return self.ProviderSite
  def set_ProviderSite(self, ProviderSite): self.ProviderSite = ProviderSite
  def get_ServiceContact(self): return self.ServiceContact
  def set_ServiceContact(self, ServiceContact): self.ServiceContact = ServiceContact
  def export(self, outfile, level, namespace_='', name_='ServiceProvider', namespacedef_=''):
    if namespace_ == '':
      namespace_ = 'ows:'

    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ServiceProvider')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceProvider'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ServiceProvider', fromsubclass_=False):
    if self.ProviderName is not None:
      showIndent(outfile, level)
      outfile.write('<%sProviderName>%s</%sProviderName>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProviderName).encode(ExternalEncoding), input_name='ProviderName'), namespace_))
    if self.ProviderSite:
      self.ProviderSite.export(outfile, level, namespace_, name_='ProviderSite')
    if self.ServiceContact:
      self.ServiceContact.export(outfile, level, namespace_, name_='ServiceContact', )
  def hasContent_(self):
    if (
        self.ProviderName is not None or
        self.ProviderSite is not None or
        self.ServiceContact is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ServiceProvider'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.ProviderName is not None:
      showIndent(outfile, level)
      outfile.write('ProviderName=%s,\n' % quote_python(self.ProviderName).encode(ExternalEncoding))
    if self.ProviderSite is not None:
      showIndent(outfile, level)
      outfile.write('ProviderSite=model_.OnlineResourceType(\n')
      self.ProviderSite.exportLiteral(outfile, level, name_='ProviderSite')
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ServiceContact is not None:
      showIndent(outfile, level)
      outfile.write('ServiceContact=model_.ResponsiblePartySubsetType(\n')
      self.ServiceContact.exportLiteral(outfile, level, name_='ServiceContact')
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ProviderName':
      ProviderName_ = child_.text
      ProviderName_ = self.gds_validate_string(ProviderName_, node, 'ProviderName')
      self.ProviderName = ProviderName_
    elif nodeName_ == 'ProviderSite':
      obj_ = OnlineResourceType.factory()
      obj_.build(child_)
      self.set_ProviderSite(obj_)
    elif nodeName_ == 'ServiceContact':
      obj_ = ResponsiblePartySubsetType.factory()
      obj_.build(child_)
      self.set_ServiceContact(obj_)
# end class ServiceProvider


class OperationsMetadata(GeneratedsSuper):
  """Metadata about the operations and related abilities specified by
  this service and implemented by this server, including the URLs
  for operation requests. The basic contents of this section shall
  be the same for all OWS types, but individual services can add
  elements and/or change the optionality of optional elements."""
  subclass = None
  superclass = None
  def __init__(self, Operation=None, Parameter=None, Constraint=None, ExtendedCapabilities=None):
    if Operation is None:
      self.Operation = []
    else:
      self.Operation = Operation
    if Parameter is None:
      self.Parameter = []
    else:
      self.Parameter = Parameter
    if Constraint is None:
      self.Constraint = []
    else:
      self.Constraint = Constraint
    self.ExtendedCapabilities = ExtendedCapabilities
  def factory(*args_, **kwargs_):
    if OperationsMetadata.subclass:
      return OperationsMetadata.subclass(*args_, **kwargs_)
    else:
      return OperationsMetadata(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Operation(self): return self.Operation
  def set_Operation(self, Operation): self.Operation = Operation
  def add_Operation(self, value): self.Operation.append(value)
  def insert_Operation(self, index, value): self.Operation[index] = value
  def get_Parameter(self): return self.Parameter
  def set_Parameter(self, Parameter): self.Parameter = Parameter
  def add_Parameter(self, value): self.Parameter.append(value)
  def insert_Parameter(self, index, value): self.Parameter[index] = value
  def get_Constraint(self): return self.Constraint
  def set_Constraint(self, Constraint): self.Constraint = Constraint
  def add_Constraint(self, value): self.Constraint.append(value)
  def insert_Constraint(self, index, value): self.Constraint[index] = value
  def get_ExtendedCapabilities(self): return self.ExtendedCapabilities
  def set_ExtendedCapabilities(self, ExtendedCapabilities): self.ExtendedCapabilities = ExtendedCapabilities
  def export(self, outfile, level, namespace_='', name_='OperationsMetadata', namespacedef_=''):
    if namespace_ == '':
      namespace_ = 'ows:'

    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='OperationsMetadata')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationsMetadata'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='OperationsMetadata', fromsubclass_=False):
    for Operation_ in self.Operation:
      Operation_.export(outfile, level, namespace_, name_='Operation')
    for Parameter_ in self.Parameter:
      Parameter_.export(outfile, level, namespace_, name_='Parameter')
    for Constraint_ in self.Constraint:
      Constraint_.export(outfile, level, namespace_, name_='Constraint')
    if self.ExtendedCapabilities is not None:
      showIndent(outfile, level)
      outfile.write('<%sExtendedCapabilities>%s</%sExtendedCapabilities>\n' % (namespace_, self.gds_format_string(quote_xml(self.ExtendedCapabilities).encode(ExternalEncoding), input_name='ExtendedCapabilities'), namespace_))
  def hasContent_(self):
    if (
        self.Operation or
        self.Parameter or
        self.Constraint or
        self.ExtendedCapabilities is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='OperationsMetadata'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Operation=[\n')
    level += 1
    for Operation_ in self.Operation:
      showIndent(outfile, level)
      outfile.write('model_.Operation(\n')
      Operation_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Parameter=[\n')
    level += 1
    for Parameter_ in self.Parameter:
      showIndent(outfile, level)
      outfile.write('model_.DomainType(\n')
      Parameter_.exportLiteral(outfile, level, name_='DomainType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Constraint=[\n')
    level += 1
    for Constraint_ in self.Constraint:
      showIndent(outfile, level)
      outfile.write('model_.DomainType(\n')
      Constraint_.exportLiteral(outfile, level, name_='DomainType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.ExtendedCapabilities is not None:
      showIndent(outfile, level)
      outfile.write('ExtendedCapabilities=%s,\n' % quote_python(self.ExtendedCapabilities).encode(ExternalEncoding))
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Operation':
      obj_ = Operation.factory()
      obj_.build(child_)
      self.Operation.append(obj_)
    elif nodeName_ == 'Parameter':
      obj_ = DomainType.factory()
      obj_.build(child_)
      self.Parameter.append(obj_)
    elif nodeName_ == 'Constraint':
      obj_ = DomainType.factory()
      obj_.build(child_)
      self.Constraint.append(obj_)
    elif nodeName_ == 'ExtendedCapabilities':
      ExtendedCapabilities_ = child_.text
      ExtendedCapabilities_ = self.gds_validate_string(ExtendedCapabilities_, node, 'ExtendedCapabilities')
      self.ExtendedCapabilities = ExtendedCapabilities_
# end class OperationsMetadata


class Operation(GeneratedsSuper):
  """Metadata for one operation that this server implements. Name or
  identifier of this operation (request) (for example,
  GetCapabilities). The list of required and optional operations
  implemented shall be specified in the Implementation
  Specification for this service."""
  subclass = None
  superclass = None
  def __init__(self, name=None, DCP=None, Parameter=None, Constraint=None, Metadata=None):
    self.name = _cast(None, name)
    if DCP is None:
      self.DCP = []
    else:
      self.DCP = DCP
    if Parameter is None:
      self.Parameter = []
    else:
      self.Parameter = Parameter
    if Constraint is None:
      self.Constraint = []
    else:
      self.Constraint = Constraint
    if Metadata is None:
      self.Metadata = []
    else:
      self.Metadata = Metadata
  def factory(*args_, **kwargs_):
    if Operation.subclass:
      return Operation.subclass(*args_, **kwargs_)
    else:
      return Operation(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_DCP(self): return self.DCP
  def set_DCP(self, DCP): self.DCP = DCP
  def add_DCP(self, value): self.DCP.append(value)
  def insert_DCP(self, index, value): self.DCP[index] = value
  def get_Parameter(self): return self.Parameter
  def set_Parameter(self, Parameter): self.Parameter = Parameter
  def add_Parameter(self, value): self.Parameter.append(value)
  def insert_Parameter(self, index, value): self.Parameter[index] = value
  def get_Constraint(self): return self.Constraint
  def set_Constraint(self, Constraint): self.Constraint = Constraint
  def add_Constraint(self, value): self.Constraint.append(value)
  def insert_Constraint(self, index, value): self.Constraint[index] = value
  def get_Metadata(self): return self.Metadata
  def set_Metadata(self, Metadata): self.Metadata = Metadata
  def add_Metadata(self, value): self.Metadata.append(value)
  def insert_Metadata(self, index, value): self.Metadata[index] = value
  def get_name(self): return self.name
  def set_name(self, name): self.name = name
  def export(self, outfile, level, namespace_='', name_='Operation', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Operation')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Operation'):
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='Operation', fromsubclass_=False):
    for DCP_ in self.DCP:
      DCP_.export(outfile, level, namespace_, name_='DCP')
    for Parameter_ in self.Parameter:
      Parameter_.export(outfile, level, namespace_, name_='Parameter')
    for Constraint_ in self.Constraint:
      Constraint_.export(outfile, level, namespace_, name_='Constraint')
    for Metadata_ in self.Metadata:
      Metadata_.export(outfile, level, namespace_, name_='Metadata')
  def hasContent_(self):
    if (
        self.DCP or
        self.Parameter or
        self.Constraint or
        self.Metadata
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Operation'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      showIndent(outfile, level)
      outfile.write('name = "%s",\n' % (self.name,))
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('DCP=[\n')
    level += 1
    for DCP_ in self.DCP:
      showIndent(outfile, level)
      outfile.write('model_.DCP(\n')
      DCP_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Parameter=[\n')
    level += 1
    for Parameter_ in self.Parameter:
      showIndent(outfile, level)
      outfile.write('model_.DomainType(\n')
      Parameter_.exportLiteral(outfile, level, name_='DomainType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Constraint=[\n')
    level += 1
    for Constraint_ in self.Constraint:
      showIndent(outfile, level)
      outfile.write('model_.DomainType(\n')
      Constraint_.exportLiteral(outfile, level, name_='DomainType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Metadata=[\n')
    level += 1
    for Metadata_ in self.Metadata:
      showIndent(outfile, level)
      outfile.write('model_.Metadata(\n')
      Metadata_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('name', node)
    if value is not None and 'name' not in already_processed:
      already_processed.append('name')
      self.name = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'DCP':
      obj_ = DCP.factory()
      obj_.build(child_)
      self.DCP.append(obj_)
    elif nodeName_ == 'Parameter':
      obj_ = DomainType.factory()
      obj_.build(child_)
      self.Parameter.append(obj_)
    elif nodeName_ == 'Constraint':
      obj_ = DomainType.factory()
      obj_.build(child_)
      self.Constraint.append(obj_)
    elif nodeName_ == 'Metadata':
      obj_ = MetadataType.factory()
      obj_.build(child_)
      self.Metadata.append(obj_)
# end class Operation


class DCP(GeneratedsSuper):
  """Information for one distributed Computing Platform (DCP) supported
  for this operation. At present, only the HTTP DCP is defined, so
  this element only includes the HTTP element."""
  subclass = None
  superclass = None
  def __init__(self, HTTP=None):
    self.HTTP = HTTP
  def factory(*args_, **kwargs_):
    if DCP.subclass:
      return DCP.subclass(*args_, **kwargs_)
    else:
      return DCP(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_HTTP(self): return self.HTTP
  def set_HTTP(self, HTTP): self.HTTP = HTTP
  def export(self, outfile, level, namespace_='', name_='DCP', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DCP')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCP'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='DCP', fromsubclass_=False):
    if self.HTTP:
      self.HTTP.export(outfile, level, namespace_, name_='HTTP', )
  def hasContent_(self):
    if (
        self.HTTP is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DCP'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.HTTP is not None:
      showIndent(outfile, level)
      outfile.write('HTTP=model_.HTTP(\n')
      self.HTTP.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'HTTP':
      obj_ = HTTP.factory()
      obj_.build(child_)
      self.set_HTTP(obj_)
# end class DCP


class HTTP(GeneratedsSuper):
  """Connect point URLs for the HTTP Distributed Computing Platform
  (DCP). Normally, only one Get and/or one Post is included in
  this element. More than one Get and/or Post is allowed to
  support including alternative URLs for uses such as load
  balancing or backup."""
  subclass = None
  superclass = None
  def __init__(self, Get=None, Post=None):
    if Get is None:
      self.Get = []
    else:
      self.Get = Get
    if Post is None:
      self.Post = []
    else:
      self.Post = Post
  def factory(*args_, **kwargs_):
    if HTTP.subclass:
      return HTTP.subclass(*args_, **kwargs_)
    else:
      return HTTP(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Get(self): return self.Get
  def set_Get(self, Get): self.Get = Get
  def add_Get(self, value): self.Get.append(value)
  def insert_Get(self, index, value): self.Get[index] = value
  def get_Post(self): return self.Post
  def set_Post(self, Post): self.Post = Post
  def add_Post(self, value): self.Post.append(value)
  def insert_Post(self, index, value): self.Post[index] = value
  def export(self, outfile, level, namespace_='', name_='HTTP', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='HTTP')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HTTP'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='HTTP', fromsubclass_=False):
    for Get_ in self.Get:
      Get_.export(outfile, level, namespace_, name_='Get')
    for Post_ in self.Post:
      Post_.export(outfile, level, namespace_, name_='Post')
  def hasContent_(self):
    if (
        self.Get or
        self.Post
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='HTTP'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Get=[\n')
    level += 1
    for Get_ in self.Get:
      showIndent(outfile, level)
      outfile.write('model_.RequestMethodType(\n')
      Get_.exportLiteral(outfile, level, name_='RequestMethodType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Post=[\n')
    level += 1
    for Post_ in self.Post:
      showIndent(outfile, level)
      outfile.write('model_.RequestMethodType(\n')
      Post_.exportLiteral(outfile, level, name_='RequestMethodType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Get':
      obj_ = RequestMethodType.factory()
      obj_.build(child_)
      self.Get.append(obj_)
    elif nodeName_ == 'Post':
      obj_ = RequestMethodType.factory()
      obj_.build(child_)
      self.Post.append(obj_)
# end class HTTP


class RequestMethodType(OnlineResourceType):
  """Connect point URL and any constraints for this HTTP request method
  for this operation request. In the OnlineResourceType, the
  xlink:href attribute in the xlink:simpleLink attribute group
  shall be used to contain this URL. The other attributes in the
  xlink:simpleLink attribute group should not be used."""
  subclass = None
  superclass = OnlineResourceType
  def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None, Constraint=None):
    super(RequestMethodType, self).__init__(title, arcrole, actuate, href, role, show, type_, )
    if Constraint is None:
      self.Constraint = []
    else:
      self.Constraint = Constraint
  def factory(*args_, **kwargs_):
    if RequestMethodType.subclass:
      return RequestMethodType.subclass(*args_, **kwargs_)
    else:
      return RequestMethodType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Constraint(self): return self.Constraint
  def set_Constraint(self, Constraint): self.Constraint = Constraint
  def add_Constraint(self, value): self.Constraint.append(value)
  def insert_Constraint(self, index, value): self.Constraint[index] = value
  def export(self, outfile, level, namespace_='', name_='RequestMethodType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='RequestMethodType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="RequestMethodType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestMethodType'):
    super(RequestMethodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RequestMethodType')
  def exportChildren(self, outfile, level, namespace_='', name_='RequestMethodType', fromsubclass_=False):
    super(RequestMethodType, self).exportChildren(outfile, level, namespace_, name_, True)
    for Constraint_ in self.Constraint:
      Constraint_.export(outfile, level, namespace_, name_='Constraint')
  def hasContent_(self):
    if (
        self.Constraint or
        super(RequestMethodType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='RequestMethodType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(RequestMethodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(RequestMethodType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('Constraint=[\n')
    level += 1
    for Constraint_ in self.Constraint:
      showIndent(outfile, level)
      outfile.write('model_.DomainType(\n')
      Constraint_.exportLiteral(outfile, level, name_='DomainType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(RequestMethodType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Constraint':
      obj_ = DomainType.factory()
      obj_.build(child_)
      self.Constraint.append(obj_)
    super(RequestMethodType, self).buildChildren(child_, node, nodeName_, True)
# end class RequestMethodType


class UnNamedDomainType(GeneratedsSuper):
  """Valid domain (or allowed set of values) of one quantity, with needed
  metadata but without a quantity name or identifier."""
  subclass = None
  superclass = None
  def __init__(self, AllowedValues=None, AnyValue=None, NoValues=None, ValuesReference=None, DefaultValue=None, Meaning=None, DataType=None, UOM=None, ReferenceSystem=None, Metadata=None):
    self.AllowedValues = AllowedValues
    self.AnyValue = AnyValue
    self.NoValues = NoValues
    self.ValuesReference = ValuesReference
    self.DefaultValue = DefaultValue
    self.Meaning = Meaning
    self.DataType = DataType
    self.UOM = UOM
    self.ReferenceSystem = ReferenceSystem
    if Metadata is None:
      self.Metadata = []
    else:
      self.Metadata = Metadata
  def factory(*args_, **kwargs_):
    if UnNamedDomainType.subclass:
      return UnNamedDomainType.subclass(*args_, **kwargs_)
    else:
      return UnNamedDomainType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_AllowedValues(self): return self.AllowedValues
  def set_AllowedValues(self, AllowedValues): self.AllowedValues = AllowedValues
  def get_AnyValue(self): return self.AnyValue
  def set_AnyValue(self, AnyValue): self.AnyValue = AnyValue
  def get_NoValues(self): return self.NoValues
  def set_NoValues(self, NoValues): self.NoValues = NoValues
  def get_ValuesReference(self): return self.ValuesReference
  def set_ValuesReference(self, ValuesReference): self.ValuesReference = ValuesReference
  def get_DefaultValue(self): return self.DefaultValue
  def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
  def get_Meaning(self): return self.Meaning
  def set_Meaning(self, Meaning): self.Meaning = Meaning
  def get_DataType(self): return self.DataType
  def set_DataType(self, DataType): self.DataType = DataType
  def get_UOM(self): return self.UOM
  def set_UOM(self, UOM): self.UOM = UOM
  def get_ReferenceSystem(self): return self.ReferenceSystem
  def set_ReferenceSystem(self, ReferenceSystem): self.ReferenceSystem = ReferenceSystem
  def get_Metadata(self): return self.Metadata
  def set_Metadata(self, Metadata): self.Metadata = Metadata
  def add_Metadata(self, value): self.Metadata.append(value)
  def insert_Metadata(self, index, value): self.Metadata[index] = value
  def export(self, outfile, level, namespace_='', name_='UnNamedDomainType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='UnNamedDomainType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnNamedDomainType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='UnNamedDomainType', fromsubclass_=False):
    if self.AllowedValues:
      self.AllowedValues.export(outfile, level, namespace_, name_='AllowedValues', )
    if self.AnyValue:
      self.AnyValue.export(outfile, level, namespace_, name_='AnyValue', )
    if self.NoValues:
      self.NoValues.export(outfile, level, namespace_, name_='NoValues', )
    if self.ValuesReference:
      self.ValuesReference.export(outfile, level, namespace_, name_='ValuesReference', )
    if self.DefaultValue:
      self.DefaultValue.export(outfile, level, namespace_, name_='DefaultValue')
    if self.Meaning:
      self.Meaning.export(outfile, level, namespace_, name_='Meaning')
    if self.DataType:
      self.DataType.export(outfile, level, namespace_, name_='DataType')
    if self.UOM:
      self.UOM.export(outfile, level, namespace_, name_='UOM', )
    if self.ReferenceSystem:
      self.ReferenceSystem.export(outfile, level, namespace_, name_='ReferenceSystem', )
    for Metadata_ in self.Metadata:
      Metadata_.export(outfile, level, namespace_, name_='Metadata')
  def hasContent_(self):
    if (
        self.AllowedValues is not None or
        self.AnyValue is not None or
        self.NoValues is not None or
        self.ValuesReference is not None or
        self.DefaultValue is not None or
        self.Meaning is not None or
        self.DataType is not None or
        self.UOM is not None or
        self.ReferenceSystem is not None or
        self.Metadata
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='UnNamedDomainType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.AllowedValues is not None:
      showIndent(outfile, level)
      outfile.write('AllowedValues=model_.AllowedValues(\n')
      self.AllowedValues.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.AnyValue is not None:
      showIndent(outfile, level)
      outfile.write('AnyValue=model_.AnyValue(\n')
      self.AnyValue.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.NoValues is not None:
      showIndent(outfile, level)
      outfile.write('NoValues=model_.NoValues(\n')
      self.NoValues.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ValuesReference is not None:
      showIndent(outfile, level)
      outfile.write('ValuesReference=model_.ValuesReference(\n')
      self.ValuesReference.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.DefaultValue is not None:
      showIndent(outfile, level)
      outfile.write('DefaultValue=model_.DefaultValue(\n')
      self.DefaultValue.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Meaning is not None:
      showIndent(outfile, level)
      outfile.write('Meaning=model_.Meaning(\n')
      self.Meaning.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.DataType is not None:
      showIndent(outfile, level)
      outfile.write('DataType=model_.DataType(\n')
      self.DataType.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.UOM is not None:
      showIndent(outfile, level)
      outfile.write('UOM=model_.UOM(\n')
      self.UOM.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ReferenceSystem is not None:
      showIndent(outfile, level)
      outfile.write('ReferenceSystem=model_.ReferenceSystem(\n')
      self.ReferenceSystem.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('Metadata=[\n')
    level += 1
    for Metadata_ in self.Metadata:
      showIndent(outfile, level)
      outfile.write('model_.Metadata(\n')
      Metadata_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'AllowedValues':
      obj_ = AllowedValues.factory()
      obj_.build(child_)
      self.set_AllowedValues(obj_)
    elif nodeName_ == 'AnyValue':
      obj_ = AnyValue.factory()
      obj_.build(child_)
      self.set_AnyValue(obj_)
    elif nodeName_ == 'NoValues':
      obj_ = NoValues.factory()
      obj_.build(child_)
      self.set_NoValues(obj_)
    elif nodeName_ == 'ValuesReference':
      obj_ = ValuesReference.factory()
      obj_.build(child_)
      self.set_ValuesReference(obj_)
    elif nodeName_ == 'DefaultValue':
      obj_ = ValueType.factory()
      obj_.build(child_)
      self.set_DefaultValue(obj_)
    elif nodeName_ == 'Meaning':
      obj_ = DomainMetadataType.factory()
      obj_.build(child_)
      self.set_Meaning(obj_)
    elif nodeName_ == 'DataType':
      obj_ = DomainMetadataType.factory()
      obj_.build(child_)
      self.set_DataType(obj_)
    elif nodeName_ == 'UOM':
      obj_ = DomainMetadataType.factory()
      obj_.build(child_)
      self.set_UOM(obj_)
    elif nodeName_ == 'ReferenceSystem':
      obj_ = DomainMetadataType.factory()
      obj_.build(child_)
      self.set_ReferenceSystem(obj_)
    elif nodeName_ == 'Metadata':
      obj_ = MetadataType.factory()
      obj_.build(child_)
      self.Metadata.append(obj_)
# end class UnNamedDomainType


class AnyValue(GeneratedsSuper):
  """Specifies that any value is allowed for this parameter."""
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None):
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if AnyValue.subclass:
      return AnyValue.subclass(*args_, **kwargs_)
    else:
      return AnyValue(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='AnyValue', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AnyValue')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnyValue'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AnyValue', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AnyValue'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class AnyValue


class NoValues(GeneratedsSuper):
  """Specifies that no values are allowed for this parameter or quantity."""
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None):
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if NoValues.subclass:
      return NoValues.subclass(*args_, **kwargs_)
    else:
      return NoValues(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='NoValues', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='NoValues')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoValues'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='NoValues', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='NoValues'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class NoValues


class ValuesReference(GeneratedsSuper):
  """Reference to externally specified list of all the valid values
  and/or ranges of values for this quantity. (Informative: This
  element was simplified from the metaDataProperty element in GML
  3.0.) Human-readable name of the list of values provided by the
  referenced document. Can be empty string when this list has no
  name."""
  subclass = None
  superclass = None
  def __init__(self, reference=None, valueOf_=None):
    self.reference = _cast(None, reference)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ValuesReference.subclass:
      return ValuesReference.subclass(*args_, **kwargs_)
    else:
      return ValuesReference(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_reference(self): return self.reference
  def set_reference(self, reference): self.reference = reference
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ValuesReference', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ValuesReference')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuesReference'):
    if self.reference is not None and 'reference' not in already_processed:
      already_processed.append('reference')
      outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference).encode(ExternalEncoding), input_name='reference'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='ValuesReference', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ValuesReference'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.reference is not None and 'reference' not in already_processed:
      already_processed.append('reference')
      showIndent(outfile, level)
      outfile.write('reference = "%s",\n' % (self.reference,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('reference', node)
    if value is not None and 'reference' not in already_processed:
      already_processed.append('reference')
      self.reference = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class ValuesReference


class AllowedValues(GeneratedsSuper):
  """List of all the valid values and/or ranges of values for this
  quantity. For numeric quantities, signed values should be
  ordered from negative infinity to positive infinity."""
  subclass = None
  superclass = None
  def __init__(self, Value=None, Range=None):
    if Value is None:
      self.Value = []
    else:
      self.Value = Value
    if Range is None:
      self.Range = []
    else:
      self.Range = Range
  def factory(*args_, **kwargs_):
    if AllowedValues.subclass:
      return AllowedValues.subclass(*args_, **kwargs_)
    else:
      return AllowedValues(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Value(self): return self.Value
  def set_Value(self, Value): self.Value = Value
  def add_Value(self, value): self.Value.append(value)
  def insert_Value(self, index, value): self.Value[index] = value
  def get_Range(self): return self.Range
  def set_Range(self, Range): self.Range = Range
  def add_Range(self, value): self.Range.append(value)
  def insert_Range(self, index, value): self.Range[index] = value
  def export(self, outfile, level, namespace_='', name_='AllowedValues', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AllowedValues')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllowedValues'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AllowedValues', fromsubclass_=False):
    for Value_ in self.Value:
      Value_.export(outfile, level, namespace_, name_='Value')
    for Range_ in self.Range:
      Range_.export(outfile, level, namespace_, name_='Range')
  def hasContent_(self):
    if (
        self.Value or
        self.Range
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AllowedValues'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Value=[\n')
    level += 1
    for Value_ in self.Value:
      showIndent(outfile, level)
      outfile.write('model_.Value(\n')
      Value_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Range=[\n')
    level += 1
    for Range_ in self.Range:
      showIndent(outfile, level)
      outfile.write('model_.Range(\n')
      Range_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Value':
      obj_ = ValueType.factory()
      obj_.build(child_)
      self.Value.append(obj_)
    elif nodeName_ == 'Range':
      obj_ = RangeType.factory()
      obj_.build(child_)
      self.Range.append(obj_)
# end class AllowedValues


class ValueType(GeneratedsSuper):
  """A single value, encoded as a string. This type can be used for one
  value, for a spacing between allowed values, or for the default
  value of a parameter."""
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None):
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ValueType.subclass:
      return ValueType.subclass(*args_, **kwargs_)
    else:
      return ValueType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ValueType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ValueType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ValueType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ValueType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class ValueType


class RangeType(GeneratedsSuper):
  """A range of values of a numeric parameter. This range can be
  continuous or discrete, defined by a fixed spacing between
  adjacent valid values. If the MinimumValue or MaximumValue is
  not included, there is no value limit in that direction.
  Inclusion of the specified minimum and maximum values in the
  range shall be defined by the rangeClosure. Shall be included
  unless the default value applies."""
  subclass = None
  superclass = None
  def __init__(self, rangeClosure=None, MinimumValue=None, MaximumValue=None, Spacing=None):
    self.rangeClosure = _cast(None, rangeClosure)
    self.MinimumValue = MinimumValue
    self.MaximumValue = MaximumValue
    self.Spacing = Spacing
  def factory(*args_, **kwargs_):
    if RangeType.subclass:
      return RangeType.subclass(*args_, **kwargs_)
    else:
      return RangeType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_MinimumValue(self): return self.MinimumValue
  def set_MinimumValue(self, MinimumValue): self.MinimumValue = MinimumValue
  def get_MaximumValue(self): return self.MaximumValue
  def set_MaximumValue(self, MaximumValue): self.MaximumValue = MaximumValue
  def get_Spacing(self): return self.Spacing
  def set_Spacing(self, Spacing): self.Spacing = Spacing
  def get_rangeClosure(self): return self.rangeClosure
  def set_rangeClosure(self, rangeClosure): self.rangeClosure = rangeClosure
  def export(self, outfile, level, namespace_='', name_='RangeType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='RangeType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RangeType'):
    if self.rangeClosure is not None and 'rangeClosure' not in already_processed:
      already_processed.append('rangeClosure')
      outfile.write(' rangeClosure=%s' % (self.gds_format_string(quote_attrib(self.rangeClosure).encode(ExternalEncoding), input_name='rangeClosure'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='RangeType', fromsubclass_=False):
    if self.MinimumValue:
      self.MinimumValue.export(outfile, level, namespace_, name_='MinimumValue')
    if self.MaximumValue:
      self.MaximumValue.export(outfile, level, namespace_, name_='MaximumValue')
    if self.Spacing:
      self.Spacing.export(outfile, level, namespace_, name_='Spacing')
  def hasContent_(self):
    if (
        self.MinimumValue is not None or
        self.MaximumValue is not None or
        self.Spacing is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='RangeType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.rangeClosure is not None and 'rangeClosure' not in already_processed:
      already_processed.append('rangeClosure')
      showIndent(outfile, level)
      outfile.write('rangeClosure = "%s",\n' % (self.rangeClosure,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.MinimumValue is not None:
      showIndent(outfile, level)
      outfile.write('MinimumValue=model_.MinimumValue(\n')
      self.MinimumValue.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.MaximumValue is not None:
      showIndent(outfile, level)
      outfile.write('MaximumValue=model_.MaximumValue(\n')
      self.MaximumValue.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Spacing is not None:
      showIndent(outfile, level)
      outfile.write('Spacing=model_.Spacing(\n')
      self.Spacing.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('rangeClosure', node)
    if value is not None and 'rangeClosure' not in already_processed:
      already_processed.append('rangeClosure')
      self.rangeClosure = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'MinimumValue':
      obj_ = ValueType.factory()
      obj_.build(child_)
      self.set_MinimumValue(obj_)
    elif nodeName_ == 'MaximumValue':
      obj_ = ValueType.factory()
      obj_.build(child_)
      self.set_MaximumValue(obj_)
    elif nodeName_ == 'Spacing':
      obj_ = ValueType.factory()
      obj_.build(child_)
      self.set_Spacing(obj_)
# end class RangeType


class DomainMetadataType(GeneratedsSuper):
  """References metadata about a quantity, and provides a name for this
  metadata. (Informative: This element was simplified from the
  metaDataProperty element in GML 3.0.) Human-readable name of the
  metadata described by associated referenced document."""
  subclass = None
  superclass = None
  def __init__(self, reference=None, valueOf_=None):
    self.reference = _cast(None, reference)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if DomainMetadataType.subclass:
      return DomainMetadataType.subclass(*args_, **kwargs_)
    else:
      return DomainMetadataType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_reference(self): return self.reference
  def set_reference(self, reference): self.reference = reference
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='DomainMetadataType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DomainMetadataType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DomainMetadataType'):
    if self.reference is not None and 'reference' not in already_processed:
      already_processed.append('reference')
      outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference).encode(ExternalEncoding), input_name='reference'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='DomainMetadataType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DomainMetadataType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.reference is not None and 'reference' not in already_processed:
      already_processed.append('reference')
      showIndent(outfile, level)
      outfile.write('reference = "%s",\n' % (self.reference,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('reference', node)
    if value is not None and 'reference' not in already_processed:
      already_processed.append('reference')
      self.reference = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class DomainMetadataType


class ExceptionReport(GeneratedsSuper):
  """Report message returned to the client that requested any OWS
  operation when the server detects an error while processing that
  operation request. Specification version for OWS operation. The
  string value shall contain one x.y.z "version" value (e.g.,
  "2.1.3"). A version number shall contain three non-negative
  integers separated by decimal points, in the form "x.y.z". The
  integers y and z shall not exceed 99. Each version shall be for
  the Implementation Specification (document) and the associated
  XML Schemas to which requested operations will conform. An
  Implementation Specification version normally specifies XML
  Schemas against which an XML encoded operation response must
  conform and should be validated. See Version negotiation
  subclause for more information. Identifier of the language used
  by all included exception text values. These language
  identifiers shall be as specified in IETF RFC 4646. When this
  attribute is omitted, the language used is not identified."""
  subclass = None
  superclass = None
  def __init__(self, lang=None, version=None, Exception=None):
    self.lang = _cast(None, lang)
    self.version = _cast(None, version)
    if Exception is None:
      self.Exception = []
    else:
      self.Exception = Exception
  def factory(*args_, **kwargs_):
    if ExceptionReport.subclass:
      return ExceptionReport.subclass(*args_, **kwargs_)
    else:
      return ExceptionReport(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Exception(self): return self.Exception
  def set_Exception(self, Exception): self.Exception = Exception
  def add_Exception(self, value): self.Exception.append(value)
  def insert_Exception(self, index, value): self.Exception[index] = value
  def get_lang(self): return self.lang
  def set_lang(self, lang): self.lang = lang
  def get_version(self): return self.version
  def set_version(self, version): self.version = version
  def export(self, outfile, level, namespace_='', name_='ExceptionReport', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ExceptionReport')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExceptionReport'):
    if self.lang is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='ExceptionReport', fromsubclass_=False):
    for Exception_ in self.Exception:
      Exception_.export(outfile, level, namespace_, name_='Exception')
  def hasContent_(self):
    if (
        self.Exception
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ExceptionReport'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.lang is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      showIndent(outfile, level)
      outfile.write('lang = "%s",\n' % (self.lang,))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      showIndent(outfile, level)
      outfile.write('version = "%s",\n' % (self.version,))
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Exception=[\n')
    level += 1
    for Exception_ in self.Exception:
      showIndent(outfile, level)
      outfile.write('model_.Exception(\n')
      Exception_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('lang', node)
    if value is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      self.lang = value
    value = find_attr_value_('version', node)
    if value is not None and 'version' not in already_processed:
      already_processed.append('version')
      self.version = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Exception':
      obj_ = ExceptionType.factory()
      obj_.build(child_)
      self.Exception.append(obj_)
# end class ExceptionReport


class ExceptionType(GeneratedsSuper):
  """An Exception element describes one detected error that a server
  chooses to convey to the client. A code representing the type of
  this exception, which shall be selected from a set of
  exceptionCode values specified for the specific service
  operation and server. When included, this locator shall indicate
  to the client where an exception was encountered in servicing
  the client's operation request. This locator should be included
  whenever meaningful information can be provided by the server.
  The contents of this locator will depend on the specific
  exceptionCode and OWS service, and shall be specified in the OWS
  Implementation Specification."""
  subclass = None
  superclass = None
  def __init__(self, locator=None, exceptionCode=None, ExceptionText=None):
    self.locator = _cast(None, locator)
    self.exceptionCode = _cast(None, exceptionCode)
    if ExceptionText is None:
      self.ExceptionText = []
    else:
      self.ExceptionText = ExceptionText
  def factory(*args_, **kwargs_):
    if ExceptionType.subclass:
      return ExceptionType.subclass(*args_, **kwargs_)
    else:
      return ExceptionType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ExceptionText(self): return self.ExceptionText
  def set_ExceptionText(self, ExceptionText): self.ExceptionText = ExceptionText
  def add_ExceptionText(self, value): self.ExceptionText.append(value)
  def insert_ExceptionText(self, index, value): self.ExceptionText[index] = value
  def get_locator(self): return self.locator
  def set_locator(self, locator): self.locator = locator
  def get_exceptionCode(self): return self.exceptionCode
  def set_exceptionCode(self, exceptionCode): self.exceptionCode = exceptionCode
  def export(self, outfile, level, namespace_='', name_='ExceptionType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ExceptionType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExceptionType'):
    if self.locator is not None and 'locator' not in already_processed:
      already_processed.append('locator')
      outfile.write(' locator=%s' % (self.gds_format_string(quote_attrib(self.locator).encode(ExternalEncoding), input_name='locator'), ))
    if self.exceptionCode is not None and 'exceptionCode' not in already_processed:
      already_processed.append('exceptionCode')
      outfile.write(' exceptionCode=%s' % (self.gds_format_string(quote_attrib(self.exceptionCode).encode(ExternalEncoding), input_name='exceptionCode'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='ExceptionType', fromsubclass_=False):
    for ExceptionText_ in self.ExceptionText:
      showIndent(outfile, level)
      outfile.write('<%sExceptionText>%s</%sExceptionText>\n' % (namespace_, self.gds_format_string(quote_xml(ExceptionText_).encode(ExternalEncoding), input_name='ExceptionText'), namespace_))
  def hasContent_(self):
    if (
        self.ExceptionText
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ExceptionType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.locator is not None and 'locator' not in already_processed:
      already_processed.append('locator')
      showIndent(outfile, level)
      outfile.write('locator = "%s",\n' % (self.locator,))
    if self.exceptionCode is not None and 'exceptionCode' not in already_processed:
      already_processed.append('exceptionCode')
      showIndent(outfile, level)
      outfile.write('exceptionCode = "%s",\n' % (self.exceptionCode,))
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('ExceptionText=[\n')
    level += 1
    for ExceptionText_ in self.ExceptionText:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(ExceptionText_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('locator', node)
    if value is not None and 'locator' not in already_processed:
      already_processed.append('locator')
      self.locator = value
    value = find_attr_value_('exceptionCode', node)
    if value is not None and 'exceptionCode' not in already_processed:
      already_processed.append('exceptionCode')
      self.exceptionCode = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ExceptionText':
      ExceptionText_ = child_.text
      ExceptionText_ = self.gds_validate_string(ExceptionText_, node, 'ExceptionText')
      self.ExceptionText.append(ExceptionText_)
# end class ExceptionType


class ContentsBaseType(GeneratedsSuper):
  """Contents of typical Contents section of an OWS service metadata
  (Capabilities) document. This type shall be extended and/or
  restricted if needed for specific OWS use to include the
  specific metadata needed."""
  subclass = None
  superclass = None
  def __init__(self, DatasetDescriptionSummary=None, OtherSource=None):
    if DatasetDescriptionSummary is None:
      self.DatasetDescriptionSummary = []
    else:
      self.DatasetDescriptionSummary = DatasetDescriptionSummary
    if OtherSource is None:
      self.OtherSource = []
    else:
      self.OtherSource = OtherSource
  def factory(*args_, **kwargs_):
    if ContentsBaseType.subclass:
      return ContentsBaseType.subclass(*args_, **kwargs_)
    else:
      return ContentsBaseType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_DatasetDescriptionSummary(self): return self.DatasetDescriptionSummary
  def set_DatasetDescriptionSummary(self, DatasetDescriptionSummary): self.DatasetDescriptionSummary = DatasetDescriptionSummary
  def add_DatasetDescriptionSummary(self, value): self.DatasetDescriptionSummary.append(value)
  def insert_DatasetDescriptionSummary(self, index, value): self.DatasetDescriptionSummary[index] = value
  def get_OtherSource(self): return self.OtherSource
  def set_OtherSource(self, OtherSource): self.OtherSource = OtherSource
  def add_OtherSource(self, value): self.OtherSource.append(value)
  def insert_OtherSource(self, index, value): self.OtherSource[index] = value
  def export(self, outfile, level, namespace_='', name_='ContentsBaseType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContentsBaseType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContentsBaseType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContentsBaseType', fromsubclass_=False):
    for DatasetDescriptionSummary_ in self.DatasetDescriptionSummary:
      DatasetDescriptionSummary_.export(outfile, level, namespace_, name_='Layer')
    for OtherSource_ in self.OtherSource:
      OtherSource_.export(outfile, level, namespace_, name_='OtherSource')
  def hasContent_(self):
    if (
        self.DatasetDescriptionSummary or
        self.OtherSource
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContentsBaseType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('DatasetDescriptionSummary=[\n')
    level += 1
    for DatasetDescriptionSummary_ in self.DatasetDescriptionSummary:
      showIndent(outfile, level)
      outfile.write('model_.DatasetDescriptionSummary(\n')
      DatasetDescriptionSummary_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('OtherSource=[\n')
    level += 1
    for OtherSource_ in self.OtherSource:
      showIndent(outfile, level)
      outfile.write('model_.OtherSource(\n')
      OtherSource_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'DatasetDescriptionSummary':
      obj_ = DatasetDescriptionSummaryBaseType.factory()
      obj_.build(child_)
      self.DatasetDescriptionSummary.append(obj_)
    elif nodeName_ == 'OtherSource':
      obj_ = MetadataType.factory()
      obj_.build(child_)
      self.OtherSource.append(obj_)
# end class ContentsBaseType


class DatasetDescriptionSummaryBaseType(DescriptionType):
  """Typical dataset metadata in typical Contents section of an OWS
  service metadata (Capabilities) document. This type shall be
  extended and/or restricted if needed for specific OWS use, to
  include the specific Dataset description metadata needed."""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, WGS84BoundingBox=None, Identifier=None, BoundingBox=None, Metadata=None, DatasetDescriptionSummary=None):
    super(DatasetDescriptionSummaryBaseType, self).__init__(Title, Abstract, Keywords, )
    if WGS84BoundingBox is None:
      self.WGS84BoundingBox = []
    else:
      self.WGS84BoundingBox = WGS84BoundingBox
    self.Identifier = Identifier
    if BoundingBox is None:
      self.BoundingBox = []
    else:
      self.BoundingBox = BoundingBox
    if Metadata is None:
      self.Metadata = []
    else:
      self.Metadata = Metadata
    if DatasetDescriptionSummary is None:
      self.DatasetDescriptionSummary = []
    else:
      self.DatasetDescriptionSummary = DatasetDescriptionSummary
  def factory(*args_, **kwargs_):
    if DatasetDescriptionSummaryBaseType.subclass:
      return DatasetDescriptionSummaryBaseType.subclass(*args_, **kwargs_)
    else:
      return DatasetDescriptionSummaryBaseType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_WGS84BoundingBox(self): return self.WGS84BoundingBox
  def set_WGS84BoundingBox(self, WGS84BoundingBox): self.WGS84BoundingBox = WGS84BoundingBox
  def add_WGS84BoundingBox(self, value): self.WGS84BoundingBox.append(value)
  def insert_WGS84BoundingBox(self, index, value): self.WGS84BoundingBox[index] = value
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_BoundingBox(self): return self.BoundingBox
  def set_BoundingBox(self, BoundingBox): self.BoundingBox = BoundingBox
  def add_BoundingBox(self, value): self.BoundingBox.append(value)
  def insert_BoundingBox(self, index, value): self.BoundingBox[index] = value
  def get_Metadata(self): return self.Metadata
  def set_Metadata(self, Metadata): self.Metadata = Metadata
  def add_Metadata(self, value): self.Metadata.append(value)
  def insert_Metadata(self, index, value): self.Metadata[index] = value
  def get_DatasetDescriptionSummary(self): return self.DatasetDescriptionSummary
  def set_DatasetDescriptionSummary(self, DatasetDescriptionSummary): self.DatasetDescriptionSummary = DatasetDescriptionSummary
  def add_DatasetDescriptionSummary(self, value): self.DatasetDescriptionSummary.append(value)
  def insert_DatasetDescriptionSummary(self, index, value): self.DatasetDescriptionSummary[index] = value
  def export(self, outfile, level, namespace_='', name_='DatasetDescriptionSummaryBaseType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DatasetDescriptionSummaryBaseType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="DatasetDescriptionSummaryBaseType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatasetDescriptionSummaryBaseType'):
    super(DatasetDescriptionSummaryBaseType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DatasetDescriptionSummaryBaseType')
  def exportChildren(self, outfile, level, namespace_='', name_='DatasetDescriptionSummaryBaseType', fromsubclass_=False):
    super(DatasetDescriptionSummaryBaseType, self).exportChildren(outfile, level, namespace_, name_, True)
    for WGS84BoundingBox_ in self.WGS84BoundingBox:
      WGS84BoundingBox_.export(outfile, level, namespace_, name_='WGS84BoundingBox')
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier', )
    for BoundingBox_ in self.BoundingBox:
      BoundingBox_.export(outfile, level, namespace_, name_='BoundingBox')
    for Metadata_ in self.Metadata:
      Metadata_.export(outfile, level, namespace_, name_='Metadata')
    for DatasetDescriptionSummary_ in self.DatasetDescriptionSummary:
      DatasetDescriptionSummary_.export(outfile, level, namespace_, name_='DatasetDescriptionSummary')
  def hasContent_(self):
    if (
        self.WGS84BoundingBox or
        self.Identifier is not None or
        self.BoundingBox or
        self.Metadata or
        self.DatasetDescriptionSummary or
        super(DatasetDescriptionSummaryBaseType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DatasetDescriptionSummaryBaseType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(DatasetDescriptionSummaryBaseType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(DatasetDescriptionSummaryBaseType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('WGS84BoundingBox=[\n')
    level += 1
    for WGS84BoundingBox_ in self.WGS84BoundingBox:
      showIndent(outfile, level)
      outfile.write('model_.WGS84BoundingBox(\n')
      WGS84BoundingBox_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.CodeType(\n')
      self.Identifier.exportLiteral(outfile, level, name_='Identifier')
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('BoundingBox=[\n')
    level += 1
    for BoundingBox_ in self.BoundingBox:
      showIndent(outfile, level)
      outfile.write('model_.BoundingBox(\n')
      BoundingBox_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Metadata=[\n')
    level += 1
    for Metadata_ in self.Metadata:
      showIndent(outfile, level)
      outfile.write('model_.Metadata(\n')
      Metadata_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DatasetDescriptionSummary=[\n')
    level += 1
    for DatasetDescriptionSummary_ in self.DatasetDescriptionSummary:
      showIndent(outfile, level)
      outfile.write('model_.DatasetDescriptionSummary(\n')
      DatasetDescriptionSummary_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(DatasetDescriptionSummaryBaseType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'WGS84BoundingBox':
      obj_ = WGS84BoundingBoxType.factory()
      obj_.build(child_)
      self.WGS84BoundingBox.append(obj_)
    elif nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'BoundingBox':
      obj_ = BoundingBoxType.factory()
      obj_.build(child_)
      self.BoundingBox.append(obj_)
    elif nodeName_ == 'Metadata':
      obj_ = MetadataType.factory()
      obj_.build(child_)
      self.Metadata.append(obj_)
    elif nodeName_ == 'DatasetDescriptionSummary':
      obj_ = DatasetDescriptionSummaryBaseType.factory()
      obj_.build(child_)
      self.DatasetDescriptionSummary.append(obj_)
    super(DatasetDescriptionSummaryBaseType, self).buildChildren(child_, node, nodeName_, True)
# end class DatasetDescriptionSummaryBaseType


class AbstractReferenceBaseType(GeneratedsSuper):
  """Base for a reference to a remote or local resource. This type
  contains only a restricted and annotated set of the attributes
  from the xlink:simpleLink attributeGroup. Reference to a remote
  resource or local payload. A remote resource is typically
  addressed by a URL. For a local payload (such as a multipart
  mime message), the xlink:href must start with the prefix cid:.
  Reference to a resource that describes the role of this
  reference. When no value is supplied, no particular role value
  is to be inferred. Although allowed, this attribute is not
  expected to be useful in this application of xlink:simpleLink.
  Describes the meaning of the referenced resource in a human-
  readable fashion. Although allowed, this attribute is not
  expected to be useful in this application of xlink:simpleLink.
  Although allowed, this attribute is not expected to be useful in
  this application of xlink:simpleLink."""
  subclass = None
  superclass = None
  def __init__(self, show=None, title=None, actuate=None, href=None, role=None, arcrole=None, type_=None, valueOf_=None):
    self.show = _cast(None, show)
    self.title = _cast(None, title)
    self.actuate = _cast(None, actuate)
    self.href = _cast(None, href)
    self.role = _cast(None, role)
    self.arcrole = _cast(None, arcrole)
    self.type_ = _cast(None, type_)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if AbstractReferenceBaseType.subclass:
      return AbstractReferenceBaseType.subclass(*args_, **kwargs_)
    else:
      return AbstractReferenceBaseType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_show(self): return self.show
  def set_show(self, show): self.show = show
  def get_title(self): return self.title
  def set_title(self, title): self.title = title
  def get_actuate(self): return self.actuate
  def set_actuate(self, actuate): self.actuate = actuate
  def get_href(self): return self.href
  def set_href(self, href): self.href = href
  def get_role(self): return self.role
  def set_role(self, role): self.role = role
  def get_arcrole(self): return self.arcrole
  def set_arcrole(self, arcrole): self.arcrole = arcrole
  def get_type(self): return self.type_
  def set_type(self, type_): self.type_ = type_
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='AbstractReferenceBaseType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AbstractReferenceBaseType')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractReferenceBaseType'):
    if self.show is not None and 'show' not in already_processed:
      already_processed.append('show')
      outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
    if self.title is not None and 'title' not in already_processed:
      already_processed.append('title')
      outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
    if self.actuate is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
    if self.href is not None and 'href' not in already_processed:
      already_processed.append('href')
      outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    if self.role is not None and 'role' not in already_processed:
      already_processed.append('role')
      outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
    if self.arcrole is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='AbstractReferenceBaseType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AbstractReferenceBaseType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.show is not None and 'show' not in already_processed:
      already_processed.append('show')
      showIndent(outfile, level)
      outfile.write('show = "%s",\n' % (self.show,))
    if self.title is not None and 'title' not in already_processed:
      already_processed.append('title')
      showIndent(outfile, level)
      outfile.write('title = "%s",\n' % (self.title,))
    if self.actuate is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      showIndent(outfile, level)
      outfile.write('actuate = "%s",\n' % (self.actuate,))
    if self.href is not None and 'href' not in already_processed:
      already_processed.append('href')
      showIndent(outfile, level)
      outfile.write('href = "%s",\n' % (self.href,))
    if self.role is not None and 'role' not in already_processed:
      already_processed.append('role')
      showIndent(outfile, level)
      outfile.write('role = "%s",\n' % (self.role,))
    if self.arcrole is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      showIndent(outfile, level)
      outfile.write('arcrole = "%s",\n' % (self.arcrole,))
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      showIndent(outfile, level)
      outfile.write('type_ = "%s",\n' % (self.type_,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('show', node)
    if value is not None and 'show' not in already_processed:
      already_processed.append('show')
      self.show = value
    value = find_attr_value_('title', node)
    if value is not None and 'title' not in already_processed:
      already_processed.append('title')
      self.title = value
    value = find_attr_value_('actuate', node)
    if value is not None and 'actuate' not in already_processed:
      already_processed.append('actuate')
      self.actuate = value
    value = find_attr_value_('href', node)
    if value is not None and 'href' not in already_processed:
      already_processed.append('href')
      self.href = value
    value = find_attr_value_('role', node)
    if value is not None and 'role' not in already_processed:
      already_processed.append('role')
      self.role = value
    value = find_attr_value_('arcrole', node)
    if value is not None and 'arcrole' not in already_processed:
      already_processed.append('arcrole')
      self.arcrole = value
    value = find_attr_value_('type', node)
    if value is not None and 'type' not in already_processed:
      already_processed.append('type')
      self.type_ = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class AbstractReferenceBaseType


class ReferenceType(AbstractReferenceBaseType):
  """Complete reference to a remote or local resource, allowing including
  metadata about that resource."""
  subclass = None
  superclass = AbstractReferenceBaseType
  def __init__(self, show=None, title=None, actuate=None, href=None, role=None, arcrole=None, type_=None, Identifier=None, Abstract=None, Format=None, Metadata=None):
    super(ReferenceType, self).__init__(show, title, actuate, href, role, arcrole, type_, )
    self.Identifier = Identifier
    if Abstract is None:
      self.Abstract = []
    else:
      self.Abstract = Abstract
    self.Format = Format
    if Metadata is None:
      self.Metadata = []
    else:
      self.Metadata = Metadata
  def factory(*args_, **kwargs_):
    if ReferenceType.subclass:
      return ReferenceType.subclass(*args_, **kwargs_)
    else:
      return ReferenceType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_Abstract(self): return self.Abstract
  def set_Abstract(self, Abstract): self.Abstract = Abstract
  def add_Abstract(self, value): self.Abstract.append(value)
  def insert_Abstract(self, index, value): self.Abstract[index] = value
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def validate_MimeType(self, value):
    # Validate type MimeType, a restriction on string.
    pass
  def get_Metadata(self): return self.Metadata
  def set_Metadata(self, Metadata): self.Metadata = Metadata
  def add_Metadata(self, value): self.Metadata.append(value)
  def insert_Metadata(self, index, value): self.Metadata[index] = value
  def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ReferenceType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="ReferenceType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
    super(ReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
  def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False):
    super(ReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier')
    for Abstract_ in self.Abstract:
      Abstract_.export(outfile, level, namespace_, name_='Abstract')
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('<%sFormat>%s</%sFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_))
    for Metadata_ in self.Metadata:
      Metadata_.export(outfile, level, namespace_, name_='Metadata')
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.Abstract or
        self.Format is not None or
        self.Metadata or
        super(ReferenceType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ReferenceType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(ReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(ReferenceType, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('Abstract=[\n')
    level += 1
    for Abstract_ in self.Abstract:
      showIndent(outfile, level)
      outfile.write('model_.Abstract(\n')
      Abstract_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
    showIndent(outfile, level)
    outfile.write('Metadata=[\n')
    level += 1
    for Metadata_ in self.Metadata:
      showIndent(outfile, level)
      outfile.write('model_.Metadata(\n')
      Metadata_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(ReferenceType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'Abstract':
      obj_ = LanguageStringType.factory()
      obj_.build(child_)
      self.Abstract.append(obj_)
    elif nodeName_ == 'Format':
      Format_ = child_.text
      Format_ = self.gds_validate_string(Format_, node, 'Format')
      self.Format = Format_
      self.validate_MimeType(self.Format)    # validate type MimeType
    elif nodeName_ == 'Metadata':
      obj_ = MetadataType.factory()
      obj_.build(child_)
      self.Metadata.append(obj_)
    super(ReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class ReferenceType


class ReferenceGroupType(BasicIdentificationType):
  """Logical group of one or more references to remote and/or local
  resources, allowing including metadata about that group. A Group
  can be used instead of a Manifest that can only contain one
  group."""
  subclass = None
  superclass = BasicIdentificationType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, Metadata=None, AbstractReferenceBase=None):
    super(ReferenceGroupType, self).__init__(Title, Abstract, Keywords, Identifier, Metadata, )
    if AbstractReferenceBase is None:
      self.AbstractReferenceBase = []
    else:
      self.AbstractReferenceBase = AbstractReferenceBase
  def factory(*args_, **kwargs_):
    if ReferenceGroupType.subclass:
      return ReferenceGroupType.subclass(*args_, **kwargs_)
    else:
      return ReferenceGroupType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_AbstractReferenceBase(self): return self.AbstractReferenceBase
  def set_AbstractReferenceBase(self, AbstractReferenceBase): self.AbstractReferenceBase = AbstractReferenceBase
  def add_AbstractReferenceBase(self, value): self.AbstractReferenceBase.append(value)
  def insert_AbstractReferenceBase(self, index, value): self.AbstractReferenceBase[index] = value
  def export(self, outfile, level, namespace_='', name_='ReferenceGroupType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ReferenceGroupType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="ReferenceGroupType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceGroupType'):
    super(ReferenceGroupType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceGroupType')
  def exportChildren(self, outfile, level, namespace_='', name_='ReferenceGroupType', fromsubclass_=False):
    super(ReferenceGroupType, self).exportChildren(outfile, level, namespace_, name_, True)
    for AbstractReferenceBase_ in self.get_AbstractReferenceBase():
      AbstractReferenceBase_.export(outfile, level, namespace_, name_='AbstractReferenceBase')
  def hasContent_(self):
    if (
        self.AbstractReferenceBase or
        super(ReferenceGroupType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ReferenceGroupType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(ReferenceGroupType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(ReferenceGroupType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('AbstractReferenceBase=[\n')
    level += 1
    for AbstractReferenceBase_ in self.AbstractReferenceBase:
      showIndent(outfile, level)
      outfile.write('model_.AbstractReferenceBase(\n')
      AbstractReferenceBase_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(ReferenceGroupType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'AbstractReferenceBase':
      type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
      if type_name_ is None:
        type_name_ = child_.attrib.get('type')
      if type_name_ is not None:
        type_names_ = type_name_.split(':')
        if len(type_names_) == 1:
          type_name_ = type_names_[0]
        else:
          type_name_ = type_names_[1]
        class_ = globals()[type_name_]
        obj_ = class_.factory()
        obj_.build(child_)
      else:
        raise NotImplementedError(
            'Class not implemented for <AbstractReferenceBase> element')
      self.AbstractReferenceBase.append(obj_)
    super(ReferenceGroupType, self).buildChildren(child_, node, nodeName_, True)
# end class ReferenceGroupType


class ManifestType(BasicIdentificationType):
  """Unordered list of one or more groups of references to remote and/or
  local resources."""
  subclass = None
  superclass = BasicIdentificationType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, Metadata=None, ReferenceGroup=None):
    super(ManifestType, self).__init__(Title, Abstract, Keywords, Identifier, Metadata, )
    if ReferenceGroup is None:
      self.ReferenceGroup = []
    else:
      self.ReferenceGroup = ReferenceGroup
  def factory(*args_, **kwargs_):
    if ManifestType.subclass:
      return ManifestType.subclass(*args_, **kwargs_)
    else:
      return ManifestType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ReferenceGroup(self): return self.ReferenceGroup
  def set_ReferenceGroup(self, ReferenceGroup): self.ReferenceGroup = ReferenceGroup
  def add_ReferenceGroup(self, value): self.ReferenceGroup.append(value)
  def insert_ReferenceGroup(self, index, value): self.ReferenceGroup[index] = value
  def export(self, outfile, level, namespace_='', name_='ManifestType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ManifestType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="ManifestType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ManifestType'):
    super(ManifestType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ManifestType')
  def exportChildren(self, outfile, level, namespace_='', name_='ManifestType', fromsubclass_=False):
    super(ManifestType, self).exportChildren(outfile, level, namespace_, name_, True)
    for ReferenceGroup_ in self.ReferenceGroup:
      ReferenceGroup_.export(outfile, level, namespace_, name_='ReferenceGroup')
  def hasContent_(self):
    if (
        self.ReferenceGroup or
        super(ManifestType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ManifestType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(ManifestType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(ManifestType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('ReferenceGroup=[\n')
    level += 1
    for ReferenceGroup_ in self.ReferenceGroup:
      showIndent(outfile, level)
      outfile.write('model_.ReferenceGroup(\n')
      ReferenceGroup_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(ManifestType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ReferenceGroup':
      obj_ = ReferenceGroupType.factory()
      obj_.build(child_)
      self.ReferenceGroup.append(obj_)
    super(ManifestType, self).buildChildren(child_, node, nodeName_, True)
# end class ManifestType


class ServiceReferenceType(ReferenceType):
  """Complete reference to a remote resource that needs to be retrieved
  from an OWS using an XML-encoded operation request. This element
  shall be used, within an InputData or Manifest element that is
  used for input data, when that input data needs to be retrieved
  from another web service using a XML-encoded OWS operation
  request. This element shall not be used for local payload input
  data or for requesting the resource from a web server using HTTP
  Get."""
  subclass = None
  superclass = ReferenceType
  def __init__(self, show=None, title=None, actuate=None, href=None, role=None, arcrole=None, type_=None, Identifier=None, Abstract=None, Format=None, Metadata=None, RequestMessage=None, RequestMessageReference=None):
    super(ServiceReferenceType, self).__init__(show, title, actuate, href, role, arcrole, type_, Identifier, Abstract, Format, Metadata, )
    self.RequestMessage = RequestMessage
    self.RequestMessageReference = RequestMessageReference
  def factory(*args_, **kwargs_):
    if ServiceReferenceType.subclass:
      return ServiceReferenceType.subclass(*args_, **kwargs_)
    else:
      return ServiceReferenceType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_RequestMessage(self): return self.RequestMessage
  def set_RequestMessage(self, RequestMessage): self.RequestMessage = RequestMessage
  def get_RequestMessageReference(self): return self.RequestMessageReference
  def set_RequestMessageReference(self, RequestMessageReference): self.RequestMessageReference = RequestMessageReference
  def export(self, outfile, level, namespace_='', name_='ServiceReferenceType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ServiceReferenceType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="ServiceReferenceType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceReferenceType'):
    super(ServiceReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceReferenceType')
  def exportChildren(self, outfile, level, namespace_='', name_='ServiceReferenceType', fromsubclass_=False):
    super(ServiceReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.RequestMessage is not None:
      showIndent(outfile, level)
      outfile.write('<%sRequestMessage>%s</%sRequestMessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.RequestMessage).encode(ExternalEncoding), input_name='RequestMessage'), namespace_))
    if self.RequestMessageReference is not None:
      showIndent(outfile, level)
      outfile.write('<%sRequestMessageReference>%s</%sRequestMessageReference>\n' % (namespace_, self.gds_format_string(quote_xml(self.RequestMessageReference).encode(ExternalEncoding), input_name='RequestMessageReference'), namespace_))
  def hasContent_(self):
    if (
        self.RequestMessage is not None or
        self.RequestMessageReference is not None or
        super(ServiceReferenceType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ServiceReferenceType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(ServiceReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(ServiceReferenceType, self).exportLiteralChildren(outfile, level, name_)
    if self.RequestMessage is not None:
      showIndent(outfile, level)
      outfile.write('RequestMessage=%s,\n' % quote_python(self.RequestMessage).encode(ExternalEncoding))
    if self.RequestMessageReference is not None:
      showIndent(outfile, level)
      outfile.write('RequestMessageReference=%s,\n' % quote_python(self.RequestMessageReference).encode(ExternalEncoding))
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(ServiceReferenceType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'RequestMessage':
      RequestMessage_ = child_.text
      RequestMessage_ = self.gds_validate_string(RequestMessage_, node, 'RequestMessage')
      self.RequestMessage = RequestMessage_
    elif nodeName_ == 'RequestMessageReference':
      RequestMessageReference_ = child_.text
      RequestMessageReference_ = self.gds_validate_string(RequestMessageReference_, node, 'RequestMessageReference')
      self.RequestMessageReference = RequestMessageReference_
    super(ServiceReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceReferenceType


class DomainType(UnNamedDomainType):
  """Valid domain (or allowed set of values) of one quantity, with its
  name or identifier. Name or identifier of this quantity."""
  subclass = None
  superclass = UnNamedDomainType
  def __init__(self, AllowedValues=None, AnyValue=None, NoValues=None, ValuesReference=None, DefaultValue=None, Meaning=None, DataType=None, UOM=None, ReferenceSystem=None, Metadata=None, name=None):
    super(DomainType, self).__init__(AllowedValues, AnyValue, NoValues, ValuesReference, DefaultValue, Meaning, DataType, UOM, ReferenceSystem, Metadata, )
    self.name = _cast(None, name)
    pass
  def factory(*args_, **kwargs_):
    if DomainType.subclass:
      return DomainType.subclass(*args_, **kwargs_)
    else:
      return DomainType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_name(self): return self.name
  def set_name(self, name): self.name = name
  def export(self, outfile, level, namespace_='', name_='DomainType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DomainType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="DomainType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DomainType'):
    super(DomainType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DomainType')
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='DomainType', fromsubclass_=False):
    super(DomainType, self).exportChildren(outfile, level, namespace_, name_, True)
  def hasContent_(self):
    if (
        super(DomainType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DomainType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      showIndent(outfile, level)
      outfile.write('name = "%s",\n' % (self.name,))
    super(DomainType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(DomainType, self).exportLiteralChildren(outfile, level, name_)
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('name', node)
    if value is not None and 'name' not in already_processed:
      already_processed.append('name')
      self.name = value
    super(DomainType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    super(DomainType, self).buildChildren(child_, node, nodeName_, True)
    pass
# end class DomainType


class Theme(DescriptionType):
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, Theme=None, LayerRef=None):
    super(Theme, self).__init__(Title, Abstract, Keywords, )
    self.Identifier = Identifier
    if Theme is None:
      self.Theme = []
    else:
      self.Theme = Theme
    if LayerRef is None:
      self.LayerRef = []
    else:
      self.LayerRef = LayerRef
  def factory(*args_, **kwargs_):
    if Theme.subclass:
      return Theme.subclass(*args_, **kwargs_)
    else:
      return Theme(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_Theme(self): return self.Theme
  def set_Theme(self, Theme): self.Theme = Theme
  def add_Theme(self, value): self.Theme.append(value)
  def insert_Theme(self, index, value): self.Theme[index] = value
  def get_LayerRef(self): return self.LayerRef
  def set_LayerRef(self, LayerRef): self.LayerRef = LayerRef
  def add_LayerRef(self, value): self.LayerRef.append(value)
  def insert_LayerRef(self, index, value): self.LayerRef[index] = value
  def export(self, outfile, level, namespace_='', name_='Theme', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Theme')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="Theme"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Theme'):
    super(Theme, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Theme')
  def exportChildren(self, outfile, level, namespace_='', name_='Theme', fromsubclass_=False):
    super(Theme, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier', )
    for Theme_ in self.Theme:
      Theme_.export(outfile, level, namespace_, name_='Theme')
    for LayerRef_ in self.LayerRef:
      showIndent(outfile, level)
      outfile.write('<%sLayerRef>%s</%sLayerRef>\n' % (namespace_, self.gds_format_string(quote_xml(LayerRef_).encode(ExternalEncoding), input_name='LayerRef'), namespace_))
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.Theme or
        self.LayerRef or
        super(Theme, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Theme'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(Theme, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(Theme, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('Theme=[\n')
    level += 1
    for Theme_ in self.Theme:
      showIndent(outfile, level)
      outfile.write('model_.Theme(\n')
      Theme_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('LayerRef=[\n')
    level += 1
    for LayerRef_ in self.LayerRef:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(LayerRef_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(Theme, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'Theme':
      obj_ = Theme.factory()
      obj_.build(child_)
      self.Theme.append(obj_)
    elif nodeName_ == 'LayerRef':
      LayerRef_ = child_.text
      LayerRef_ = self.gds_validate_string(LayerRef_, node, 'LayerRef')
      self.LayerRef.append(LayerRef_)
    super(Theme, self).buildChildren(child_, node, nodeName_, True)
# end class Theme


class TileMatrix(DescriptionType):
  """Describes a particular tile matrix."""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, ScaleDenominator=None, TopLeftCorner=None, TileWidth=None, TileHeight=None, MatrixWidth=None, MatrixHeight=None):
    super(TileMatrix, self).__init__(Title, Abstract, Keywords, )
    self.Identifier = Identifier
    self.ScaleDenominator = ScaleDenominator
    self.TopLeftCorner = TopLeftCorner
    self.TileWidth = TileWidth
    self.TileHeight = TileHeight
    self.MatrixWidth = MatrixWidth
    self.MatrixHeight = MatrixHeight
  def factory(*args_, **kwargs_):
    if TileMatrix.subclass:
      return TileMatrix.subclass(*args_, **kwargs_)
    else:
      return TileMatrix(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_ScaleDenominator(self): return self.ScaleDenominator
  def set_ScaleDenominator(self, ScaleDenominator): self.ScaleDenominator = ScaleDenominator
  def get_TopLeftCorner(self): return self.TopLeftCorner
  def set_TopLeftCorner(self, TopLeftCorner): self.TopLeftCorner = TopLeftCorner
  def validate_PositionType(self, value):
    # Validate type PositionType, a restriction on double.
    pass
  def get_TileWidth(self): return self.TileWidth
  def set_TileWidth(self, TileWidth): self.TileWidth = TileWidth
  def get_TileHeight(self): return self.TileHeight
  def set_TileHeight(self, TileHeight): self.TileHeight = TileHeight
  def get_MatrixWidth(self): return self.MatrixWidth
  def set_MatrixWidth(self, MatrixWidth): self.MatrixWidth = MatrixWidth
  def get_MatrixHeight(self): return self.MatrixHeight
  def set_MatrixHeight(self, MatrixHeight): self.MatrixHeight = MatrixHeight
  def export(self, outfile, level, namespace_='', name_='TileMatrix', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='TileMatrix')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="TileMatrix"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TileMatrix'):
    super(TileMatrix, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TileMatrix')
  def exportChildren(self, outfile, level, namespace_='', name_='TileMatrix', fromsubclass_=False):
    super(TileMatrix, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier', )
    if self.ScaleDenominator is not None:
      showIndent(outfile, level)
      outfile.write('<%sScaleDenominator>%s</%sScaleDenominator>\n' % (namespace_, self.gds_format_double(self.ScaleDenominator, input_name='ScaleDenominator'), namespace_))
    if self.TopLeftCorner is not None:
      showIndent(outfile, level)
      outfile.write('<%sTopLeftCorner>%s</%sTopLeftCorner>\n' % (namespace_, self.gds_format_double_list(self.TopLeftCorner, input_name='TopLeftCorner'), namespace_))
    if self.TileWidth is not None:
      showIndent(outfile, level)
      outfile.write('<%sTileWidth>%s</%sTileWidth>\n' % (namespace_, self.gds_format_integer(self.TileWidth, input_name='TileWidth'), namespace_))
    if self.TileHeight is not None:
      showIndent(outfile, level)
      outfile.write('<%sTileHeight>%s</%sTileHeight>\n' % (namespace_, self.gds_format_integer(self.TileHeight, input_name='TileHeight'), namespace_))
    if self.MatrixWidth is not None:
      showIndent(outfile, level)
      outfile.write('<%sMatrixWidth>%s</%sMatrixWidth>\n' % (namespace_, self.gds_format_integer(self.MatrixWidth, input_name='MatrixWidth'), namespace_))
    if self.MatrixHeight is not None:
      showIndent(outfile, level)
      outfile.write('<%sMatrixHeight>%s</%sMatrixHeight>\n' % (namespace_, self.gds_format_integer(self.MatrixHeight, input_name='MatrixHeight'), namespace_))
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.ScaleDenominator is not None or
        self.TopLeftCorner is not None or
        self.TileWidth is not None or
        self.TileHeight is not None or
        self.MatrixWidth is not None or
        self.MatrixHeight is not None or
        super(TileMatrix, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='TileMatrix'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(TileMatrix, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(TileMatrix, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ScaleDenominator is not None:
      showIndent(outfile, level)
      outfile.write('ScaleDenominator=%e,\n' % self.ScaleDenominator)
    if self.TopLeftCorner is not None:
      showIndent(outfile, level)
      outfile.write('TopLeftCorner=%e,\n' % self.TopLeftCorner)
    if self.TileWidth is not None:
      showIndent(outfile, level)
      outfile.write('TileWidth=%d,\n' % self.TileWidth)
    if self.TileHeight is not None:
      showIndent(outfile, level)
      outfile.write('TileHeight=%d,\n' % self.TileHeight)
    if self.MatrixWidth is not None:
      showIndent(outfile, level)
      outfile.write('MatrixWidth=%d,\n' % self.MatrixWidth)
    if self.MatrixHeight is not None:
      showIndent(outfile, level)
      outfile.write('MatrixHeight=%d,\n' % self.MatrixHeight)
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(TileMatrix, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'ScaleDenominator':
      sval_ = child_.text
      try:
        fval_ = float(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires float or double: %s' % exp)
      fval_ = self.gds_validate_float(fval_, node, 'ScaleDenominator')
      self.ScaleDenominator = fval_
    elif nodeName_ == 'TopLeftCorner':
      TopLeftCorner_ = child_.text
      TopLeftCorner_ = self.gds_validate_double_list(TopLeftCorner_, node, 'TopLeftCorner')
      self.TopLeftCorner = TopLeftCorner_
      self.TopLeftCorner = self.TopLeftCorner.split()
      self.validate_PositionType(self.TopLeftCorner)    # validate type PositionType
    elif nodeName_ == 'TileWidth':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'TileWidth')
      self.TileWidth = ival_
    elif nodeName_ == 'TileHeight':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'TileHeight')
      self.TileHeight = ival_
    elif nodeName_ == 'MatrixWidth':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'MatrixWidth')
      self.MatrixWidth = ival_
    elif nodeName_ == 'MatrixHeight':
      sval_ = child_.text
      try:
        ival_ = int(sval_)
      except (TypeError, ValueError), exp:
        raise_parse_error(child_, 'requires integer: %s' % exp)
      if ival_ <= 0:
        raise_parse_error(child_, 'requires positiveInteger')
      ival_ = self.gds_validate_integer(ival_, node, 'MatrixHeight')
      self.MatrixHeight = ival_
    super(TileMatrix, self).buildChildren(child_, node, nodeName_, True)
# end class TileMatrix


class TileMatrixSet(DescriptionType):
  """Describes a particular set of tile matrices."""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, BoundingBox=None, SupportedCRS=None, WellKnownScaleSet=None, TileMatrix=None):
    super(TileMatrixSet, self).__init__(Title, Abstract, Keywords, )
    self.Identifier = Identifier
    self.BoundingBox = BoundingBox
    self.SupportedCRS = SupportedCRS
    self.WellKnownScaleSet = WellKnownScaleSet
    if TileMatrix is None:
      self.TileMatrix = []
    else:
      self.TileMatrix = TileMatrix
  def factory(*args_, **kwargs_):
    if TileMatrixSet.subclass:
      return TileMatrixSet.subclass(*args_, **kwargs_)
    else:
      return TileMatrixSet(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_BoundingBox(self): return self.BoundingBox
  def set_BoundingBox(self, BoundingBox): self.BoundingBox = BoundingBox
  def get_SupportedCRS(self): return self.SupportedCRS
  def set_SupportedCRS(self, SupportedCRS): self.SupportedCRS = SupportedCRS
  def get_WellKnownScaleSet(self): return self.WellKnownScaleSet
  def set_WellKnownScaleSet(self, WellKnownScaleSet): self.WellKnownScaleSet = WellKnownScaleSet
  def get_TileMatrix(self): return self.TileMatrix
  def set_TileMatrix(self, TileMatrix): self.TileMatrix = TileMatrix
  def add_TileMatrix(self, value): self.TileMatrix.append(value)
  def insert_TileMatrix(self, index, value): self.TileMatrix[index] = value
  def export(self, outfile, level, namespace_='', name_='TileMatrixSet', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='TileMatrixSet')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="TileMatrixSet"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TileMatrixSet'):
    super(TileMatrixSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TileMatrixSet')
  def exportChildren(self, outfile, level, namespace_='', name_='TileMatrixSet', fromsubclass_=False):
    super(TileMatrixSet, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier', )
    if self.BoundingBox:
      self.BoundingBox.export(outfile, level, namespace_, name_='BoundingBox')
    if self.SupportedCRS is not None:
      showIndent(outfile, level)
      outfile.write('<%sows:SupportedCRS>%s</%sows:SupportedCRS>\n' % (namespace_, self.gds_format_string(quote_xml(self.SupportedCRS).encode(ExternalEncoding), input_name='SupportedCRS'), namespace_))
    if self.WellKnownScaleSet is not None:
      showIndent(outfile, level)
      outfile.write('<%sWellKnownScaleSet>%s</%sWellKnownScaleSet>\n' % (namespace_, self.gds_format_string(quote_xml(self.WellKnownScaleSet).encode(ExternalEncoding), input_name='WellKnownScaleSet'), namespace_))
    for TileMatrix_ in self.TileMatrix:
      TileMatrix_.export(outfile, level, namespace_, name_='TileMatrix')
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.BoundingBox is not None or
        self.SupportedCRS is not None or
        self.WellKnownScaleSet is not None or
        self.TileMatrix or
        super(TileMatrixSet, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='TileMatrixSet'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(TileMatrixSet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(TileMatrixSet, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.BoundingBox is not None:
      showIndent(outfile, level)
      outfile.write('BoundingBox=model_.BoundingBox(\n')
      self.BoundingBox.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.SupportedCRS is not None:
      showIndent(outfile, level)
      outfile.write('SupportedCRS=%s,\n' % quote_python(self.SupportedCRS).encode(ExternalEncoding))
    if self.WellKnownScaleSet is not None:
      showIndent(outfile, level)
      outfile.write('WellKnownScaleSet=%s,\n' % quote_python(self.WellKnownScaleSet).encode(ExternalEncoding))
    showIndent(outfile, level)
    outfile.write('TileMatrix=[\n')
    level += 1
    for TileMatrix_ in self.TileMatrix:
      showIndent(outfile, level)
      outfile.write('model_.TileMatrix(\n')
      TileMatrix_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(TileMatrixSet, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'BoundingBox':
      obj_ = BoundingBoxType.factory()
      obj_.build(child_)
      self.set_BoundingBox(obj_)
    elif nodeName_ == 'SupportedCRS':
      SupportedCRS_ = child_.text
      SupportedCRS_ = self.gds_validate_string(SupportedCRS_, node, 'SupportedCRS')
      self.SupportedCRS = SupportedCRS_
    elif nodeName_ == 'WellKnownScaleSet':
      WellKnownScaleSet_ = child_.text
      WellKnownScaleSet_ = self.gds_validate_string(WellKnownScaleSet_, node, 'WellKnownScaleSet')
      self.WellKnownScaleSet = WellKnownScaleSet_
    elif nodeName_ == 'TileMatrix':
      obj_ = TileMatrix.factory()
      obj_.build(child_)
      self.TileMatrix.append(obj_)
    super(TileMatrixSet, self).buildChildren(child_, node, nodeName_, True)
# end class TileMatrixSet


class Dimension(DescriptionType):
  """Metadata about a particular dimension that the tiles of a layer are
  available."""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, Identifier=None, UOM=None, UnitSymbol=None, Default=None, Current=None, Value=None):
    super(Dimension, self).__init__(Title, Abstract, Keywords, )
    self.Identifier = Identifier
    self.UOM = UOM
    self.UnitSymbol = UnitSymbol
    self.Default = Default
    self.Current = Current
    if Value is None:
      self.Value = []
    else:
      self.Value = Value
  def factory(*args_, **kwargs_):
    if Dimension.subclass:
      return Dimension.subclass(*args_, **kwargs_)
    else:
      return Dimension(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_UOM(self): return self.UOM
  def set_UOM(self, UOM): self.UOM = UOM
  def get_UnitSymbol(self): return self.UnitSymbol
  def set_UnitSymbol(self, UnitSymbol): self.UnitSymbol = UnitSymbol
  def get_Default(self): return self.Default
  def set_Default(self, Default): self.Default = Default
  def get_Current(self): return self.Current
  def set_Current(self, Current): self.Current = Current
  def get_Value(self): return self.Value
  def set_Value(self, Value): self.Value = Value
  def add_Value(self, value): self.Value.append(value)
  def insert_Value(self, index, value): self.Value[index] = value
  def export(self, outfile, level, namespace_='', name_='Dimension', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Dimension')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="Dimension"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Dimension'):
    super(Dimension, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Dimension')
  def exportChildren(self, outfile, level, namespace_='', name_='Dimension', fromsubclass_=False):
    super(Dimension, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier', )
    if self.UOM:
      self.UOM.export(outfile, level, namespace_, name_='UOM')
    if self.UnitSymbol is not None:
      showIndent(outfile, level)
      outfile.write('<%sUnitSymbol>%s</%sUnitSymbol>\n' % (namespace_, self.gds_format_string(quote_xml(self.UnitSymbol).encode(ExternalEncoding), input_name='UnitSymbol'), namespace_))
    if self.Default is not None:
      showIndent(outfile, level)
      outfile.write('<%sDefault>%s</%sDefault>\n' % (namespace_, self.gds_format_string(quote_xml(self.Default).encode(ExternalEncoding), input_name='Default'), namespace_))
    if self.Current is not None:
      showIndent(outfile, level)
      outfile.write('<%sCurrent>%s</%sCurrent>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.Current)), input_name='Current'), namespace_))
    for Value_ in self.Value:
      showIndent(outfile, level)
      outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.UOM is not None or
        self.UnitSymbol is not None or
        self.Default is not None or
        self.Current is not None or
        self.Value or
        super(Dimension, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Dimension'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(Dimension, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(Dimension, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.UOM is not None:
      showIndent(outfile, level)
      outfile.write('UOM=model_.UOM(\n')
      self.UOM.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.UnitSymbol is not None:
      showIndent(outfile, level)
      outfile.write('UnitSymbol=%s,\n' % quote_python(self.UnitSymbol).encode(ExternalEncoding))
    if self.Default is not None:
      showIndent(outfile, level)
      outfile.write('Default=%s,\n' % quote_python(self.Default).encode(ExternalEncoding))
    if self.Current is not None:
      showIndent(outfile, level)
      outfile.write('Current=%s,\n' % self.Current)
    showIndent(outfile, level)
    outfile.write('Value=[\n')
    level += 1
    for Value_ in self.Value:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(Dimension, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'UOM':
      obj_ = DomainMetadataType.factory()
      obj_.build(child_)
      self.set_UOM(obj_)
    elif nodeName_ == 'UnitSymbol':
      UnitSymbol_ = child_.text
      UnitSymbol_ = self.gds_validate_string(UnitSymbol_, node, 'UnitSymbol')
      self.UnitSymbol = UnitSymbol_
    elif nodeName_ == 'Default':
      Default_ = child_.text
      Default_ = self.gds_validate_string(Default_, node, 'Default')
      self.Default = Default_
    elif nodeName_ == 'Current':
      sval_ = child_.text
      if sval_ in ('true', '1'):
        ival_ = True
      elif sval_ in ('false', '0'):
        ival_ = False
      else:
        raise_parse_error(child_, 'requires boolean')
      ival_ = self.gds_validate_boolean(ival_, node, 'Current')
      self.Current = ival_
    elif nodeName_ == 'Value':
      Value_ = child_.text
      Value_ = self.gds_validate_string(Value_, node, 'Value')
      self.Value.append(Value_)
    super(Dimension, self).buildChildren(child_, node, nodeName_, True)
# end class Dimension


class LegendURL(OnlineResourceType):
  """Zero or more LegendURL elements may be provided, providing an
  image(s) of a legend relevant to each Style of a Layer. The
  Format element indicates the MIME type of the legend.
  minScaleDenominator and maxScaleDenominator attributes may be
  provided to indicate to the client which scale(s) (inclusive)
  the legend image is appropriate for. (If provided, these values
  must exactly match the scale denominators of available
  TileMatrixes.) width and height attributes may be provided to
  assist client applications in laying out space to display the
  legend. The URL from which the legend image can be retrievedA
  supported output format for the legend imageDenominator of the
  minimum scale (inclusive) for which this legend image is
  validDenominator of the maximum scale (exclusive) for which this
  legend image is validWidth (in pixels) of the legend imageHeight
  (in pixels) of the legend image"""
  subclass = None
  superclass = OnlineResourceType
  def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None, height=None, minScaleDenominator=None, maxScaleDenominator=None, width=None, format=None, valueOf_=None):
    super(LegendURL, self).__init__(title, arcrole, actuate, href, role, show, type_, valueOf_, )
    self.height = _cast(int, height)
    self.minScaleDenominator = _cast(float, minScaleDenominator)
    self.maxScaleDenominator = _cast(float, maxScaleDenominator)
    self.width = _cast(int, width)
    self.format = _cast(None, format)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if LegendURL.subclass:
      return LegendURL.subclass(*args_, **kwargs_)
    else:
      return LegendURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_height(self): return self.height
  def set_height(self, height): self.height = height
  def get_minScaleDenominator(self): return self.minScaleDenominator
  def set_minScaleDenominator(self, minScaleDenominator): self.minScaleDenominator = minScaleDenominator
  def get_maxScaleDenominator(self): return self.maxScaleDenominator
  def set_maxScaleDenominator(self, maxScaleDenominator): self.maxScaleDenominator = maxScaleDenominator
  def get_width(self): return self.width
  def set_width(self, width): self.width = width
  def get_format(self): return self.format
  def set_format(self, format): self.format = format
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='LegendURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='LegendURL')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="LegendURL"')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegendURL'):
    super(LegendURL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LegendURL')
    if self.height is not None and 'height' not in already_processed:
      already_processed.append('height')
      outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
    if self.minScaleDenominator is not None and 'minScaleDenominator' not in already_processed:
      already_processed.append('minScaleDenominator')
      outfile.write(' minScaleDenominator="%s"' % self.gds_format_double(self.minScaleDenominator, input_name='minScaleDenominator'))
    if self.maxScaleDenominator is not None and 'maxScaleDenominator' not in already_processed:
      already_processed.append('maxScaleDenominator')
      outfile.write(' maxScaleDenominator="%s"' % self.gds_format_double(self.maxScaleDenominator, input_name='maxScaleDenominator'))
    if self.width is not None and 'width' not in already_processed:
      already_processed.append('width')
      outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
    if self.format is not None and 'format' not in already_processed:
      already_processed.append('format')
      outfile.write(' format=%s' % (quote_attrib(self.format), ))
  def exportChildren(self, outfile, level, namespace_='', name_='LegendURL', fromsubclass_=False):
    super(LegendURL, self).exportChildren(outfile, level, namespace_, name_, True)
    pass
  def hasContent_(self):
    if (
        self.valueOf_ or
        super(LegendURL, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='LegendURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.height is not None and 'height' not in already_processed:
      already_processed.append('height')
      showIndent(outfile, level)
      outfile.write('height = %d,\n' % (self.height,))
    if self.minScaleDenominator is not None and 'minScaleDenominator' not in already_processed:
      already_processed.append('minScaleDenominator')
      showIndent(outfile, level)
      outfile.write('minScaleDenominator = %e,\n' % (self.minScaleDenominator,))
    if self.maxScaleDenominator is not None and 'maxScaleDenominator' not in already_processed:
      already_processed.append('maxScaleDenominator')
      showIndent(outfile, level)
      outfile.write('maxScaleDenominator = %e,\n' % (self.maxScaleDenominator,))
    if self.width is not None and 'width' not in already_processed:
      already_processed.append('width')
      showIndent(outfile, level)
      outfile.write('width = %d,\n' % (self.width,))
    if self.format is not None and 'format' not in already_processed:
      already_processed.append('format')
      showIndent(outfile, level)
      outfile.write('format = %s,\n' % (self.format,))
    super(LegendURL, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(LegendURL, self).exportLiteralChildren(outfile, level, name_)
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('height', node)
    if value is not None and 'height' not in already_processed:
      already_processed.append('height')
      try:
        self.height = int(value)
      except ValueError, exp:
        raise_parse_error(node, 'Bad integer attribute: %s' % exp)
      if self.height <= 0:
        raise_parse_error(node, 'Invalid PositiveInteger')
    value = find_attr_value_('minScaleDenominator', node)
    if value is not None and 'minScaleDenominator' not in already_processed:
      already_processed.append('minScaleDenominator')
      try:
        self.minScaleDenominator = float(value)
      except ValueError, exp:
        raise ValueError('Bad float/double attribute (minScaleDenominator): %s' % exp)
    value = find_attr_value_('maxScaleDenominator', node)
    if value is not None and 'maxScaleDenominator' not in already_processed:
      already_processed.append('maxScaleDenominator')
      try:
        self.maxScaleDenominator = float(value)
      except ValueError, exp:
        raise ValueError('Bad float/double attribute (maxScaleDenominator): %s' % exp)
    value = find_attr_value_('width', node)
    if value is not None and 'width' not in already_processed:
      already_processed.append('width')
      try:
        self.width = int(value)
      except ValueError, exp:
        raise_parse_error(node, 'Bad integer attribute: %s' % exp)
      if self.width <= 0:
        raise_parse_error(node, 'Invalid PositiveInteger')
    value = find_attr_value_('format', node)
    if value is not None and 'format' not in already_processed:
      already_processed.append('format')
      self.format = value
    super(LegendURL, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    super(LegendURL, self).buildChildren(child_, node, nodeName_, True)
    pass
# end class LegendURL


class Style(DescriptionType):
  """This style is used when no style is specified"""
  subclass = None
  superclass = DescriptionType
  def __init__(self, Title=None, Abstract=None, Keywords=None, isDefault=None, Identifier=None, LegendURL=None):
    super(Style, self).__init__(Title, Abstract, Keywords, )
    self.isDefault = _cast(bool, isDefault)
    self.Identifier = Identifier
    if LegendURL is None:
      self.LegendURL = []
    else:
      self.LegendURL = LegendURL
  def factory(*args_, **kwargs_):
    if Style.subclass:
      return Style.subclass(*args_, **kwargs_)
    else:
      return Style(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def get_LegendURL(self): return self.LegendURL
  def set_LegendURL(self, LegendURL): self.LegendURL = LegendURL
  def add_LegendURL(self, value): self.LegendURL.append(value)
  def insert_LegendURL(self, index, value): self.LegendURL[index] = value
  def get_isDefault(self): return self.isDefault
  def set_isDefault(self, isDefault): self.isDefault = isDefault
  def export(self, outfile, level, namespace_='', name_='Style', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Style')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="Style"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Style'):
    super(Style, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Style')
    if self.isDefault is not None and 'isDefault' not in already_processed:
      already_processed.append('isDefault')
      outfile.write(' isDefault="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.isDefault)), input_name='isDefault'))
  def exportChildren(self, outfile, level, namespace_='', name_='Style', fromsubclass_=False):
    super(Style, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Identifier:
      self.Identifier.export(outfile, level, namespace_, name_='Identifier', )
    for LegendURL_ in self.LegendURL:
      LegendURL_.export(outfile, level, namespace_, name_='LegendURL')
  def hasContent_(self):
    if (
        self.Identifier is not None or
        self.LegendURL or
        super(Style, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Style'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.isDefault is not None and 'isDefault' not in already_processed:
      already_processed.append('isDefault')
      showIndent(outfile, level)
      outfile.write('isDefault = %s,\n' % (self.isDefault,))
    super(Style, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(Style, self).exportLiteralChildren(outfile, level, name_)
    if self.Identifier is not None:
      showIndent(outfile, level)
      outfile.write('Identifier=model_.Identifier(\n')
      self.Identifier.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('LegendURL=[\n')
    level += 1
    for LegendURL_ in self.LegendURL:
      showIndent(outfile, level)
      outfile.write('model_.LegendURL(\n')
      LegendURL_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('isDefault', node)
    if value is not None and 'isDefault' not in already_processed:
      already_processed.append('isDefault')
      if value in ('true', '1'):
        self.isDefault = True
      elif value in ('false', '0'):
        self.isDefault = False
      else:
        raise_parse_error(node, 'Bad boolean attribute')
    super(Style, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Identifier':
      obj_ = CodeType.factory()
      obj_.build(child_)
      self.set_Identifier(obj_)
    elif nodeName_ == 'LegendURL':
      obj_ = LegendURL.factory()
      obj_.build(child_)
      self.LegendURL.append(obj_)
    super(Style, self).buildChildren(child_, node, nodeName_, True)
# end class Style


class LayerType(DatasetDescriptionSummaryBaseType):
  subclass = None
  superclass = DatasetDescriptionSummaryBaseType
  def __init__(self, Title=None, Abstract=None, Keywords=None, WGS84BoundingBox=None, Identifier=None, BoundingBox=None, Metadata=None, DatasetDescriptionSummary=None, Style=None, Format=None, InfoFormat=None, Dimension=None, TileMatrixSetLink=None, ResourceURL=None):
    super(LayerType, self).__init__(Title, Abstract, Keywords, WGS84BoundingBox, Identifier, BoundingBox, Metadata, DatasetDescriptionSummary, )
    if Style is None:
      self.Style = []
    else:
      self.Style = Style
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if InfoFormat is None:
      self.InfoFormat = []
    else:
      self.InfoFormat = InfoFormat
    if Dimension is None:
      self.Dimension = []
    else:
      self.Dimension = Dimension
    if TileMatrixSetLink is None:
      self.TileMatrixSetLink = []
    else:
      self.TileMatrixSetLink = TileMatrixSetLink
    if ResourceURL is None:
      self.ResourceURL = []
    else:
      self.ResourceURL = ResourceURL
  def factory(*args_, **kwargs_):
    if LayerType.subclass:
      return LayerType.subclass(*args_, **kwargs_)
    else:
      return LayerType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Style(self): return self.Style
  def set_Style(self, Style): self.Style = Style
  def add_Style(self, value): self.Style.append(value)
  def insert_Style(self, index, value): self.Style[index] = value
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def validate_MimeType(self, value):
    # Validate type MimeType, a restriction on string.
    pass
  def get_InfoFormat(self): return self.InfoFormat
  def set_InfoFormat(self, InfoFormat): self.InfoFormat = InfoFormat
  def add_InfoFormat(self, value): self.InfoFormat.append(value)
  def insert_InfoFormat(self, index, value): self.InfoFormat[index] = value
  def get_Dimension(self): return self.Dimension
  def set_Dimension(self, Dimension): self.Dimension = Dimension
  def add_Dimension(self, value): self.Dimension.append(value)
  def insert_Dimension(self, index, value): self.Dimension[index] = value
  def get_TileMatrixSetLink(self): return self.TileMatrixSetLink
  def set_TileMatrixSetLink(self, TileMatrixSetLink): self.TileMatrixSetLink = TileMatrixSetLink
  def add_TileMatrixSetLink(self, value): self.TileMatrixSetLink.append(value)
  def insert_TileMatrixSetLink(self, index, value): self.TileMatrixSetLink[index] = value
  def get_ResourceURL(self): return self.ResourceURL
  def set_ResourceURL(self, ResourceURL): self.ResourceURL = ResourceURL
  def add_ResourceURL(self, value): self.ResourceURL.append(value)
  def insert_ResourceURL(self, index, value): self.ResourceURL[index] = value
  def export(self, outfile, level, namespace_='', name_='LayerType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='LayerType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="LayerType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LayerType'):
    super(LayerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LayerType')
  def exportChildren(self, outfile, level, namespace_='', name_='LayerType', fromsubclass_=False):
    super(LayerType, self).exportChildren(outfile, level, namespace_, name_, True)
    for Style_ in self.Style:
      Style_.export(outfile, level, namespace_, name_='Style')
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('<%sFormat>%s</%sFormat>\n' % (namespace_, self.gds_format_string(quote_xml(Format_).encode(ExternalEncoding), input_name='Format'), namespace_))
    for InfoFormat_ in self.InfoFormat:
      showIndent(outfile, level)
      outfile.write('<%sInfoFormat>%s</%sInfoFormat>\n' % (namespace_, self.gds_format_string(quote_xml(InfoFormat_).encode(ExternalEncoding), input_name='InfoFormat'), namespace_))
    for Dimension_ in self.Dimension:
      Dimension_.export(outfile, level, namespace_, name_='Dimension')
    for TileMatrixSetLink_ in self.TileMatrixSetLink:
      TileMatrixSetLink_.export(outfile, level, namespace_, name_='TileMatrixSetLink')
    for ResourceURL_ in self.ResourceURL:
      ResourceURL_.export(outfile, level, namespace_, name_='ResourceURL')
  def hasContent_(self):
    if (
        self.Style or
        self.Format or
        self.InfoFormat or
        self.Dimension or
        self.TileMatrixSetLink or
        self.ResourceURL or
        super(LayerType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='LayerType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(LayerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(LayerType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('Style=[\n')
    level += 1
    for Style_ in self.Style:
      showIndent(outfile, level)
      outfile.write('model_.Style(\n')
      Style_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(Format_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('InfoFormat=[\n')
    level += 1
    for InfoFormat_ in self.InfoFormat:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(InfoFormat_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Dimension=[\n')
    level += 1
    for Dimension_ in self.Dimension:
      showIndent(outfile, level)
      outfile.write('model_.Dimension(\n')
      Dimension_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('TileMatrixSetLink=[\n')
    level += 1
    for TileMatrixSetLink_ in self.TileMatrixSetLink:
      showIndent(outfile, level)
      outfile.write('model_.TileMatrixSetLink(\n')
      TileMatrixSetLink_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('ResourceURL=[\n')
    level += 1
    for ResourceURL_ in self.ResourceURL:
      showIndent(outfile, level)
      outfile.write('model_.URLTemplateType(\n')
      ResourceURL_.exportLiteral(outfile, level, name_='URLTemplateType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(LayerType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Style':
      obj_ = Style.factory()
      obj_.build(child_)
      self.Style.append(obj_)
    elif nodeName_ == 'Format':
      Format_ = child_.text
      Format_ = self.gds_validate_string(Format_, node, 'Format')
      self.Format.append(Format_)
      self.validate_MimeType(self.Format)    # validate type MimeType
    elif nodeName_ == 'InfoFormat':
      InfoFormat_ = child_.text
      InfoFormat_ = self.gds_validate_string(InfoFormat_, node, 'InfoFormat')
      self.InfoFormat.append(InfoFormat_)
      self.validate_MimeType(self.InfoFormat)    # validate type MimeType
    elif nodeName_ == 'Dimension':
      obj_ = Dimension.factory()
      obj_.build(child_)
      self.Dimension.append(obj_)
    elif nodeName_ == 'TileMatrixSetLink':
      obj_ = TileMatrixSetLink.factory()
      obj_.build(child_)
      self.TileMatrixSetLink.append(obj_)
    elif nodeName_ == 'ResourceURL':
      obj_ = URLTemplateType.factory()
      obj_.build(child_)
      self.ResourceURL.append(obj_)
    super(LayerType, self).buildChildren(child_, node, nodeName_, True)
# end class LayerType


class ContentsType(ContentsBaseType):
  subclass = None
  superclass = ContentsBaseType
  def __init__(self, DatasetDescriptionSummary=None, OtherSource=None, TileMatrixSet=None):
    super(ContentsType, self).__init__(DatasetDescriptionSummary, OtherSource, )
    if TileMatrixSet is None:
      self.TileMatrixSet = []
    else:
      self.TileMatrixSet = TileMatrixSet
  def factory(*args_, **kwargs_):
    if ContentsType.subclass:
      return ContentsType.subclass(*args_, **kwargs_)
    else:
      return ContentsType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_TileMatrixSet(self): return self.TileMatrixSet
  def set_TileMatrixSet(self, TileMatrixSet): self.TileMatrixSet = TileMatrixSet
  def add_TileMatrixSet(self, value): self.TileMatrixSet.append(value)
  def insert_TileMatrixSet(self, index, value): self.TileMatrixSet[index] = value
  def export(self, outfile, level, namespace_='', name_='ContentsType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContentsType')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    # outfile.write(' xsi:type="ContentsType"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContentsType'):
    super(ContentsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContentsType')
  def exportChildren(self, outfile, level, namespace_='', name_='ContentsType', fromsubclass_=False):
    super(ContentsType, self).exportChildren(outfile, level, namespace_, name_, True)
    for TileMatrixSet_ in self.TileMatrixSet:
      TileMatrixSet_.export(outfile, level, namespace_, name_='TileMatrixSet')
  def hasContent_(self):
    if (
        self.TileMatrixSet or
        super(ContentsType, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContentsType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(ContentsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(ContentsType, self).exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('TileMatrixSet=[\n')
    level += 1
    for TileMatrixSet_ in self.TileMatrixSet:
      showIndent(outfile, level)
      outfile.write('model_.TileMatrixSet(\n')
      TileMatrixSet_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(ContentsType, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'TileMatrixSet':
      obj_ = TileMatrixSet.factory()
      obj_.build(child_)
      self.TileMatrixSet.append(obj_)
    super(ContentsType, self).buildChildren(child_, node, nodeName_, True)
# end class ContentsType


class Capabilities(CapabilitiesBaseType):
  """XML defines the WMTS GetCapabilities operation response.
  ServiceMetadata document provides clients with service metadata
  about a specific service instance, including metadata about the
  tightly-coupled data served. If the server does not implement
  the updateSequence parameter, the server SHALL always return the
  complete Capabilities document, without the updateSequence
  parameter. When the server implements the updateSequence
  parameter and the GetCapabilities operation request included the
  updateSequence parameter with the current value, the server
  SHALL return this element with only the "version" and
  "updateSequence" attributes. Otherwise, all optional elements
  SHALL be included or not depending on the actual value of the
  Contents parameter in the GetCapabilities operation request."""
  subclass = None
  superclass = CapabilitiesBaseType
  def __init__(self, updateSequence=None, version=None, ServiceIdentification=None, ServiceProvider=None, OperationsMetadata=None, Contents=None, Themes=None, WSDL=None, ServiceMetadataURL=None):
    super(Capabilities, self).__init__(updateSequence, version, ServiceIdentification, ServiceProvider, OperationsMetadata, )
    self.Contents = Contents
    if Themes is None:
      self.Themes = []
    else:
      self.Themes = Themes
    if WSDL is None:
      self.WSDL = []
    else:
      self.WSDL = WSDL
    if ServiceMetadataURL is None:
      self.ServiceMetadataURL = []
    else:
      self.ServiceMetadataURL = ServiceMetadataURL
  def factory(*args_, **kwargs_):
    if Capabilities.subclass:
      return Capabilities.subclass(*args_, **kwargs_)
    else:
      return Capabilities(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Contents(self): return self.Contents
  def set_Contents(self, Contents): self.Contents = Contents
  def get_Themes(self): return self.Themes
  def set_Themes(self, Themes): self.Themes = Themes
  def add_Themes(self, value): self.Themes.append(value)
  def insert_Themes(self, index, value): self.Themes[index] = value
  def get_WSDL(self): return self.WSDL
  def set_WSDL(self, WSDL): self.WSDL = WSDL
  def add_WSDL(self, value): self.WSDL.append(value)
  def insert_WSDL(self, index, value): self.WSDL[index] = value
  def get_ServiceMetadataURL(self): return self.ServiceMetadataURL
  def set_ServiceMetadataURL(self, ServiceMetadataURL): self.ServiceMetadataURL = ServiceMetadataURL
  def add_ServiceMetadataURL(self, value): self.ServiceMetadataURL.append(value)
  def insert_ServiceMetadataURL(self, index, value): self.ServiceMetadataURL[index] = value
  def export(self, outfile, level, namespace_='', name_='Capabilities', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Capabilities')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    outfile.write(' xmlns="http://www.opengis.net/wmts/1.0"')
    outfile.write(' xmlns:ows="http://www.opengis.net/ows/1.1"')
    outfile.write(' xmlns:xlink="http://www.w3.org/1999/xlink"')
    outfile.write(' xmlns:gml="http://www.opengis.net/gml"')
    outfile.write(' xsi:schemaLocation="http://www.opengis.net/wmts/1.0 http://schemas.opengis.net/wmts/1.0/wmtsGetCapabilities_response.xsd"')
    # outfile.write(' xsi:type="Capabilities"')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Capabilities'):
    super(Capabilities, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Capabilities')
  def exportChildren(self, outfile, level, namespace_='', name_='Capabilities', fromsubclass_=False):
    super(Capabilities, self).exportChildren(outfile, level, namespace_, name_, True)
    if self.Contents:
      self.Contents.export(outfile, level, namespace_, name_='Contents')
    for Themes_ in self.Themes:
      Themes_.export(outfile, level, namespace_, name_='Themes')
    for WSDL_ in self.WSDL:
      WSDL_.export(outfile, level, namespace_, name_='WSDL')
    for ServiceMetadataURL_ in self.ServiceMetadataURL:
      ServiceMetadataURL_.export(outfile, level, namespace_, name_='ServiceMetadataURL')
  def hasContent_(self):
    if (
        self.Contents is not None or
        self.Themes or
        self.WSDL or
        self.ServiceMetadataURL or
        super(Capabilities, self).hasContent_()
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Capabilities'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    super(Capabilities, self).exportLiteralAttributes(outfile, level, already_processed, name_)
  def exportLiteralChildren(self, outfile, level, name_):
    super(Capabilities, self).exportLiteralChildren(outfile, level, name_)
    if self.Contents is not None:
      showIndent(outfile, level)
      outfile.write('Contents=model_.ContentsType(\n')
      self.Contents.exportLiteral(outfile, level, name_='Contents')
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('Themes=[\n')
    level += 1
    for Themes_ in self.Themes:
      showIndent(outfile, level)
      outfile.write('model_.Themes(\n')
      Themes_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('WSDL=[\n')
    level += 1
    for WSDL_ in self.WSDL:
      showIndent(outfile, level)
      outfile.write('model_.OnlineResourceType(\n')
      WSDL_.exportLiteral(outfile, level, name_='OnlineResourceType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('ServiceMetadataURL=[\n')
    level += 1
    for ServiceMetadataURL_ in self.ServiceMetadataURL:
      showIndent(outfile, level)
      outfile.write('model_.OnlineResourceType(\n')
      ServiceMetadataURL_.exportLiteral(outfile, level, name_='OnlineResourceType')
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    super(Capabilities, self).buildAttributes(node, attrs, already_processed)
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Contents':
      obj_ = ContentsType.factory()
      obj_.build(child_)
      self.set_Contents(obj_)
    elif nodeName_ == 'Themes':
      obj_ = Themes.factory()
      obj_.build(child_)
      self.Themes.append(obj_)
    elif nodeName_ == 'WSDL':
      obj_ = OnlineResourceType.factory()
      obj_.build(child_)
      self.WSDL.append(obj_)
    elif nodeName_ == 'ServiceMetadataURL':
      obj_ = OnlineResourceType.factory()
      obj_.build(child_)
      self.ServiceMetadataURL.append(obj_)
    super(Capabilities, self).buildChildren(child_, node, nodeName_, True)
# end class Capabilities


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
  print USAGE_TEXT
  sys.exit(1)


def get_root_tag(node):
  tag = Tag_pattern_.match(node.tag).groups()[-1]
  rootClass = globals().get(tag)
  return tag, rootClass


def parse(inFileName):
  doc = parsexml_(inFileName)
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'Capabilities'
    rootClass = Capabilities
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('<?xml version="1.0" ?>\n')
  rootObj.export(sys.stdout, 0, name_=rootTag,
      namespacedef_='')
  return rootObj


def parseString(inString):
  from StringIO import StringIO
  doc = parsexml_(StringIO(inString))
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'Capabilities'
    rootClass = Capabilities
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('<?xml version="1.0" ?>\n')
  rootObj.export(sys.stdout, 0, name_="Capabilities",
      namespacedef_='')
  return rootObj


def parseLiteral(inFileName):
  doc = parsexml_(inFileName)
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'Capabilities'
    rootClass = Capabilities
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('#from capabilities import *\n\n')
  sys.stdout.write('import capabilities as model_\n\n')
  sys.stdout.write('rootObj = model_.rootTag(\n')
  rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
  sys.stdout.write(')\n')
  return rootObj


def main():
  args = sys.argv[1:]
  if len(args) == 1:
    parse(args[0])
  else:
    usage()


if __name__ == '__main__':
  #import pdb; pdb.set_trace()
  main()


__all__ = [
    "AbstractMetaData",
    "AbstractReferenceBaseType",
    "AcceptFormatsType",
    "AcceptVersionsType",
    "AddressType",
    "AllowedValues",
    "AnyValue",
    "BasicIdentificationType",
    "BoundingBoxType",
    "Capabilities",
    "CapabilitiesBaseType",
    "CodeType",
    "ContactType",
    "ContentsBaseType",
    "ContentsType",
    "DCP",
    "DatasetDescriptionSummaryBaseType",
    "DescriptionType",
    "Dimension",
    "DomainMetadataType",
    "DomainType",
    "ExceptionReport",
    "ExceptionType",
    "GetCapabilitiesType",
    "GetResourceByIdType",
    "HTTP",
    "IdentificationType",
    "KeywordsType",
    "LanguageStringType",
    "LayerType",
    "LegendURL",
    "ManifestType",
    "MetadataType",
    "NoValues",
    "OnlineResourceType",
    "Operation",
    "OperationsMetadata",
    "RangeType",
    "ReferenceGroupType",
    "ReferenceType",
    "RequestMethodType",
    "Resource",
    "ResponsiblePartySubsetType",
    "ResponsiblePartyType",
    "SectionsType",
    "ServiceIdentification",
    "ServiceProvider",
    "ServiceReferenceType",
    "Style",
    "TelephoneType",
    "Theme",
    "Themes",
    "TileMatrix",
    "TileMatrixLimits",
    "TileMatrixSet",
    "TileMatrixSetLimits",
    "TileMatrixSetLink",
    "URLTemplateType",
    "UnNamedDomainType",
    "ValueType",
    "ValuesReference",
    "WGS84BoundingBoxType"
    ]
