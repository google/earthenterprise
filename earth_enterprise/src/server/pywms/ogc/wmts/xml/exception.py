#!/usr/bin/env python
#
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# -*- coding: utf-8 -*-

#
# Generated Wed Aug 31 14:17:08 2011 by generateDS.py version 2.5a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
  # lxml
  from lxml import etree as etree_
  XMLParser_import_library = XMLParser_import_lxml
  if Verbose_import_:
    print("running with lxml.etree")
except ImportError:
  try:
    # cElementTree from Python 2.5+
    import xml.etree.cElementTree as etree_
    XMLParser_import_library = XMLParser_import_elementtree
    if Verbose_import_:
      print("running with cElementTree on Python 2.5+")
  except ImportError:
    try:
      # ElementTree from Python 2.5+
      import xml.etree.ElementTree as etree_
      XMLParser_import_library = XMLParser_import_elementtree
      if Verbose_import_:
        print("running with ElementTree on Python 2.5+")
    except ImportError:
      try:
        # normal cElementTree install
        import cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
          print("running with cElementTree")
      except ImportError:
        try:
          # normal ElementTree install
          import elementtree.ElementTree as etree_
          XMLParser_import_library = XMLParser_import_elementtree
          if Verbose_import_:
            print("running with ElementTree")
        except ImportError:
          raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
  if (XMLParser_import_library == XMLParser_import_lxml and
      'parser' not in kwargs):
    # Use the lxml ElementTree compatible parser so that, e.g.,
    #   we ignore comments.
    kwargs['parser'] = etree_.ETCompatXMLParser()
  doc = etree_.parse(*args, **kwargs)
  return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
  from generatedssuper import GeneratedsSuper
except ImportError, exp:

  class GeneratedsSuper(object):
    def gds_format_string(self, input_data, input_name=''):
      return input_data
    def gds_validate_string(self, input_data, node, input_name=''):
      return input_data
    def gds_format_integer(self, input_data, input_name=''):
      return '%d' % input_data
    def gds_validate_integer(self, input_data, node, input_name=''):
      return input_data
    def gds_format_integer_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_integer_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of integers')
      return input_data
    def gds_format_float(self, input_data, input_name=''):
      return '%f' % input_data
    def gds_validate_float(self, input_data, node, input_name=''):
      return input_data
    def gds_format_float_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_float_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of floats')
      return input_data
    def gds_format_double(self, input_data, input_name=''):
      return '%e' % input_data
    def gds_validate_double(self, input_data, node, input_name=''):
      return input_data
    def gds_format_double_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_double_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of doubles')
      return input_data
    def gds_format_boolean(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_boolean(self, input_data, node, input_name=''):
      return input_data
    def gds_format_boolean_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_boolean_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        if value not in ('true', '1', 'false', '0', ):
          raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
      return input_data
    def gds_str_lower(self, instring):
      return instring.lower()
    def get_path_(self, node):
      path_list = []
      self.get_path_list_(node, path_list)
      path_list.reverse()
      path = '/'.join(path_list)
      return path
    Tag_strip_pattern_ = re_.compile(r'\{.*\}')
    def get_path_list_(self, node, path_list):
      if node is None:
        return
      tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
      if tag:
        path_list.append(tag)
      self.get_path_list_(node.getparent(), path_list)


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
  for idx in range(level):
    outfile.write('    ')

def quote_xml(inStr):
  if not inStr:
    return ''
  s1 = (isinstance(inStr, basestring) and inStr or
        '%s' % inStr)
  s1 = s1.replace('&', '&amp;')
  s1 = s1.replace('<', '&lt;')
  s1 = s1.replace('>', '&gt;')
  return s1

def quote_attrib(inStr):
  s1 = (isinstance(inStr, basestring) and inStr or
        '%s' % inStr)
  s1 = s1.replace('&', '&amp;')
  s1 = s1.replace('<', '&lt;')
  s1 = s1.replace('>', '&gt;')
  if '"' in s1:
    if "'" in s1:
      s1 = '"%s"' % s1.replace('"', "&quot;")
    else:
      s1 = "'%s'" % s1
  else:
    s1 = '"%s"' % s1
  return s1

def quote_python(inStr):
  s1 = inStr
  if s1.find("'") == -1:
    if s1.find('\n') == -1:
      return "'%s'" % s1
    else:
      return "'''%s'''" % s1
  else:
    if s1.find('"') != -1:
      s1 = s1.replace('"', '\\"')
    if s1.find('\n') == -1:
      return '"%s"' % s1
    else:
      return '"""%s"""' % s1

def get_all_text_(node):
  if node.text is not None:
    text = node.text
  else:
    text = ''
  for child in node:
    if child.tail is not None:
      text += child.tail
  return text

def find_attr_value_(attr_name, node):
  attrs = node.attrib
  # First try with no namespace.
  value = attrs.get(attr_name)
  if value is None:
    # Now try the other possible namespaces.
    namespaces = node.nsmap.itervalues()
    for namespace in namespaces:
      value = attrs.get('{%s}%s' % (namespace, attr_name, ))
      if value is not None:
        break
  return value


class GDSParseError(Exception):
  pass

def raise_parse_error(node, msg):
  if XMLParser_import_library == XMLParser_import_lxml:
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
  else:
    msg = '%s (element %s)' % (msg, node.tag, )
  raise GDSParseError(msg)


class MixedContainer:
  # Constants for category:
  CategoryNone = 0
  CategoryText = 1
  CategorySimple = 2
  CategoryComplex = 3
  # Constants for content_type:
  TypeNone = 0
  TypeText = 1
  TypeString = 2
  TypeInteger = 3
  TypeFloat = 4
  TypeDecimal = 5
  TypeDouble = 6
  TypeBoolean = 7
  def __init__(self, category, content_type, name, value):
    self.category = category
    self.content_type = content_type
    self.name = name
    self.value = value
  def getCategory(self):
    return self.category
  def getContenttype(self, content_type):
    return self.content_type
  def getValue(self):
    return self.value
  def getName(self):
    return self.name
  def export(self, outfile, level, name, namespace):
    if self.category == MixedContainer.CategoryText:
      # Prevent exporting empty content as empty lines.
      if self.value.strip():
        outfile.write(self.value)
    elif self.category == MixedContainer.CategorySimple:
      self.exportSimple(outfile, level, name)
    else:    # category == MixedContainer.CategoryComplex
      self.value.export(outfile, level, namespace,name)
  def exportSimple(self, outfile, level, name):
    if self.content_type == MixedContainer.TypeString:
      outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeInteger or \
            self.content_type == MixedContainer.TypeBoolean:
      outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeFloat or \
            self.content_type == MixedContainer.TypeDecimal:
      outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeDouble:
      outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
  def exportLiteral(self, outfile, level, name):
    if self.category == MixedContainer.CategoryText:
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
          (self.category, self.content_type, self.name, self.value))
    elif self.category == MixedContainer.CategorySimple:
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
          (self.category, self.content_type, self.name, self.value))
    else:    # category == MixedContainer.CategoryComplex
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
          (self.category, self.content_type, self.name,))
      self.value.exportLiteral(outfile, level + 1)
      showIndent(outfile, level)
      outfile.write(')\n')


class MemberSpec_(object):
  def __init__(self, name='', data_type='', container=0):
    self.name = name
    self.data_type = data_type
    self.container = container
  def set_name(self, name): self.name = name
  def get_name(self): return self.name
  def set_data_type(self, data_type): self.data_type = data_type
  def get_data_type_chain(self): return self.data_type
  def get_data_type(self):
    if isinstance(self.data_type, list):
      if len(self.data_type) > 0:
        return self.data_type[-1]
      else:
        return 'xs:string'
    else:
      return self.data_type
  def set_container(self, container): self.container = container
  def get_container(self): return self.container

def _cast(typ, value):
  if typ is None or value is None:
    return value
  return typ(value)

#
# Data representation classes.
#

class ExceptionReport(GeneratedsSuper):
  """Report message returned to the client that requested any OWS
  operation when the server detects an error while processing that
  operation request. Specification version for OWS operation. The
  string value shall contain one x.y.z "version" value (e.g.,
  "2.1.3"). A version number shall contain three non-negative
  integers separated by decimal points, in the form "x.y.z". The
  integers y and z shall not exceed 99. Each version shall be for
  the Implementation Specification (document) and the associated
  XML Schemas to which requested operations will conform. An
  Implementation Specification version normally specifies XML
  Schemas against which an XML encoded operation response must
  conform and should be validated. See Version negotiation
  subclause for more information. Identifier of the language used
  by all included exception text values. These language
  identifiers shall be as specified in IETF RFC 4646. When this
  attribute is omitted, the language used is not identified."""
  subclass = None
  superclass = None
  def __init__(self, lang=None, version=None, Exception=None):
    self.lang = _cast(None, lang)
    self.version = _cast(None, version)
    if Exception is None:
      self.Exception = []
    else:
      self.Exception = Exception
  def factory(*args_, **kwargs_):
    if ExceptionReport.subclass:
      return ExceptionReport.subclass(*args_, **kwargs_)
    else:
      return ExceptionReport(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Exception(self): return self.Exception
  def set_Exception(self, Exception): self.Exception = Exception
  def add_Exception(self, value): self.Exception.append(value)
  def insert_Exception(self, index, value): self.Exception[index] = value
  def get_lang(self): return self.lang
  def set_lang(self, lang): self.lang = lang
  def get_version(self): return self.version
  def set_version(self, version): self.version = version
  def export(self, outfile, level, namespace_='', name_='ExceptionReport', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ExceptionReport')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExceptionReport'):
    outfile.write(' xmlns="http://www.opengis.net/ows/1.1"')
    outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
    outfile.write(' xsi:schemaLocation="http://www.opengis.net/ows/1.1 owsExceptionReport.xsd"')
    if self.lang is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='ExceptionReport', fromsubclass_=False):
    for Exception_ in self.Exception:
      Exception_.export(outfile, level, namespace_, name_='Exception')
  def hasContent_(self):
    if (
        self.Exception
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ExceptionReport'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.lang is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      showIndent(outfile, level)
      outfile.write('lang = "%s",\n' % (self.lang,))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      showIndent(outfile, level)
      outfile.write('version = "%s",\n' % (self.version,))
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Exception=[\n')
    level += 1
    for Exception_ in self.Exception:
      showIndent(outfile, level)
      outfile.write('model_.Exception(\n')
      Exception_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('lang', node)
    if value is not None and 'lang' not in already_processed:
      already_processed.append('lang')
      self.lang = value
    value = find_attr_value_('version', node)
    if value is not None and 'version' not in already_processed:
      already_processed.append('version')
      self.version = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Exception':
      obj_ = ExceptionType.factory()
      obj_.build(child_)
      self.Exception.append(obj_)
# end class ExceptionReport


class ExceptionType(GeneratedsSuper):
  """An Exception element describes one detected error that a server
  chooses to convey to the client. A code representing the type of
  this exception, which shall be selected from a set of
  exceptionCode values specified for the specific service
  operation and server. When included, this locator shall indicate
  to the client where an exception was encountered in servicing
  the client's operation request. This locator should be included
  whenever meaningful information can be provided by the server.
  The contents of this locator will depend on the specific
  exceptionCode and OWS service, and shall be specified in the OWS
  Implementation Specification."""
  subclass = None
  superclass = None
  def __init__(self, locator=None, exceptionCode=None, ExceptionText=None):
    self.locator = _cast(None, locator)
    self.exceptionCode = _cast(None, exceptionCode)
    if ExceptionText is None:
      self.ExceptionText = []
    else:
      self.ExceptionText = ExceptionText
  def factory(*args_, **kwargs_):
    if ExceptionType.subclass:
      return ExceptionType.subclass(*args_, **kwargs_)
    else:
      return ExceptionType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ExceptionText(self): return self.ExceptionText
  def set_ExceptionText(self, ExceptionText): self.ExceptionText = ExceptionText
  def add_ExceptionText(self, value): self.ExceptionText.append(value)
  def insert_ExceptionText(self, index, value): self.ExceptionText[index] = value
  def get_locator(self): return self.locator
  def set_locator(self, locator): self.locator = locator
  def get_exceptionCode(self): return self.exceptionCode
  def set_exceptionCode(self, exceptionCode): self.exceptionCode = exceptionCode
  def export(self, outfile, level, namespace_='', name_='ExceptionType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ExceptionType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExceptionType'):
    if self.locator is not None and 'locator' not in already_processed:
      already_processed.append('locator')
      outfile.write(' locator=%s' % (self.gds_format_string(quote_attrib(self.locator).encode(ExternalEncoding), input_name='locator'), ))
    if self.exceptionCode is not None and 'exceptionCode' not in already_processed:
      already_processed.append('exceptionCode')
      outfile.write(' exceptionCode=%s' % (self.gds_format_string(quote_attrib(self.exceptionCode).encode(ExternalEncoding), input_name='exceptionCode'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='ExceptionType', fromsubclass_=False):
    for ExceptionText_ in self.ExceptionText:
      showIndent(outfile, level)
      outfile.write('<%sExceptionText>%s</%sExceptionText>\n' % (namespace_, self.gds_format_string(quote_xml(ExceptionText_).encode(ExternalEncoding), input_name='ExceptionText'), namespace_))
  def hasContent_(self):
    if (
        self.ExceptionText
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ExceptionType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.locator is not None and 'locator' not in already_processed:
      already_processed.append('locator')
      showIndent(outfile, level)
      outfile.write('locator = "%s",\n' % (self.locator,))
    if self.exceptionCode is not None and 'exceptionCode' not in already_processed:
      already_processed.append('exceptionCode')
      showIndent(outfile, level)
      outfile.write('exceptionCode = "%s",\n' % (self.exceptionCode,))
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('ExceptionText=[\n')
    level += 1
    for ExceptionText_ in self.ExceptionText:
      showIndent(outfile, level)
      outfile.write('%s,\n' % quote_python(ExceptionText_).encode(ExternalEncoding))
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('locator', node)
    if value is not None and 'locator' not in already_processed:
      already_processed.append('locator')
      self.locator = value
    value = find_attr_value_('exceptionCode', node)
    if value is not None and 'exceptionCode' not in already_processed:
      already_processed.append('exceptionCode')
      self.exceptionCode = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ExceptionText':
      ExceptionText_ = child_.text
      ExceptionText_ = self.gds_validate_string(ExceptionText_, node, 'ExceptionText')
      self.ExceptionText.append(ExceptionText_)
# end class ExceptionType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
  print USAGE_TEXT
  sys.exit(1)


def get_root_tag(node):
  tag = Tag_pattern_.match(node.tag).groups()[-1]
  rootClass = globals().get(tag)
  return tag, rootClass


def parse(inFileName):
  doc = parsexml_(inFileName)
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'ExceptionReport'
    rootClass = ExceptionReport
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('<?xml version="1.0" ?>\n')
  rootObj.export(sys.stdout, 0, name_=rootTag,
      namespacedef_='')
  return rootObj


def parseString(inString):
  from StringIO import StringIO
  doc = parsexml_(StringIO(inString))
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'ExceptionReport'
    rootClass = ExceptionReport
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('<?xml version="1.0" ?>\n')
  rootObj.export(sys.stdout, 0, name_="ExceptionReport",
      namespacedef_='')
  return rootObj


def parseLiteral(inFileName):
  doc = parsexml_(inFileName)
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'ExceptionReport'
    rootClass = ExceptionReport
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('#from exception import *\n\n')
  sys.stdout.write('import exception as model_\n\n')
  sys.stdout.write('rootObj = model_.rootTag(\n')
  rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
  sys.stdout.write(')\n')
  return rootObj


def main():
  args = sys.argv[1:]
  if len(args) == 1:
    parse(args[0])
  else:
    usage()


if __name__ == '__main__':
  #import pdb; pdb.set_trace()
  main()


__all__ = [
    "ExceptionReport",
    "ExceptionType"
    ]
