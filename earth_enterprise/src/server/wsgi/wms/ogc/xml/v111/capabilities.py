#!/usr/bin/env python2.7
#
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# -*- coding: utf-8 -*-

#
# Generated Wed Jun  8 19:59:09 2011 by generateDS.py version 2.5a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
try:
    import defusedxml.ElementTree as etree_
    if Verbose_import_:
        print("running with defusedxml.ElementTree")
except ImportError:
    raise ImportError("Failed to import defusedxml.ElementTree")

def parsexml_(*args, **kwargs):
  doc = etree_.parse(*args, **kwargs)
  return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
# in a module named generatedssuper.py.

try:
  from generatedssuper import GeneratedsSuper
except ImportError, exp:

  class GeneratedsSuper(object):
    def gds_format_string(self, input_data, input_name=''):
      return input_data
    def gds_validate_string(self, input_data, node, input_name=''):
      return input_data
    def gds_format_integer(self, input_data, input_name=''):
      return '%d' % input_data
    def gds_validate_integer(self, input_data, node, input_name=''):
      return input_data
    def gds_format_integer_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_integer_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of integers')
      return input_data
    def gds_format_float(self, input_data, input_name=''):
      return '%f' % input_data
    def gds_validate_float(self, input_data, node, input_name=''):
      return input_data
    def gds_format_float_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_float_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of floats')
      return input_data
    def gds_format_double(self, input_data, input_name=''):
      return '%e' % input_data
    def gds_validate_double(self, input_data, node, input_name=''):
      return input_data
    def gds_format_double_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_double_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        try:
          fvalue = float(value)
        except (TypeError, ValueError), exp:
          raise_parse_error(node, 'Requires sequence of doubles')
      return input_data
    def gds_format_boolean(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_boolean(self, input_data, node, input_name=''):
      return input_data
    def gds_format_boolean_list(self, input_data, input_name=''):
      return '%s' % input_data
    def gds_validate_boolean_list(self, input_data, node, input_name=''):
      values = input_data.split()
      for value in values:
        if value not in ('true', '1', 'false', '0', ):
          raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
      return input_data
    def gds_str_lower(self, instring):
      return instring.lower()
    def get_path_(self, node):
      path_list = []
      self.get_path_list_(node, path_list)
      path_list.reverse()
      path = '/'.join(path_list)
      return path
    Tag_strip_pattern_ = re_.compile(r'\{.*\}')
    def get_path_list_(self, node, path_list):
      if node is None:
        return
      tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
      if tag:
        path_list.append(tag)
      self.get_path_list_(node.getparent(), path_list)


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
  for idx in range(level):
    outfile.write('    ')

def quote_xml(inStr):
  if not inStr:
    return ''
  s1 = (isinstance(inStr, basestring) and inStr or
        '%s' % inStr)
  s1 = s1.replace('&', '&amp;')
  s1 = s1.replace('<', '&lt;')
  s1 = s1.replace('>', '&gt;')
  return s1

def quote_attrib(inStr):
  s1 = (isinstance(inStr, basestring) and inStr or
        '%s' % inStr)
  s1 = s1.replace('&', '&amp;')
  s1 = s1.replace('<', '&lt;')
  s1 = s1.replace('>', '&gt;')
  if '"' in s1:
    if "'" in s1:
      s1 = '"%s"' % s1.replace('"', "&quot;")
    else:
      s1 = "'%s'" % s1
  else:
    s1 = '"%s"' % s1
  return s1

def quote_python(inStr):
  s1 = inStr
  if s1.find("'") == -1:
    if s1.find('\n') == -1:
      return "'%s'" % s1
    else:
      return "'''%s'''" % s1
  else:
    if s1.find('"') != -1:
      s1 = s1.replace('"', '\\"')
    if s1.find('\n') == -1:
      return '"%s"' % s1
    else:
      return '"""%s"""' % s1

def get_all_text_(node):
  if node.text is not None:
    text = node.text
  else:
    text = ''
  for child in node:
    if child.tail is not None:
      text += child.tail
  return text

def find_attr_value_(attr_name, node):
  attrs = node.attrib
  # First try with no namespace.
  value = attrs.get(attr_name)
  if value is None:
    # Now try the other possible namespaces.
    namespaces = node.nsmap.itervalues()
    for namespace in namespaces:
      value = attrs.get('{%s}%s' % (namespace, attr_name, ))
      if value is not None:
        break
  return value


class GDSParseError(Exception):
  pass

def raise_parse_error(node, msg):
  msg = '%s (element %s)' % (msg, node.tag, )
  raise GDSParseError(msg)


class MixedContainer:
  # Constants for category:
  CategoryNone = 0
  CategoryText = 1
  CategorySimple = 2
  CategoryComplex = 3
  # Constants for content_type:
  TypeNone = 0
  TypeText = 1
  TypeString = 2
  TypeInteger = 3
  TypeFloat = 4
  TypeDecimal = 5
  TypeDouble = 6
  TypeBoolean = 7
  def __init__(self, category, content_type, name, value):
    self.category = category
    self.content_type = content_type
    self.name = name
    self.value = value
  def getCategory(self):
    return self.category
  def getContenttype(self, content_type):
    return self.content_type
  def getValue(self):
    return self.value
  def getName(self):
    return self.name
  def export(self, outfile, level, name, namespace):
    if self.category == MixedContainer.CategoryText:
      # Prevent exporting empty content as empty lines.
      if self.value.strip():
        outfile.write(self.value)
    elif self.category == MixedContainer.CategorySimple:
      self.exportSimple(outfile, level, name)
    else:    # category == MixedContainer.CategoryComplex
      self.value.export(outfile, level, namespace,name)
  def exportSimple(self, outfile, level, name):
    if self.content_type == MixedContainer.TypeString:
      outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeInteger or \
            self.content_type == MixedContainer.TypeBoolean:
      outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeFloat or \
            self.content_type == MixedContainer.TypeDecimal:
      outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
    elif self.content_type == MixedContainer.TypeDouble:
      outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
  def exportLiteral(self, outfile, level, name):
    if self.category == MixedContainer.CategoryText:
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
          (self.category, self.content_type, self.name, self.value))
    elif self.category == MixedContainer.CategorySimple:
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
          (self.category, self.content_type, self.name, self.value))
    else:    # category == MixedContainer.CategoryComplex
      showIndent(outfile, level)
      outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
          (self.category, self.content_type, self.name,))
      self.value.exportLiteral(outfile, level + 1)
      showIndent(outfile, level)
      outfile.write(')\n')


class MemberSpec_(object):
  def __init__(self, name='', data_type='', container=0):
    self.name = name
    self.data_type = data_type
    self.container = container
  def set_name(self, name): self.name = name
  def get_name(self): return self.name
  def set_data_type(self, data_type): self.data_type = data_type
  def get_data_type_chain(self): return self.data_type
  def get_data_type(self):
    if isinstance(self.data_type, list):
      if len(self.data_type) > 0:
        return self.data_type[-1]
      else:
        return 'xs:string'
    else:
      return self.data_type
  def set_container(self, container): self.container = container
  def get_container(self): return self.container

def _cast(typ, value):
  if typ is None or value is None:
    return value
  return typ(value)

#
# Data representation classes.
#

class WMT_MS_Capabilities(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, updateSequence=None, version=None, Service=None, Capability=None):
    self.updateSequence = _cast(None, updateSequence)
    self.version = _cast(None, version)
    self.Service = Service
    self.Capability = Capability
  def factory(*args_, **kwargs_):
    if WMT_MS_Capabilities.subclass:
      return WMT_MS_Capabilities.subclass(*args_, **kwargs_)
    else:
      return WMT_MS_Capabilities(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Service(self): return self.Service
  def set_Service(self, Service): self.Service = Service
  def get_Capability(self): return self.Capability
  def set_Capability(self, Capability): self.Capability = Capability
  def get_updateSequence(self): return self.updateSequence
  def set_updateSequence(self, updateSequence): self.updateSequence = updateSequence
  def get_version(self): return self.version
  def set_version(self, version): self.version = version
  def export(self, outfile, level, namespace_='', name_='WMT_MS_Capabilities', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='WMT_MS_Capabilities')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WMT_MS_Capabilities'):
    if self.updateSequence is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      outfile.write(' updateSequence=%s' % (self.gds_format_string(quote_attrib(self.updateSequence).encode(ExternalEncoding), input_name='updateSequence'), ))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='WMT_MS_Capabilities', fromsubclass_=False):
    if self.Service:
      self.Service.export(outfile, level, namespace_, name_='Service', )
    if self.Capability:
      self.Capability.export(outfile, level, namespace_, name_='Capability', )
  def hasContent_(self):
    if (
        self.Service is not None or
        self.Capability is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='WMT_MS_Capabilities'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.updateSequence is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      showIndent(outfile, level)
      outfile.write('updateSequence = "%s",\n' % (self.updateSequence,))
    if self.version is not None and 'version' not in already_processed:
      already_processed.append('version')
      showIndent(outfile, level)
      outfile.write('version = "%s",\n' % (self.version,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Service is not None:
      showIndent(outfile, level)
      outfile.write('Service=model_.Service(\n')
      self.Service.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Capability is not None:
      showIndent(outfile, level)
      outfile.write('Capability=model_.Capability(\n')
      self.Capability.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('updateSequence', node)
    if value is not None and 'updateSequence' not in already_processed:
      already_processed.append('updateSequence')
      self.updateSequence = value
    value = find_attr_value_('version', node)
    if value is not None and 'version' not in already_processed:
      already_processed.append('version')
      self.version = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Service':
      obj_ = Service.factory()
      obj_.build(child_)
      self.set_Service(obj_)
    elif nodeName_ == 'Capability':
      obj_ = Capability.factory()
      obj_.build(child_)
      self.set_Capability(obj_)
# end class WMT_MS_Capabilities


class Name(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Name.subclass:
      return Name.subclass(*args_, **kwargs_)
    else:
      return Name(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Name', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Name')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Name'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Name', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Name'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Name


class Title(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Title.subclass:
      return Title.subclass(*args_, **kwargs_)
    else:
      return Title(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Title', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Title')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Title'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Title', fromsubclass_=False):
    outfile.write(self.gds_format_string(quote_xml(self.valueOf_).encode(ExternalEncoding)))
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Title'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Title


class Abstract(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Abstract.subclass:
      return Abstract.subclass(*args_, **kwargs_)
    else:
      return Abstract(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Abstract', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Abstract')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Abstract'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Abstract', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Abstract'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Abstract


class OnlineResource(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, xlink_type=None, xmlns_xlink=None, xlink_href=None, valueOf_=None):
    self.xlink_type = _cast(None, xlink_type)
    self.xmlns_xlink = _cast(None, xmlns_xlink)
    self.xlink_href = _cast(None, xlink_href)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if OnlineResource.subclass:
      return OnlineResource.subclass(*args_, **kwargs_)
    else:
      return OnlineResource(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_xlink_type(self): return self.xlink_type
  def set_xlink_type(self, xlink_type): self.xlink_type = xlink_type
  def get_xmlns_xlink(self): return self.xmlns_xlink
  def set_xmlns_xlink(self, xmlns_xlink): self.xmlns_xlink = xmlns_xlink
  def get_xlink_href(self): return self.xlink_href
  def set_xlink_href(self, xlink_href): self.xlink_href = xlink_href
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='OnlineResource', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='OnlineResource')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnlineResource'):
    if self.xmlns_xlink is not None and 'xmlns_xlink' not in already_processed:
      already_processed.append('xmlns_xlink')
      outfile.write(' xmlns:xlink=%s' % (self.gds_format_string(quote_attrib(self.xmlns_xlink).encode(ExternalEncoding), input_name='xmlns:xlink'), ))
    if self.xlink_type is not None and 'xlink_type' not in already_processed:
      already_processed.append('xlink_type')
      outfile.write(' xlink:type=%s' % (self.gds_format_string(quote_attrib(self.xlink_type).encode(ExternalEncoding), input_name='xlink:type'), ))
    if self.xlink_href is not None and 'xlink_href' not in already_processed:
      already_processed.append('xlink_href')
      outfile.write(' xlink:href=%s' % (self.gds_format_string(quote_attrib(self.xlink_href).encode(ExternalEncoding), input_name='xlink:href'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='OnlineResource', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='OnlineResource'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.xlink_type is not None and 'xlink_type' not in already_processed:
      already_processed.append('xlink_type')
      showIndent(outfile, level)
      outfile.write('xlink_type = "%s",\n' % (self.xlink_type,))
    if self.xmlns_xlink is not None and 'xmlns_xlink' not in already_processed:
      already_processed.append('xmlns_xlink')
      showIndent(outfile, level)
      outfile.write('xmlns_xlink = "%s",\n' % (self.xmlns_xlink,))
    if self.xlink_href is not None and 'xlink_href' not in already_processed:
      already_processed.append('xlink_href')
      showIndent(outfile, level)
      outfile.write('xlink_href = "%s",\n' % (self.xlink_href,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('xlink:type', node)
    if value is not None and 'xlink:type' not in already_processed:
      already_processed.append('xlink:type')
      self.xlink_type = value
    value = find_attr_value_('xmlns:xlink', node)
    if value is not None and 'xmlns:xlink' not in already_processed:
      already_processed.append('xmlns:xlink')
      self.xmlns_xlink = value
    value = find_attr_value_('xlink:href', node)
    if value is not None and 'xlink:href' not in already_processed:
      already_processed.append('xlink:href')
      self.xlink_href = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class OnlineResource


class Format(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Format.subclass:
      return Format.subclass(*args_, **kwargs_)
    else:
      return Format(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Format', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Format')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Format'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Format', fromsubclass_=False):
    outfile.write(self.gds_format_string(quote_xml(self.valueOf_).encode(ExternalEncoding)))
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Format'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Format


class Service(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Name=None, Title=None, Abstract=None, KeywordList=None, OnlineResource=None, ContactInformation=None, Fees=None, AccessConstraints=None):
    self.Name = Name
    self.Title = Title
    self.Abstract = Abstract
    self.KeywordList = KeywordList
    self.OnlineResource = OnlineResource
    self.ContactInformation = ContactInformation
    self.Fees = Fees
    self.AccessConstraints = AccessConstraints
  def factory(*args_, **kwargs_):
    if Service.subclass:
      return Service.subclass(*args_, **kwargs_)
    else:
      return Service(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Name(self): return self.Name
  def set_Name(self, Name): self.Name = Name
  def get_Title(self): return self.Title
  def set_Title(self, Title): self.Title = Title
  def get_Abstract(self): return self.Abstract
  def set_Abstract(self, Abstract): self.Abstract = Abstract
  def get_KeywordList(self): return self.KeywordList
  def set_KeywordList(self, KeywordList): self.KeywordList = KeywordList
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_ContactInformation(self): return self.ContactInformation
  def set_ContactInformation(self, ContactInformation): self.ContactInformation = ContactInformation
  def get_Fees(self): return self.Fees
  def set_Fees(self, Fees): self.Fees = Fees
  def get_AccessConstraints(self): return self.AccessConstraints
  def set_AccessConstraints(self, AccessConstraints): self.AccessConstraints = AccessConstraints
  def export(self, outfile, level, namespace_='', name_='Service', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Service')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Service'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Service', fromsubclass_=False):
    if self.Name is not None:
      showIndent(outfile, level)
      outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
    if self.Title:
      self.Title.export(outfile, level, namespace_, name_='Title', )
    if self.Abstract:
      self.Abstract.export(outfile, level, namespace_, name_='Abstract')
    if self.KeywordList:
      self.KeywordList.export(outfile, level, namespace_, name_='KeywordList')
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
    if self.ContactInformation:
      self.ContactInformation.export(outfile, level, namespace_, name_='ContactInformation')
    if self.Fees:
      self.Fees.export(outfile, level, namespace_, name_='Fees')
    if self.AccessConstraints:
      self.AccessConstraints.export(outfile, level, namespace_, name_='AccessConstraints')
  def hasContent_(self):
    if (
        self.Name is not None or
        self.Title is not None or
        self.Abstract is not None or
        self.KeywordList is not None or
        self.OnlineResource is not None or
        self.ContactInformation is not None or
        self.Fees is not None or
        self.AccessConstraints is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Service'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Name is not None:
      showIndent(outfile, level)
      outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    if self.Title is not None:
      showIndent(outfile, level)
      outfile.write('Title=model_.Title(\n')
      self.Title.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Abstract is not None:
      showIndent(outfile, level)
      outfile.write('Abstract=model_.Abstract(\n')
      self.Abstract.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.KeywordList is not None:
      showIndent(outfile, level)
      outfile.write('KeywordList=model_.KeywordList(\n')
      self.KeywordList.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactInformation is not None:
      showIndent(outfile, level)
      outfile.write('ContactInformation=model_.ContactInformation(\n')
      self.ContactInformation.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Fees is not None:
      showIndent(outfile, level)
      outfile.write('Fees=model_.Fees(\n')
      self.Fees.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.AccessConstraints is not None:
      showIndent(outfile, level)
      outfile.write('AccessConstraints=model_.AccessConstraints(\n')
      self.AccessConstraints.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Name':
      Name_ = child_.text
      Name_ = self.gds_validate_string(Name_, node, 'Name')
      self.Name = Name_
    elif nodeName_ == 'Title':
      obj_ = Title.factory()
      obj_.build(child_)
      self.set_Title(obj_)
    elif nodeName_ == 'Abstract':
      obj_ = Abstract.factory()
      obj_.build(child_)
      self.set_Abstract(obj_)
    elif nodeName_ == 'KeywordList':
      obj_ = KeywordList.factory()
      obj_.build(child_)
      self.set_KeywordList(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
    elif nodeName_ == 'ContactInformation':
      obj_ = ContactInformation.factory()
      obj_.build(child_)
      self.set_ContactInformation(obj_)
    elif nodeName_ == 'Fees':
      obj_ = Fees.factory()
      obj_.build(child_)
      self.set_Fees(obj_)
    elif nodeName_ == 'AccessConstraints':
      obj_ = AccessConstraints.factory()
      obj_.build(child_)
      self.set_AccessConstraints(obj_)
# end class Service


class KeywordList(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Keyword=None):
    if Keyword is None:
      self.Keyword = []
    else:
      self.Keyword = Keyword
  def factory(*args_, **kwargs_):
    if KeywordList.subclass:
      return KeywordList.subclass(*args_, **kwargs_)
    else:
      return KeywordList(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Keyword(self): return self.Keyword
  def set_Keyword(self, Keyword): self.Keyword = Keyword
  def add_Keyword(self, value): self.Keyword.append(value)
  def insert_Keyword(self, index, value): self.Keyword[index] = value
  def export(self, outfile, level, namespace_='', name_='KeywordList', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='KeywordList')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeywordList'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='KeywordList', fromsubclass_=False):
    for Keyword_ in self.Keyword:
      Keyword_.export(outfile, level, namespace_, name_='Keyword')
  def hasContent_(self):
    if (
        self.Keyword
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='KeywordList'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Keyword=[\n')
    level += 1
    for Keyword_ in self.Keyword:
      showIndent(outfile, level)
      outfile.write('model_.Keyword(\n')
      Keyword_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Keyword':
      obj_ = Keyword.factory()
      obj_.build(child_)
      self.Keyword.append(obj_)
# end class KeywordList


class Keyword(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Keyword.subclass:
      return Keyword.subclass(*args_, **kwargs_)
    else:
      return Keyword(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Keyword', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Keyword')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Keyword'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Keyword', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Keyword'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Keyword


class ContactInformation(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, ContactPersonPrimary=None, ContactPosition=None, ContactAddress=None, ContactVoiceTelephone=None, ContactFacsimileTelephone=None, ContactElectronicMailAddress=None):
    self.ContactPersonPrimary = ContactPersonPrimary
    self.ContactPosition = ContactPosition
    self.ContactAddress = ContactAddress
    self.ContactVoiceTelephone = ContactVoiceTelephone
    self.ContactFacsimileTelephone = ContactFacsimileTelephone
    self.ContactElectronicMailAddress = ContactElectronicMailAddress
  def factory(*args_, **kwargs_):
    if ContactInformation.subclass:
      return ContactInformation.subclass(*args_, **kwargs_)
    else:
      return ContactInformation(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ContactPersonPrimary(self): return self.ContactPersonPrimary
  def set_ContactPersonPrimary(self, ContactPersonPrimary): self.ContactPersonPrimary = ContactPersonPrimary
  def get_ContactPosition(self): return self.ContactPosition
  def set_ContactPosition(self, ContactPosition): self.ContactPosition = ContactPosition
  def get_ContactAddress(self): return self.ContactAddress
  def set_ContactAddress(self, ContactAddress): self.ContactAddress = ContactAddress
  def get_ContactVoiceTelephone(self): return self.ContactVoiceTelephone
  def set_ContactVoiceTelephone(self, ContactVoiceTelephone): self.ContactVoiceTelephone = ContactVoiceTelephone
  def get_ContactFacsimileTelephone(self): return self.ContactFacsimileTelephone
  def set_ContactFacsimileTelephone(self, ContactFacsimileTelephone): self.ContactFacsimileTelephone = ContactFacsimileTelephone
  def get_ContactElectronicMailAddress(self): return self.ContactElectronicMailAddress
  def set_ContactElectronicMailAddress(self, ContactElectronicMailAddress): self.ContactElectronicMailAddress = ContactElectronicMailAddress
  def export(self, outfile, level, namespace_='', name_='ContactInformation', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactInformation')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactInformation'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactInformation', fromsubclass_=False):
    if self.ContactPersonPrimary:
      self.ContactPersonPrimary.export(outfile, level, namespace_, name_='ContactPersonPrimary')
    if self.ContactPosition:
      self.ContactPosition.export(outfile, level, namespace_, name_='ContactPosition')
    if self.ContactAddress:
      self.ContactAddress.export(outfile, level, namespace_, name_='ContactAddress')
    if self.ContactVoiceTelephone:
      self.ContactVoiceTelephone.export(outfile, level, namespace_, name_='ContactVoiceTelephone')
    if self.ContactFacsimileTelephone:
      self.ContactFacsimileTelephone.export(outfile, level, namespace_, name_='ContactFacsimileTelephone')
    if self.ContactElectronicMailAddress:
      self.ContactElectronicMailAddress.export(outfile, level, namespace_, name_='ContactElectronicMailAddress')
  def hasContent_(self):
    if (
        self.ContactPersonPrimary is not None or
        self.ContactPosition is not None or
        self.ContactAddress is not None or
        self.ContactVoiceTelephone is not None or
        self.ContactFacsimileTelephone is not None or
        self.ContactElectronicMailAddress is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactInformation'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.ContactPersonPrimary is not None:
      showIndent(outfile, level)
      outfile.write('ContactPersonPrimary=model_.ContactPersonPrimary(\n')
      self.ContactPersonPrimary.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactPosition is not None:
      showIndent(outfile, level)
      outfile.write('ContactPosition=model_.ContactPosition(\n')
      self.ContactPosition.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactAddress is not None:
      showIndent(outfile, level)
      outfile.write('ContactAddress=model_.ContactAddress(\n')
      self.ContactAddress.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactVoiceTelephone is not None:
      showIndent(outfile, level)
      outfile.write('ContactVoiceTelephone=model_.ContactVoiceTelephone(\n')
      self.ContactVoiceTelephone.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactFacsimileTelephone is not None:
      showIndent(outfile, level)
      outfile.write('ContactFacsimileTelephone=model_.ContactFacsimileTelephone(\n')
      self.ContactFacsimileTelephone.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactElectronicMailAddress is not None:
      showIndent(outfile, level)
      outfile.write('ContactElectronicMailAddress=model_.ContactElectronicMailAddress(\n')
      self.ContactElectronicMailAddress.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ContactPersonPrimary':
      obj_ = ContactPersonPrimary.factory()
      obj_.build(child_)
      self.set_ContactPersonPrimary(obj_)
    elif nodeName_ == 'ContactPosition':
      obj_ = ContactPosition.factory()
      obj_.build(child_)
      self.set_ContactPosition(obj_)
    elif nodeName_ == 'ContactAddress':
      obj_ = ContactAddress.factory()
      obj_.build(child_)
      self.set_ContactAddress(obj_)
    elif nodeName_ == 'ContactVoiceTelephone':
      obj_ = ContactVoiceTelephone.factory()
      obj_.build(child_)
      self.set_ContactVoiceTelephone(obj_)
    elif nodeName_ == 'ContactFacsimileTelephone':
      obj_ = ContactFacsimileTelephone.factory()
      obj_.build(child_)
      self.set_ContactFacsimileTelephone(obj_)
    elif nodeName_ == 'ContactElectronicMailAddress':
      obj_ = ContactElectronicMailAddress.factory()
      obj_.build(child_)
      self.set_ContactElectronicMailAddress(obj_)
# end class ContactInformation


class ContactPersonPrimary(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, ContactPerson=None, ContactOrganization=None):
    self.ContactPerson = ContactPerson
    self.ContactOrganization = ContactOrganization
  def factory(*args_, **kwargs_):
    if ContactPersonPrimary.subclass:
      return ContactPersonPrimary.subclass(*args_, **kwargs_)
    else:
      return ContactPersonPrimary(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_ContactPerson(self): return self.ContactPerson
  def set_ContactPerson(self, ContactPerson): self.ContactPerson = ContactPerson
  def get_ContactOrganization(self): return self.ContactOrganization
  def set_ContactOrganization(self, ContactOrganization): self.ContactOrganization = ContactOrganization
  def export(self, outfile, level, namespace_='', name_='ContactPersonPrimary', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactPersonPrimary')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactPersonPrimary'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactPersonPrimary', fromsubclass_=False):
    if self.ContactPerson:
      self.ContactPerson.export(outfile, level, namespace_, name_='ContactPerson', )
    if self.ContactOrganization:
      self.ContactOrganization.export(outfile, level, namespace_, name_='ContactOrganization', )
  def hasContent_(self):
    if (
        self.ContactPerson is not None or
        self.ContactOrganization is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactPersonPrimary'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.ContactPerson is not None:
      showIndent(outfile, level)
      outfile.write('ContactPerson=model_.ContactPerson(\n')
      self.ContactPerson.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.ContactOrganization is not None:
      showIndent(outfile, level)
      outfile.write('ContactOrganization=model_.ContactOrganization(\n')
      self.ContactOrganization.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'ContactPerson':
      obj_ = ContactPerson.factory()
      obj_.build(child_)
      self.set_ContactPerson(obj_)
    elif nodeName_ == 'ContactOrganization':
      obj_ = ContactOrganization.factory()
      obj_.build(child_)
      self.set_ContactOrganization(obj_)
# end class ContactPersonPrimary


class ContactPerson(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ContactPerson.subclass:
      return ContactPerson.subclass(*args_, **kwargs_)
    else:
      return ContactPerson(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ContactPerson', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactPerson')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactPerson'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactPerson', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactPerson'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class ContactPerson


class ContactOrganization(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ContactOrganization.subclass:
      return ContactOrganization.subclass(*args_, **kwargs_)
    else:
      return ContactOrganization(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ContactOrganization', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactOrganization')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactOrganization'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactOrganization', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactOrganization'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class ContactOrganization


class ContactPosition(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ContactPosition.subclass:
      return ContactPosition.subclass(*args_, **kwargs_)
    else:
      return ContactPosition(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ContactPosition', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactPosition')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactPosition'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactPosition', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactPosition'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class ContactPosition


class ContactAddress(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, AddressType=None, Address=None, City=None, StateOrProvince=None, PostCode=None, Country=None):
    self.AddressType = AddressType
    self.Address = Address
    self.City = City
    self.StateOrProvince = StateOrProvince
    self.PostCode = PostCode
    self.Country = Country
  def factory(*args_, **kwargs_):
    if ContactAddress.subclass:
      return ContactAddress.subclass(*args_, **kwargs_)
    else:
      return ContactAddress(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_AddressType(self): return self.AddressType
  def set_AddressType(self, AddressType): self.AddressType = AddressType
  def get_Address(self): return self.Address
  def set_Address(self, Address): self.Address = Address
  def get_City(self): return self.City
  def set_City(self, City): self.City = City
  def get_StateOrProvince(self): return self.StateOrProvince
  def set_StateOrProvince(self, StateOrProvince): self.StateOrProvince = StateOrProvince
  def get_PostCode(self): return self.PostCode
  def set_PostCode(self, PostCode): self.PostCode = PostCode
  def get_Country(self): return self.Country
  def set_Country(self, Country): self.Country = Country
  def export(self, outfile, level, namespace_='', name_='ContactAddress', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactAddress')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactAddress'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactAddress', fromsubclass_=False):
    if self.AddressType:
      self.AddressType.export(outfile, level, namespace_, name_='AddressType', )
    if self.Address:
      self.Address.export(outfile, level, namespace_, name_='Address', )
    if self.City:
      self.City.export(outfile, level, namespace_, name_='City', )
    if self.StateOrProvince:
      self.StateOrProvince.export(outfile, level, namespace_, name_='StateOrProvince', )
    if self.PostCode:
      self.PostCode.export(outfile, level, namespace_, name_='PostCode', )
    if self.Country:
      self.Country.export(outfile, level, namespace_, name_='Country', )
  def hasContent_(self):
    if (
        self.AddressType is not None or
        self.Address is not None or
        self.City is not None or
        self.StateOrProvince is not None or
        self.PostCode is not None or
        self.Country is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactAddress'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.AddressType is not None:
      showIndent(outfile, level)
      outfile.write('AddressType=model_.AddressType(\n')
      self.AddressType.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Address is not None:
      showIndent(outfile, level)
      outfile.write('Address=model_.Address(\n')
      self.Address.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.City is not None:
      showIndent(outfile, level)
      outfile.write('City=model_.City(\n')
      self.City.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.StateOrProvince is not None:
      showIndent(outfile, level)
      outfile.write('StateOrProvince=model_.StateOrProvince(\n')
      self.StateOrProvince.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.PostCode is not None:
      showIndent(outfile, level)
      outfile.write('PostCode=model_.PostCode(\n')
      self.PostCode.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Country is not None:
      showIndent(outfile, level)
      outfile.write('Country=model_.Country(\n')
      self.Country.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'AddressType':
      obj_ = AddressType.factory()
      obj_.build(child_)
      self.set_AddressType(obj_)
    elif nodeName_ == 'Address':
      obj_ = Address.factory()
      obj_.build(child_)
      self.set_Address(obj_)
    elif nodeName_ == 'City':
      obj_ = City.factory()
      obj_.build(child_)
      self.set_City(obj_)
    elif nodeName_ == 'StateOrProvince':
      obj_ = StateOrProvince.factory()
      obj_.build(child_)
      self.set_StateOrProvince(obj_)
    elif nodeName_ == 'PostCode':
      obj_ = PostCode.factory()
      obj_.build(child_)
      self.set_PostCode(obj_)
    elif nodeName_ == 'Country':
      obj_ = Country.factory()
      obj_.build(child_)
      self.set_Country(obj_)
# end class ContactAddress


class AddressType(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if AddressType.subclass:
      return AddressType.subclass(*args_, **kwargs_)
    else:
      return AddressType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='AddressType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AddressType')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AddressType', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AddressType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class AddressType


class Address(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Address.subclass:
      return Address.subclass(*args_, **kwargs_)
    else:
      return Address(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Address', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Address')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Address'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Address', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Address'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Address


class City(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if City.subclass:
      return City.subclass(*args_, **kwargs_)
    else:
      return City(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='City', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='City')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='City'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='City', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='City'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class City


class StateOrProvince(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if StateOrProvince.subclass:
      return StateOrProvince.subclass(*args_, **kwargs_)
    else:
      return StateOrProvince(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='StateOrProvince', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='StateOrProvince')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateOrProvince'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='StateOrProvince', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='StateOrProvince'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class StateOrProvince


class PostCode(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if PostCode.subclass:
      return PostCode.subclass(*args_, **kwargs_)
    else:
      return PostCode(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='PostCode', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='PostCode')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostCode'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='PostCode', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='PostCode'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class PostCode


class Country(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Country.subclass:
      return Country.subclass(*args_, **kwargs_)
    else:
      return Country(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Country', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Country')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Country'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Country', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Country'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Country


class ContactVoiceTelephone(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ContactVoiceTelephone.subclass:
      return ContactVoiceTelephone.subclass(*args_, **kwargs_)
    else:
      return ContactVoiceTelephone(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ContactVoiceTelephone', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactVoiceTelephone')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactVoiceTelephone'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactVoiceTelephone', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactVoiceTelephone'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class ContactVoiceTelephone


class ContactFacsimileTelephone(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ContactFacsimileTelephone.subclass:
      return ContactFacsimileTelephone.subclass(*args_, **kwargs_)
    else:
      return ContactFacsimileTelephone(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ContactFacsimileTelephone', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactFacsimileTelephone')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactFacsimileTelephone'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactFacsimileTelephone', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactFacsimileTelephone'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class ContactFacsimileTelephone


class ContactElectronicMailAddress(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ContactElectronicMailAddress.subclass:
      return ContactElectronicMailAddress.subclass(*args_, **kwargs_)
    else:
      return ContactElectronicMailAddress(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ContactElectronicMailAddress', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ContactElectronicMailAddress')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactElectronicMailAddress'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='ContactElectronicMailAddress', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ContactElectronicMailAddress'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class ContactElectronicMailAddress


class Fees(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Fees.subclass:
      return Fees.subclass(*args_, **kwargs_)
    else:
      return Fees(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Fees', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Fees')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Fees'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Fees', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Fees'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Fees


class AccessConstraints(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if AccessConstraints.subclass:
      return AccessConstraints.subclass(*args_, **kwargs_)
    else:
      return AccessConstraints(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='AccessConstraints', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AccessConstraints')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessConstraints'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='AccessConstraints', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AccessConstraints'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class AccessConstraints


class Capability(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Request=None, Exception=None, VendorSpecificCapabilities=None, UserDefinedSymbolization=None, Layer=None):
    self.Request = Request
    self.Exception = Exception
    self.VendorSpecificCapabilities = VendorSpecificCapabilities
    self.UserDefinedSymbolization = UserDefinedSymbolization
    self.Layer = Layer
  def factory(*args_, **kwargs_):
    if Capability.subclass:
      return Capability.subclass(*args_, **kwargs_)
    else:
      return Capability(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Request(self): return self.Request
  def set_Request(self, Request): self.Request = Request
  def get_Exception(self): return self.Exception
  def set_Exception(self, Exception): self.Exception = Exception
  def get_VendorSpecificCapabilities(self): return self.VendorSpecificCapabilities
  def set_VendorSpecificCapabilities(self, VendorSpecificCapabilities): self.VendorSpecificCapabilities = VendorSpecificCapabilities
  def get_UserDefinedSymbolization(self): return self.UserDefinedSymbolization
  def set_UserDefinedSymbolization(self, UserDefinedSymbolization): self.UserDefinedSymbolization = UserDefinedSymbolization
  def get_Layer(self): return self.Layer
  def set_Layer(self, Layer): self.Layer = Layer
  def export(self, outfile, level, namespace_='', name_='Capability', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Capability')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Capability'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Capability', fromsubclass_=False):
    if self.Request:
      self.Request.export(outfile, level, namespace_, name_='Request', )
    if self.Exception:
      self.Exception.export(outfile, level, namespace_, name_='Exception', )
    if self.VendorSpecificCapabilities is not None:
      showIndent(outfile, level)
      outfile.write('<%sVendorSpecificCapabilities>%s</%sVendorSpecificCapabilities>\n' % (namespace_, self.gds_format_string(quote_xml(self.VendorSpecificCapabilities).encode(ExternalEncoding), input_name='VendorSpecificCapabilities'), namespace_))
    if self.UserDefinedSymbolization:
      self.UserDefinedSymbolization.export(outfile, level, namespace_, name_='UserDefinedSymbolization')
    if self.Layer:
      self.Layer.export(outfile, level, namespace_, name_='Layer')
  def hasContent_(self):
    if (
        self.Request is not None or
        self.Exception is not None or
        self.VendorSpecificCapabilities is not None or
        self.UserDefinedSymbolization is not None or
        self.Layer is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Capability'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Request is not None:
      showIndent(outfile, level)
      outfile.write('Request=model_.Request(\n')
      self.Request.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Exception is not None:
      showIndent(outfile, level)
      outfile.write('Exception=model_.Exception(\n')
      self.Exception.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.VendorSpecificCapabilities is not None:
      showIndent(outfile, level)
      outfile.write('VendorSpecificCapabilities=%s,\n' % quote_python(self.VendorSpecificCapabilities).encode(ExternalEncoding))
    if self.UserDefinedSymbolization is not None:
      showIndent(outfile, level)
      outfile.write('UserDefinedSymbolization=model_.UserDefinedSymbolization(\n')
      self.UserDefinedSymbolization.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Layer is not None:
      showIndent(outfile, level)
      outfile.write('Layer=model_.Layer(\n')
      self.Layer.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Request':
      obj_ = Request.factory()
      obj_.build(child_)
      self.set_Request(obj_)
    elif nodeName_ == 'Exception':
      obj_ = Exception.factory()
      obj_.build(child_)
      self.set_Exception(obj_)
    elif nodeName_ == 'VendorSpecificCapabilities':
      VendorSpecificCapabilities_ = child_.text
      VendorSpecificCapabilities_ = self.gds_validate_string(VendorSpecificCapabilities_, node, 'VendorSpecificCapabilities')
      self.VendorSpecificCapabilities = VendorSpecificCapabilities_
    elif nodeName_ == 'UserDefinedSymbolization':
      obj_ = UserDefinedSymbolization.factory()
      obj_.build(child_)
      self.set_UserDefinedSymbolization(obj_)
    elif nodeName_ == 'Layer':
      obj_ = Layer.factory()
      obj_.build(child_)
      self.set_Layer(obj_)
# end class Capability


class Request(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, GetCapabilities=None, GetMap=None, GetFeatureInfo=None, DescribeLayer=None, GetLegendGraphic=None, GetStyles=None, PutStyles=None):
    self.GetCapabilities = GetCapabilities
    self.GetMap = GetMap
    self.GetFeatureInfo = GetFeatureInfo
    self.DescribeLayer = DescribeLayer
    self.GetLegendGraphic = GetLegendGraphic
    self.GetStyles = GetStyles
    self.PutStyles = PutStyles
  def factory(*args_, **kwargs_):
    if Request.subclass:
      return Request.subclass(*args_, **kwargs_)
    else:
      return Request(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_GetCapabilities(self): return self.GetCapabilities
  def set_GetCapabilities(self, GetCapabilities): self.GetCapabilities = GetCapabilities
  def get_GetMap(self): return self.GetMap
  def set_GetMap(self, GetMap): self.GetMap = GetMap
  def get_GetFeatureInfo(self): return self.GetFeatureInfo
  def set_GetFeatureInfo(self, GetFeatureInfo): self.GetFeatureInfo = GetFeatureInfo
  def get_DescribeLayer(self): return self.DescribeLayer
  def set_DescribeLayer(self, DescribeLayer): self.DescribeLayer = DescribeLayer
  def get_GetLegendGraphic(self): return self.GetLegendGraphic
  def set_GetLegendGraphic(self, GetLegendGraphic): self.GetLegendGraphic = GetLegendGraphic
  def get_GetStyles(self): return self.GetStyles
  def set_GetStyles(self, GetStyles): self.GetStyles = GetStyles
  def get_PutStyles(self): return self.PutStyles
  def set_PutStyles(self, PutStyles): self.PutStyles = PutStyles
  def export(self, outfile, level, namespace_='', name_='Request', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Request')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Request'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Request', fromsubclass_=False):
    if self.GetCapabilities:
      self.GetCapabilities.export(outfile, level, namespace_, name_='GetCapabilities', )
    if self.GetMap:
      self.GetMap.export(outfile, level, namespace_, name_='GetMap', )
    if self.GetFeatureInfo:
      self.GetFeatureInfo.export(outfile, level, namespace_, name_='GetFeatureInfo')
    if self.DescribeLayer:
      self.DescribeLayer.export(outfile, level, namespace_, name_='DescribeLayer')
    if self.GetLegendGraphic:
      self.GetLegendGraphic.export(outfile, level, namespace_, name_='GetLegendGraphic')
    if self.GetStyles:
      self.GetStyles.export(outfile, level, namespace_, name_='GetStyles')
    if self.PutStyles:
      self.PutStyles.export(outfile, level, namespace_, name_='PutStyles')
  def hasContent_(self):
    if (
        self.GetCapabilities is not None or
        self.GetMap is not None or
        self.GetFeatureInfo is not None or
        self.DescribeLayer is not None or
        self.GetLegendGraphic is not None or
        self.GetStyles is not None or
        self.PutStyles is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Request'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.GetCapabilities is not None:
      showIndent(outfile, level)
      outfile.write('GetCapabilities=model_.GetCapabilities(\n')
      self.GetCapabilities.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.GetMap is not None:
      showIndent(outfile, level)
      outfile.write('GetMap=model_.GetMap(\n')
      self.GetMap.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.GetFeatureInfo is not None:
      showIndent(outfile, level)
      outfile.write('GetFeatureInfo=model_.GetFeatureInfo(\n')
      self.GetFeatureInfo.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.DescribeLayer is not None:
      showIndent(outfile, level)
      outfile.write('DescribeLayer=model_.DescribeLayer(\n')
      self.DescribeLayer.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.GetLegendGraphic is not None:
      showIndent(outfile, level)
      outfile.write('GetLegendGraphic=model_.GetLegendGraphic(\n')
      self.GetLegendGraphic.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.GetStyles is not None:
      showIndent(outfile, level)
      outfile.write('GetStyles=model_.GetStyles(\n')
      self.GetStyles.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.PutStyles is not None:
      showIndent(outfile, level)
      outfile.write('PutStyles=model_.PutStyles(\n')
      self.PutStyles.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'GetCapabilities':
      obj_ = GetCapabilities.factory()
      obj_.build(child_)
      self.set_GetCapabilities(obj_)
    elif nodeName_ == 'GetMap':
      obj_ = GetMap.factory()
      obj_.build(child_)
      self.set_GetMap(obj_)
    elif nodeName_ == 'GetFeatureInfo':
      obj_ = GetFeatureInfo.factory()
      obj_.build(child_)
      self.set_GetFeatureInfo(obj_)
    elif nodeName_ == 'DescribeLayer':
      obj_ = DescribeLayer.factory()
      obj_.build(child_)
      self.set_DescribeLayer(obj_)
    elif nodeName_ == 'GetLegendGraphic':
      obj_ = GetLegendGraphic.factory()
      obj_.build(child_)
      self.set_GetLegendGraphic(obj_)
    elif nodeName_ == 'GetStyles':
      obj_ = GetStyles.factory()
      obj_.build(child_)
      self.set_GetStyles(obj_)
    elif nodeName_ == 'PutStyles':
      obj_ = PutStyles.factory()
      obj_.build(child_)
      self.set_PutStyles(obj_)
# end class Request


class GetCapabilities(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if GetCapabilities.subclass:
      return GetCapabilities.subclass(*args_, **kwargs_)
    else:
      return GetCapabilities(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='GetCapabilities', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetCapabilities')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetCapabilities'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='GetCapabilities', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetCapabilities'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class GetCapabilities


class GetMap(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if GetMap.subclass:
      return GetMap.subclass(*args_, **kwargs_)
    else:
      return GetMap(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='GetMap', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetMap')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetMap'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='GetMap', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetMap'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class GetMap


class GetFeatureInfo(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if GetFeatureInfo.subclass:
      return GetFeatureInfo.subclass(*args_, **kwargs_)
    else:
      return GetFeatureInfo(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='GetFeatureInfo', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetFeatureInfo')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetFeatureInfo'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='GetFeatureInfo', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetFeatureInfo'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class GetFeatureInfo


class DescribeLayer(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if DescribeLayer.subclass:
      return DescribeLayer.subclass(*args_, **kwargs_)
    else:
      return DescribeLayer(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='DescribeLayer', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DescribeLayer')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DescribeLayer'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='DescribeLayer', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DescribeLayer'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class DescribeLayer


class GetLegendGraphic(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if GetLegendGraphic.subclass:
      return GetLegendGraphic.subclass(*args_, **kwargs_)
    else:
      return GetLegendGraphic(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='GetLegendGraphic', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetLegendGraphic')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetLegendGraphic'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='GetLegendGraphic', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetLegendGraphic'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class GetLegendGraphic


class GetStyles(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if GetStyles.subclass:
      return GetStyles.subclass(*args_, **kwargs_)
    else:
      return GetStyles(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='GetStyles', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='GetStyles')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetStyles'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='GetStyles', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='GetStyles'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class GetStyles


class PutStyles(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, DCPType=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
    if DCPType is None:
      self.DCPType = []
    else:
      self.DCPType = DCPType
  def factory(*args_, **kwargs_):
    if PutStyles.subclass:
      return PutStyles.subclass(*args_, **kwargs_)
    else:
      return PutStyles(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def get_DCPType(self): return self.DCPType
  def set_DCPType(self, DCPType): self.DCPType = DCPType
  def add_DCPType(self, value): self.DCPType.append(value)
  def insert_DCPType(self, index, value): self.DCPType[index] = value
  def export(self, outfile, level, namespace_='', name_='PutStyles', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='PutStyles')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PutStyles'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='PutStyles', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
    for DCPType_ in self.DCPType:
      DCPType_.export(outfile, level, namespace_, name_='DCPType')
  def hasContent_(self):
    if (
        self.Format or
        self.DCPType
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='PutStyles'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DCPType=[\n')
    level += 1
    for DCPType_ in self.DCPType:
      showIndent(outfile, level)
      outfile.write('model_.DCPType(\n')
      DCPType_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
    elif nodeName_ == 'DCPType':
      obj_ = DCPType.factory()
      obj_.build(child_)
      self.DCPType.append(obj_)
# end class PutStyles


class DCPType(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, HTTP=None):
    self.HTTP = HTTP
  def factory(*args_, **kwargs_):
    if DCPType.subclass:
      return DCPType.subclass(*args_, **kwargs_)
    else:
      return DCPType(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_HTTP(self): return self.HTTP
  def set_HTTP(self, HTTP): self.HTTP = HTTP
  def export(self, outfile, level, namespace_='', name_='DCPType', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DCPType')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCPType'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='DCPType', fromsubclass_=False):
    if self.HTTP:
      self.HTTP.export(outfile, level, namespace_, name_='HTTP', )
  def hasContent_(self):
    if (
        self.HTTP is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DCPType'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.HTTP is not None:
      showIndent(outfile, level)
      outfile.write('HTTP=model_.HTTP(\n')
      self.HTTP.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'HTTP':
      obj_ = HTTP.factory()
      obj_.build(child_)
      self.set_HTTP(obj_)
# end class DCPType


class HTTP(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Get=None, Post=None):
    if Get is None:
      self.Get = []
    else:
      self.Get = Get
    if Post is None:
      self.Post = []
    else:
      self.Post = Post
  def factory(*args_, **kwargs_):
    if HTTP.subclass:
      return HTTP.subclass(*args_, **kwargs_)
    else:
      return HTTP(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Get(self): return self.Get
  def set_Get(self, Get): self.Get = Get
  def add_Get(self, value): self.Get.append(value)
  def insert_Get(self, index, value): self.Get[index] = value
  def get_Post(self): return self.Post
  def set_Post(self, Post): self.Post = Post
  def add_Post(self, value): self.Post.append(value)
  def insert_Post(self, index, value): self.Post[index] = value
  def export(self, outfile, level, namespace_='', name_='HTTP', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='HTTP')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HTTP'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='HTTP', fromsubclass_=False):
    for Get_ in self.Get:
      Get_.export(outfile, level, namespace_, name_='Get')
    for Post_ in self.Post:
      Post_.export(outfile, level, namespace_, name_='Post')
  def hasContent_(self):
    if (
        self.Get or
        self.Post
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='HTTP'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Get=[\n')
    level += 1
    for Get_ in self.Get:
      showIndent(outfile, level)
      outfile.write('model_.Get(\n')
      Get_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Post=[\n')
    level += 1
    for Post_ in self.Post:
      showIndent(outfile, level)
      outfile.write('model_.Post(\n')
      Post_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Get':
      obj_ = Get.factory()
      obj_.build(child_)
      self.Get.append(obj_)
    elif nodeName_ == 'Post':
      obj_ = Post.factory()
      obj_.build(child_)
      self.Post.append(obj_)
# end class HTTP


class Get(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, OnlineResource=None):
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if Get.subclass:
      return Get.subclass(*args_, **kwargs_)
    else:
      return Get(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def export(self, outfile, level, namespace_='', name_='Get', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Get')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Get'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Get', fromsubclass_=False):
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Get'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class Get


class Post(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, OnlineResource=None):
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if Post.subclass:
      return Post.subclass(*args_, **kwargs_)
    else:
      return Post(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def export(self, outfile, level, namespace_='', name_='Post', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Post')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Post'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Post', fromsubclass_=False):
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Post'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class Post


class Exception(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None):
    if Format is None:
      self.Format = []
    else:
      self.Format = Format
  def factory(*args_, **kwargs_):
    if Exception.subclass:
      return Exception.subclass(*args_, **kwargs_)
    else:
      return Exception(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def add_Format(self, value): self.Format.append(value)
  def insert_Format(self, index, value): self.Format[index] = value
  def export(self, outfile, level, namespace_='', name_='Exception', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Exception')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exception'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Exception', fromsubclass_=False):
    for Format_ in self.Format:
      Format_.export(outfile, level, namespace_, name_='Format')
  def hasContent_(self):
    if (
        self.Format
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Exception'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    showIndent(outfile, level)
    outfile.write('Format=[\n')
    level += 1
    for Format_ in self.Format:
      showIndent(outfile, level)
      outfile.write('model_.Format(\n')
      Format_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.Format.append(obj_)
# end class Exception


class UserDefinedSymbolization(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, RemoteWFS=None, UserLayer=None, SupportSLD=None, UserStyle=None, valueOf_=None):
    self.RemoteWFS = _cast(None, RemoteWFS)
    self.UserLayer = _cast(None, UserLayer)
    self.SupportSLD = _cast(None, SupportSLD)
    self.UserStyle = _cast(None, UserStyle)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if UserDefinedSymbolization.subclass:
      return UserDefinedSymbolization.subclass(*args_, **kwargs_)
    else:
      return UserDefinedSymbolization(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_RemoteWFS(self): return self.RemoteWFS
  def set_RemoteWFS(self, RemoteWFS): self.RemoteWFS = RemoteWFS
  def get_UserLayer(self): return self.UserLayer
  def set_UserLayer(self, UserLayer): self.UserLayer = UserLayer
  def get_SupportSLD(self): return self.SupportSLD
  def set_SupportSLD(self, SupportSLD): self.SupportSLD = SupportSLD
  def get_UserStyle(self): return self.UserStyle
  def set_UserStyle(self, UserStyle): self.UserStyle = UserStyle
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='UserDefinedSymbolization', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='UserDefinedSymbolization')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserDefinedSymbolization'):
    if self.RemoteWFS is not None and 'RemoteWFS' not in already_processed:
      already_processed.append('RemoteWFS')
      outfile.write(' RemoteWFS=%s' % (self.gds_format_string(quote_attrib(self.RemoteWFS).encode(ExternalEncoding), input_name='RemoteWFS'), ))
    if self.UserLayer is not None and 'UserLayer' not in already_processed:
      already_processed.append('UserLayer')
      outfile.write(' UserLayer=%s' % (self.gds_format_string(quote_attrib(self.UserLayer).encode(ExternalEncoding), input_name='UserLayer'), ))
    if self.SupportSLD is not None and 'SupportSLD' not in already_processed:
      already_processed.append('SupportSLD')
      outfile.write(' SupportSLD=%s' % (self.gds_format_string(quote_attrib(self.SupportSLD).encode(ExternalEncoding), input_name='SupportSLD'), ))
    if self.UserStyle is not None and 'UserStyle' not in already_processed:
      already_processed.append('UserStyle')
      outfile.write(' UserStyle=%s' % (self.gds_format_string(quote_attrib(self.UserStyle).encode(ExternalEncoding), input_name='UserStyle'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='UserDefinedSymbolization', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='UserDefinedSymbolization'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.RemoteWFS is not None and 'RemoteWFS' not in already_processed:
      already_processed.append('RemoteWFS')
      showIndent(outfile, level)
      outfile.write('RemoteWFS = "%s",\n' % (self.RemoteWFS,))
    if self.UserLayer is not None and 'UserLayer' not in already_processed:
      already_processed.append('UserLayer')
      showIndent(outfile, level)
      outfile.write('UserLayer = "%s",\n' % (self.UserLayer,))
    if self.SupportSLD is not None and 'SupportSLD' not in already_processed:
      already_processed.append('SupportSLD')
      showIndent(outfile, level)
      outfile.write('SupportSLD = "%s",\n' % (self.SupportSLD,))
    if self.UserStyle is not None and 'UserStyle' not in already_processed:
      already_processed.append('UserStyle')
      showIndent(outfile, level)
      outfile.write('UserStyle = "%s",\n' % (self.UserStyle,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('RemoteWFS', node)
    if value is not None and 'RemoteWFS' not in already_processed:
      already_processed.append('RemoteWFS')
      self.RemoteWFS = value
    value = find_attr_value_('UserLayer', node)
    if value is not None and 'UserLayer' not in already_processed:
      already_processed.append('UserLayer')
      self.UserLayer = value
    value = find_attr_value_('SupportSLD', node)
    if value is not None and 'SupportSLD' not in already_processed:
      already_processed.append('SupportSLD')
      self.SupportSLD = value
    value = find_attr_value_('UserStyle', node)
    if value is not None and 'UserStyle' not in already_processed:
      already_processed.append('UserStyle')
      self.UserStyle = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class UserDefinedSymbolization


class Layer(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, opaque=None, cascaded=None, fixedHeight=None, fixedWidth=None, noSubsets=None, queryable=None, Name=None, Title=None, Abstract=None, KeywordList=None, SRS=None, LatLonBoundingBox=None, BoundingBox=None, Dimension=None, Extent=None, Attribution=None, AuthorityURL=None, Identifier=None, MetadataURL=None, DataURL=None, FeatureListURL=None, Style=None, ScaleHint=None, Layer=None):
    self.opaque = _cast(None, opaque)
    self.cascaded = _cast(None, cascaded)
    self.fixedHeight = _cast(None, fixedHeight)
    self.fixedWidth = _cast(None, fixedWidth)
    self.noSubsets = _cast(None, noSubsets)
    self.queryable = _cast(None, queryable)
    self.Name = Name
    self.Title = Title
    self.Abstract = Abstract
    self.KeywordList = KeywordList
    if SRS is None:
      self.SRS = []
    else:
      self.SRS = SRS
    self.LatLonBoundingBox = LatLonBoundingBox
    if BoundingBox is None:
      self.BoundingBox = []
    else:
      self.BoundingBox = BoundingBox
    if Dimension is None:
      self.Dimension = []
    else:
      self.Dimension = Dimension
    if Extent is None:
      self.Extent = []
    else:
      self.Extent = Extent
    self.Attribution = Attribution
    if AuthorityURL is None:
      self.AuthorityURL = []
    else:
      self.AuthorityURL = AuthorityURL
    if Identifier is None:
      self.Identifier = []
    else:
      self.Identifier = Identifier
    if MetadataURL is None:
      self.MetadataURL = []
    else:
      self.MetadataURL = MetadataURL
    if DataURL is None:
      self.DataURL = []
    else:
      self.DataURL = DataURL
    if FeatureListURL is None:
      self.FeatureListURL = []
    else:
      self.FeatureListURL = FeatureListURL
    if Style is None:
      self.Style = []
    else:
      self.Style = Style
    self.ScaleHint = ScaleHint
    if Layer is None:
      self.Layer = []
    else:
      self.Layer = Layer
  def factory(*args_, **kwargs_):
    if Layer.subclass:
      return Layer.subclass(*args_, **kwargs_)
    else:
      return Layer(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Name(self): return self.Name
  def set_Name(self, Name): self.Name = Name
  def get_Title(self): return self.Title
  def set_Title(self, Title): self.Title = Title
  def get_Abstract(self): return self.Abstract
  def set_Abstract(self, Abstract): self.Abstract = Abstract
  def get_KeywordList(self): return self.KeywordList
  def set_KeywordList(self, KeywordList): self.KeywordList = KeywordList
  def get_SRS(self): return self.SRS
  def set_SRS(self, SRS): self.SRS = SRS
  def add_SRS(self, value): self.SRS.append(value)
  def insert_SRS(self, index, value): self.SRS[index] = value
  def get_LatLonBoundingBox(self): return self.LatLonBoundingBox
  def set_LatLonBoundingBox(self, LatLonBoundingBox): self.LatLonBoundingBox = LatLonBoundingBox
  def get_BoundingBox(self): return self.BoundingBox
  def set_BoundingBox(self, BoundingBox): self.BoundingBox = BoundingBox
  def add_BoundingBox(self, value): self.BoundingBox.append(value)
  def insert_BoundingBox(self, index, value): self.BoundingBox[index] = value
  def get_Dimension(self): return self.Dimension
  def set_Dimension(self, Dimension): self.Dimension = Dimension
  def add_Dimension(self, value): self.Dimension.append(value)
  def insert_Dimension(self, index, value): self.Dimension[index] = value
  def get_Extent(self): return self.Extent
  def set_Extent(self, Extent): self.Extent = Extent
  def add_Extent(self, value): self.Extent.append(value)
  def insert_Extent(self, index, value): self.Extent[index] = value
  def get_Attribution(self): return self.Attribution
  def set_Attribution(self, Attribution): self.Attribution = Attribution
  def get_AuthorityURL(self): return self.AuthorityURL
  def set_AuthorityURL(self, AuthorityURL): self.AuthorityURL = AuthorityURL
  def add_AuthorityURL(self, value): self.AuthorityURL.append(value)
  def insert_AuthorityURL(self, index, value): self.AuthorityURL[index] = value
  def get_Identifier(self): return self.Identifier
  def set_Identifier(self, Identifier): self.Identifier = Identifier
  def add_Identifier(self, value): self.Identifier.append(value)
  def insert_Identifier(self, index, value): self.Identifier[index] = value
  def get_MetadataURL(self): return self.MetadataURL
  def set_MetadataURL(self, MetadataURL): self.MetadataURL = MetadataURL
  def add_MetadataURL(self, value): self.MetadataURL.append(value)
  def insert_MetadataURL(self, index, value): self.MetadataURL[index] = value
  def get_DataURL(self): return self.DataURL
  def set_DataURL(self, DataURL): self.DataURL = DataURL
  def add_DataURL(self, value): self.DataURL.append(value)
  def insert_DataURL(self, index, value): self.DataURL[index] = value
  def get_FeatureListURL(self): return self.FeatureListURL
  def set_FeatureListURL(self, FeatureListURL): self.FeatureListURL = FeatureListURL
  def add_FeatureListURL(self, value): self.FeatureListURL.append(value)
  def insert_FeatureListURL(self, index, value): self.FeatureListURL[index] = value
  def get_Style(self): return self.Style
  def set_Style(self, Style): self.Style = Style
  def add_Style(self, value): self.Style.append(value)
  def insert_Style(self, index, value): self.Style[index] = value
  def get_ScaleHint(self): return self.ScaleHint
  def set_ScaleHint(self, ScaleHint): self.ScaleHint = ScaleHint
  def get_Layer(self): return self.Layer
  def set_Layer(self, Layer): self.Layer = Layer
  def add_Layer(self, value): self.Layer.append(value)
  def insert_Layer(self, index, value): self.Layer[index] = value
  def get_opaque(self): return self.opaque
  def set_opaque(self, opaque): self.opaque = opaque
  def get_cascaded(self): return self.cascaded
  def set_cascaded(self, cascaded): self.cascaded = cascaded
  def get_fixedHeight(self): return self.fixedHeight
  def set_fixedHeight(self, fixedHeight): self.fixedHeight = fixedHeight
  def get_fixedWidth(self): return self.fixedWidth
  def set_fixedWidth(self, fixedWidth): self.fixedWidth = fixedWidth
  def get_noSubsets(self): return self.noSubsets
  def set_noSubsets(self, noSubsets): self.noSubsets = noSubsets
  def get_queryable(self): return self.queryable
  def set_queryable(self, queryable): self.queryable = queryable
  def export(self, outfile, level, namespace_='', name_='Layer', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Layer')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Layer'):
    if self.opaque is not None and 'opaque' not in already_processed:
      already_processed.append('opaque')
      outfile.write(' opaque=%s' % (self.gds_format_string(quote_attrib(self.opaque).encode(ExternalEncoding), input_name='opaque'), ))
    if self.cascaded is not None and 'cascaded' not in already_processed:
      already_processed.append('cascaded')
      outfile.write(' cascaded=%s' % (self.gds_format_string(quote_attrib(self.cascaded).encode(ExternalEncoding), input_name='cascaded'), ))
    if self.fixedHeight is not None and 'fixedHeight' not in already_processed:
      already_processed.append('fixedHeight')
      outfile.write(' fixedHeight=%s' % (self.gds_format_string(quote_attrib(self.fixedHeight).encode(ExternalEncoding), input_name='fixedHeight'), ))
    if self.fixedWidth is not None and 'fixedWidth' not in already_processed:
      already_processed.append('fixedWidth')
      outfile.write(' fixedWidth=%s' % (self.gds_format_string(quote_attrib(self.fixedWidth).encode(ExternalEncoding), input_name='fixedWidth'), ))
    if self.noSubsets is not None and 'noSubsets' not in already_processed:
      already_processed.append('noSubsets')
      outfile.write(' noSubsets=%s' % (self.gds_format_string(quote_attrib(self.noSubsets).encode(ExternalEncoding), input_name='noSubsets'), ))
    if self.queryable is not None and 'queryable' not in already_processed:
      already_processed.append('queryable')
      outfile.write(' queryable=%s' % (self.gds_format_string(quote_attrib(self.queryable).encode(ExternalEncoding), input_name='queryable'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='Layer', fromsubclass_=False):
    if self.Name is not None:
      showIndent(outfile, level)
      outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
    if self.Title:
      self.Title.export(outfile, level, namespace_, name_='Title', )
    if self.Abstract:
      self.Abstract.export(outfile, level, namespace_, name_='Abstract')
    if self.KeywordList:
      self.KeywordList.export(outfile, level, namespace_, name_='KeywordList')
    for SRS_ in self.SRS:
      SRS_.export(outfile, level, namespace_, name_='SRS')
    if self.LatLonBoundingBox:
      self.LatLonBoundingBox.export(outfile, level, namespace_, name_='LatLonBoundingBox')
    for BoundingBox_ in self.BoundingBox:
      BoundingBox_.export(outfile, level, namespace_, name_='BoundingBox')
    for Dimension_ in self.Dimension:
      Dimension_.export(outfile, level, namespace_, name_='Dimension')
    for Extent_ in self.Extent:
      Extent_.export(outfile, level, namespace_, name_='Extent')
    if self.Attribution:
      self.Attribution.export(outfile, level, namespace_, name_='Attribution')
    for AuthorityURL_ in self.AuthorityURL:
      AuthorityURL_.export(outfile, level, namespace_, name_='AuthorityURL')
    for Identifier_ in self.Identifier:
      Identifier_.export(outfile, level, namespace_, name_='Identifier')
    for MetadataURL_ in self.MetadataURL:
      MetadataURL_.export(outfile, level, namespace_, name_='MetadataURL')
    for DataURL_ in self.DataURL:
      DataURL_.export(outfile, level, namespace_, name_='DataURL')
    for FeatureListURL_ in self.FeatureListURL:
      FeatureListURL_.export(outfile, level, namespace_, name_='FeatureListURL')
    for Style_ in self.Style:
      Style_.export(outfile, level, namespace_, name_='Style')
    if self.ScaleHint:
      self.ScaleHint.export(outfile, level, namespace_, name_='ScaleHint')
    for Layer_ in self.Layer:
      Layer_.export(outfile, level, namespace_, name_='Layer')
  def hasContent_(self):
    if (
        self.Name is not None or
        self.Title is not None or
        self.Abstract is not None or
        self.KeywordList is not None or
        self.SRS or
        self.LatLonBoundingBox is not None or
        self.BoundingBox or
        self.Dimension or
        self.Extent or
        self.Attribution is not None or
        self.AuthorityURL or
        self.Identifier or
        self.MetadataURL or
        self.DataURL or
        self.FeatureListURL or
        self.Style or
        self.ScaleHint is not None or
        self.Layer
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Layer'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.opaque is not None and 'opaque' not in already_processed:
      already_processed.append('opaque')
      showIndent(outfile, level)
      outfile.write('opaque = "%s",\n' % (self.opaque,))
    if self.cascaded is not None and 'cascaded' not in already_processed:
      already_processed.append('cascaded')
      showIndent(outfile, level)
      outfile.write('cascaded = "%s",\n' % (self.cascaded,))
    if self.fixedHeight is not None and 'fixedHeight' not in already_processed:
      already_processed.append('fixedHeight')
      showIndent(outfile, level)
      outfile.write('fixedHeight = "%s",\n' % (self.fixedHeight,))
    if self.fixedWidth is not None and 'fixedWidth' not in already_processed:
      already_processed.append('fixedWidth')
      showIndent(outfile, level)
      outfile.write('fixedWidth = "%s",\n' % (self.fixedWidth,))
    if self.noSubsets is not None and 'noSubsets' not in already_processed:
      already_processed.append('noSubsets')
      showIndent(outfile, level)
      outfile.write('noSubsets = "%s",\n' % (self.noSubsets,))
    if self.queryable is not None and 'queryable' not in already_processed:
      already_processed.append('queryable')
      showIndent(outfile, level)
      outfile.write('queryable = "%s",\n' % (self.queryable,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Name is not None:
      showIndent(outfile, level)
      outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    if self.Title is not None:
      showIndent(outfile, level)
      outfile.write('Title=model_.Title(\n')
      self.Title.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Abstract is not None:
      showIndent(outfile, level)
      outfile.write('Abstract=model_.Abstract(\n')
      self.Abstract.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.KeywordList is not None:
      showIndent(outfile, level)
      outfile.write('KeywordList=model_.KeywordList(\n')
      self.KeywordList.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('SRS=[\n')
    level += 1
    for SRS_ in self.SRS:
      showIndent(outfile, level)
      outfile.write('model_.SRS(\n')
      SRS_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.LatLonBoundingBox is not None:
      showIndent(outfile, level)
      outfile.write('LatLonBoundingBox=model_.LatLonBoundingBox(\n')
      self.LatLonBoundingBox.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('BoundingBox=[\n')
    level += 1
    for BoundingBox_ in self.BoundingBox:
      showIndent(outfile, level)
      outfile.write('model_.BoundingBox(\n')
      BoundingBox_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Dimension=[\n')
    level += 1
    for Dimension_ in self.Dimension:
      showIndent(outfile, level)
      outfile.write('model_.Dimension(\n')
      Dimension_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Extent=[\n')
    level += 1
    for Extent_ in self.Extent:
      showIndent(outfile, level)
      outfile.write('model_.Extent(\n')
      Extent_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.Attribution is not None:
      showIndent(outfile, level)
      outfile.write('Attribution=model_.Attribution(\n')
      self.Attribution.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('AuthorityURL=[\n')
    level += 1
    for AuthorityURL_ in self.AuthorityURL:
      showIndent(outfile, level)
      outfile.write('model_.AuthorityURL(\n')
      AuthorityURL_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Identifier=[\n')
    level += 1
    for Identifier_ in self.Identifier:
      showIndent(outfile, level)
      outfile.write('model_.Identifier(\n')
      Identifier_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('MetadataURL=[\n')
    level += 1
    for MetadataURL_ in self.MetadataURL:
      showIndent(outfile, level)
      outfile.write('model_.MetadataURL(\n')
      MetadataURL_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('DataURL=[\n')
    level += 1
    for DataURL_ in self.DataURL:
      showIndent(outfile, level)
      outfile.write('model_.DataURL(\n')
      DataURL_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('FeatureListURL=[\n')
    level += 1
    for FeatureListURL_ in self.FeatureListURL:
      showIndent(outfile, level)
      outfile.write('model_.FeatureListURL(\n')
      FeatureListURL_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    showIndent(outfile, level)
    outfile.write('Style=[\n')
    level += 1
    for Style_ in self.Style:
      showIndent(outfile, level)
      outfile.write('model_.Style(\n')
      Style_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.ScaleHint is not None:
      showIndent(outfile, level)
      outfile.write('ScaleHint=model_.ScaleHint(\n')
      self.ScaleHint.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('Layer=[\n')
    level += 1
    for Layer_ in self.Layer:
      showIndent(outfile, level)
      outfile.write('model_.Layer(\n')
      Layer_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('opaque', node)
    if value is not None and 'opaque' not in already_processed:
      already_processed.append('opaque')
      self.opaque = value
    value = find_attr_value_('cascaded', node)
    if value is not None and 'cascaded' not in already_processed:
      already_processed.append('cascaded')
      self.cascaded = value
    value = find_attr_value_('fixedHeight', node)
    if value is not None and 'fixedHeight' not in already_processed:
      already_processed.append('fixedHeight')
      self.fixedHeight = value
    value = find_attr_value_('fixedWidth', node)
    if value is not None and 'fixedWidth' not in already_processed:
      already_processed.append('fixedWidth')
      self.fixedWidth = value
    value = find_attr_value_('noSubsets', node)
    if value is not None and 'noSubsets' not in already_processed:
      already_processed.append('noSubsets')
      self.noSubsets = value
    value = find_attr_value_('queryable', node)
    if value is not None and 'queryable' not in already_processed:
      already_processed.append('queryable')
      self.queryable = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Name':
      Name_ = child_.text
      Name_ = self.gds_validate_string(Name_, node, 'Name')
      self.Name = Name_
    elif nodeName_ == 'Title':
      obj_ = Title.factory()
      obj_.build(child_)
      self.set_Title(obj_)
    elif nodeName_ == 'Abstract':
      obj_ = Abstract.factory()
      obj_.build(child_)
      self.set_Abstract(obj_)
    elif nodeName_ == 'KeywordList':
      obj_ = KeywordList.factory()
      obj_.build(child_)
      self.set_KeywordList(obj_)
    elif nodeName_ == 'SRS':
      obj_ = SRS.factory()
      obj_.build(child_)
      self.SRS.append(obj_)
    elif nodeName_ == 'LatLonBoundingBox':
      obj_ = LatLonBoundingBox.factory()
      obj_.build(child_)
      self.set_LatLonBoundingBox(obj_)
    elif nodeName_ == 'BoundingBox':
      obj_ = BoundingBox.factory()
      obj_.build(child_)
      self.BoundingBox.append(obj_)
    elif nodeName_ == 'Dimension':
      obj_ = Dimension.factory()
      obj_.build(child_)
      self.Dimension.append(obj_)
    elif nodeName_ == 'Extent':
      obj_ = Extent.factory()
      obj_.build(child_)
      self.Extent.append(obj_)
    elif nodeName_ == 'Attribution':
      obj_ = Attribution.factory()
      obj_.build(child_)
      self.set_Attribution(obj_)
    elif nodeName_ == 'AuthorityURL':
      obj_ = AuthorityURL.factory()
      obj_.build(child_)
      self.AuthorityURL.append(obj_)
    elif nodeName_ == 'Identifier':
      obj_ = Identifier.factory()
      obj_.build(child_)
      self.Identifier.append(obj_)
    elif nodeName_ == 'MetadataURL':
      obj_ = MetadataURL.factory()
      obj_.build(child_)
      self.MetadataURL.append(obj_)
    elif nodeName_ == 'DataURL':
      obj_ = DataURL.factory()
      obj_.build(child_)
      self.DataURL.append(obj_)
    elif nodeName_ == 'FeatureListURL':
      obj_ = FeatureListURL.factory()
      obj_.build(child_)
      self.FeatureListURL.append(obj_)
    elif nodeName_ == 'Style':
      obj_ = Style.factory()
      obj_.build(child_)
      self.Style.append(obj_)
    elif nodeName_ == 'ScaleHint':
      obj_ = ScaleHint.factory()
      obj_.build(child_)
      self.set_ScaleHint(obj_)
    elif nodeName_ == 'Layer':
      obj_ = Layer.factory()
      obj_.build(child_)
      self.Layer.append(obj_)
# end class Layer


class SRS(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if SRS.subclass:
      return SRS.subclass(*args_, **kwargs_)
    else:
      return SRS(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='SRS', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='SRS')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SRS'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='SRS', fromsubclass_=False):
    outfile.write(self.gds_format_string(quote_xml(self.valueOf_).encode(ExternalEncoding)))
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='SRS'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class SRS


class LatLonBoundingBox(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, minx=None, miny=None, maxx=None, maxy=None, valueOf_=None):
    self.minx = _cast(None, minx)
    self.miny = _cast(None, miny)
    self.maxx = _cast(None, maxx)
    self.maxy = _cast(None, maxy)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if LatLonBoundingBox.subclass:
      return LatLonBoundingBox.subclass(*args_, **kwargs_)
    else:
      return LatLonBoundingBox(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_minx(self): return self.minx
  def set_minx(self, minx): self.minx = minx
  def get_miny(self): return self.miny
  def set_miny(self, miny): self.miny = miny
  def get_maxx(self): return self.maxx
  def set_maxx(self, maxx): self.maxx = maxx
  def get_maxy(self): return self.maxy
  def set_maxy(self, maxy): self.maxy = maxy
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='LatLonBoundingBox', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='LatLonBoundingBox')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LatLonBoundingBox'):
    if self.minx is not None and 'minx' not in already_processed:
      already_processed.append('minx')
      outfile.write(' minx=%s' % (self.gds_format_string(quote_attrib(self.minx).encode(ExternalEncoding), input_name='minx'), ))
    if self.miny is not None and 'miny' not in already_processed:
      already_processed.append('miny')
      outfile.write(' miny=%s' % (self.gds_format_string(quote_attrib(self.miny).encode(ExternalEncoding), input_name='miny'), ))
    if self.maxx is not None and 'maxx' not in already_processed:
      already_processed.append('maxx')
      outfile.write(' maxx=%s' % (self.gds_format_string(quote_attrib(self.maxx).encode(ExternalEncoding), input_name='maxx'), ))
    if self.maxy is not None and 'maxy' not in already_processed:
      already_processed.append('maxy')
      outfile.write(' maxy=%s' % (self.gds_format_string(quote_attrib(self.maxy).encode(ExternalEncoding), input_name='maxy'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='LatLonBoundingBox', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='LatLonBoundingBox'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.minx is not None and 'minx' not in already_processed:
      already_processed.append('minx')
      showIndent(outfile, level)
      outfile.write('minx = "%s",\n' % (self.minx,))
    if self.miny is not None and 'miny' not in already_processed:
      already_processed.append('miny')
      showIndent(outfile, level)
      outfile.write('miny = "%s",\n' % (self.miny,))
    if self.maxx is not None and 'maxx' not in already_processed:
      already_processed.append('maxx')
      showIndent(outfile, level)
      outfile.write('maxx = "%s",\n' % (self.maxx,))
    if self.maxy is not None and 'maxy' not in already_processed:
      already_processed.append('maxy')
      showIndent(outfile, level)
      outfile.write('maxy = "%s",\n' % (self.maxy,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('minx', node)
    if value is not None and 'minx' not in already_processed:
      already_processed.append('minx')
      self.minx = value
    value = find_attr_value_('miny', node)
    if value is not None and 'miny' not in already_processed:
      already_processed.append('miny')
      self.miny = value
    value = find_attr_value_('maxx', node)
    if value is not None and 'maxx' not in already_processed:
      already_processed.append('maxx')
      self.maxx = value
    value = find_attr_value_('maxy', node)
    if value is not None and 'maxy' not in already_processed:
      already_processed.append('maxy')
      self.maxy = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class LatLonBoundingBox


class BoundingBox(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, maxx=None, maxy=None, miny=None, resx=None, minx=None, SRS=None, resy=None, valueOf_=None):
    self.maxx = _cast(None, maxx)
    self.maxy = _cast(None, maxy)
    self.miny = _cast(None, miny)
    self.resx = _cast(None, resx)
    self.minx = _cast(None, minx)
    self.SRS = _cast(None, SRS)
    self.resy = _cast(None, resy)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if BoundingBox.subclass:
      return BoundingBox.subclass(*args_, **kwargs_)
    else:
      return BoundingBox(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_maxx(self): return self.maxx
  def set_maxx(self, maxx): self.maxx = maxx
  def get_maxy(self): return self.maxy
  def set_maxy(self, maxy): self.maxy = maxy
  def get_miny(self): return self.miny
  def set_miny(self, miny): self.miny = miny
  def get_resx(self): return self.resx
  def set_resx(self, resx): self.resx = resx
  def get_minx(self): return self.minx
  def set_minx(self, minx): self.minx = minx
  def get_SRS(self): return self.SRS
  def set_SRS(self, SRS): self.SRS = SRS
  def get_resy(self): return self.resy
  def set_resy(self, resy): self.resy = resy
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='BoundingBox', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='BoundingBox')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundingBox'):
    if self.maxx is not None and 'maxx' not in already_processed:
      already_processed.append('maxx')
      outfile.write(' maxx=%s' % (self.gds_format_string(quote_attrib(self.maxx).encode(ExternalEncoding), input_name='maxx'), ))
    if self.maxy is not None and 'maxy' not in already_processed:
      already_processed.append('maxy')
      outfile.write(' maxy=%s' % (self.gds_format_string(quote_attrib(self.maxy).encode(ExternalEncoding), input_name='maxy'), ))
    if self.miny is not None and 'miny' not in already_processed:
      already_processed.append('miny')
      outfile.write(' miny=%s' % (self.gds_format_string(quote_attrib(self.miny).encode(ExternalEncoding), input_name='miny'), ))
    if self.resx is not None and 'resx' not in already_processed:
      already_processed.append('resx')
      outfile.write(' resx=%s' % (self.gds_format_string(quote_attrib(self.resx).encode(ExternalEncoding), input_name='resx'), ))
    if self.minx is not None and 'minx' not in already_processed:
      already_processed.append('minx')
      outfile.write(' minx=%s' % (self.gds_format_string(quote_attrib(self.minx).encode(ExternalEncoding), input_name='minx'), ))
    if self.SRS is not None and 'SRS' not in already_processed:
      already_processed.append('SRS')
      outfile.write(' SRS=%s' % (self.gds_format_string(quote_attrib(self.SRS).encode(ExternalEncoding), input_name='SRS'), ))
    if self.resy is not None and 'resy' not in already_processed:
      already_processed.append('resy')
      outfile.write(' resy=%s' % (self.gds_format_string(quote_attrib(self.resy).encode(ExternalEncoding), input_name='resy'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='BoundingBox', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='BoundingBox'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.maxx is not None and 'maxx' not in already_processed:
      already_processed.append('maxx')
      showIndent(outfile, level)
      outfile.write('maxx = "%s",\n' % (self.maxx,))
    if self.maxy is not None and 'maxy' not in already_processed:
      already_processed.append('maxy')
      showIndent(outfile, level)
      outfile.write('maxy = "%s",\n' % (self.maxy,))
    if self.miny is not None and 'miny' not in already_processed:
      already_processed.append('miny')
      showIndent(outfile, level)
      outfile.write('miny = "%s",\n' % (self.miny,))
    if self.resx is not None and 'resx' not in already_processed:
      already_processed.append('resx')
      showIndent(outfile, level)
      outfile.write('resx = "%s",\n' % (self.resx,))
    if self.minx is not None and 'minx' not in already_processed:
      already_processed.append('minx')
      showIndent(outfile, level)
      outfile.write('minx = "%s",\n' % (self.minx,))
    if self.SRS is not None and 'SRS' not in already_processed:
      already_processed.append('SRS')
      showIndent(outfile, level)
      outfile.write('SRS = "%s",\n' % (self.SRS,))
    if self.resy is not None and 'resy' not in already_processed:
      already_processed.append('resy')
      showIndent(outfile, level)
      outfile.write('resy = "%s",\n' % (self.resy,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('maxx', node)
    if value is not None and 'maxx' not in already_processed:
      already_processed.append('maxx')
      self.maxx = value
    value = find_attr_value_('maxy', node)
    if value is not None and 'maxy' not in already_processed:
      already_processed.append('maxy')
      self.maxy = value
    value = find_attr_value_('miny', node)
    if value is not None and 'miny' not in already_processed:
      already_processed.append('miny')
      self.miny = value
    value = find_attr_value_('resx', node)
    if value is not None and 'resx' not in already_processed:
      already_processed.append('resx')
      self.resx = value
    value = find_attr_value_('minx', node)
    if value is not None and 'minx' not in already_processed:
      already_processed.append('minx')
      self.minx = value
    value = find_attr_value_('SRS', node)
    if value is not None and 'SRS' not in already_processed:
      already_processed.append('SRS')
      self.SRS = value
    value = find_attr_value_('resy', node)
    if value is not None and 'resy' not in already_processed:
      already_processed.append('resy')
      self.resy = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class BoundingBox


class Dimension(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, units=None, unitSymbol=None, name=None, valueOf_=None):
    self.units = _cast(None, units)
    self.unitSymbol = _cast(None, unitSymbol)
    self.name = _cast(None, name)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Dimension.subclass:
      return Dimension.subclass(*args_, **kwargs_)
    else:
      return Dimension(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_units(self): return self.units
  def set_units(self, units): self.units = units
  def get_unitSymbol(self): return self.unitSymbol
  def set_unitSymbol(self, unitSymbol): self.unitSymbol = unitSymbol
  def get_name(self): return self.name
  def set_name(self, name): self.name = name
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Dimension', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Dimension')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Dimension'):
    if self.units is not None and 'units' not in already_processed:
      already_processed.append('units')
      outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    if self.unitSymbol is not None and 'unitSymbol' not in already_processed:
      already_processed.append('unitSymbol')
      outfile.write(' unitSymbol=%s' % (self.gds_format_string(quote_attrib(self.unitSymbol).encode(ExternalEncoding), input_name='unitSymbol'), ))
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='Dimension', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Dimension'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.units is not None and 'units' not in already_processed:
      already_processed.append('units')
      showIndent(outfile, level)
      outfile.write('units = "%s",\n' % (self.units,))
    if self.unitSymbol is not None and 'unitSymbol' not in already_processed:
      already_processed.append('unitSymbol')
      showIndent(outfile, level)
      outfile.write('unitSymbol = "%s",\n' % (self.unitSymbol,))
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      showIndent(outfile, level)
      outfile.write('name = "%s",\n' % (self.name,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('units', node)
    if value is not None and 'units' not in already_processed:
      already_processed.append('units')
      self.units = value
    value = find_attr_value_('unitSymbol', node)
    if value is not None and 'unitSymbol' not in already_processed:
      already_processed.append('unitSymbol')
      self.unitSymbol = value
    value = find_attr_value_('name', node)
    if value is not None and 'name' not in already_processed:
      already_processed.append('name')
      self.name = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class Dimension


class Extent(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, default=None, multipleValues=None, current=None, name=None, nearestValue=None, valueOf_=None, mixedclass_=None, content_=None):
    self.default = _cast(None, default)
    self.multipleValues = _cast(None, multipleValues)
    self.current = _cast(None, current)
    self.name = _cast(None, name)
    self.nearestValue = _cast(None, nearestValue)
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Extent.subclass:
      return Extent.subclass(*args_, **kwargs_)
    else:
      return Extent(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_default(self): return self.default
  def set_default(self, default): self.default = default
  def get_multipleValues(self): return self.multipleValues
  def set_multipleValues(self, multipleValues): self.multipleValues = multipleValues
  def get_current(self): return self.current
  def set_current(self, current): self.current = current
  def get_name(self): return self.name
  def set_name(self, name): self.name = name
  def get_nearestValue(self): return self.nearestValue
  def set_nearestValue(self, nearestValue): self.nearestValue = nearestValue
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Extent', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Extent')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Extent'):
    if self.default is not None and 'default' not in already_processed:
      already_processed.append('default')
      outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
    if self.multipleValues is not None and 'multipleValues' not in already_processed:
      already_processed.append('multipleValues')
      outfile.write(' multipleValues=%s' % (self.gds_format_string(quote_attrib(self.multipleValues).encode(ExternalEncoding), input_name='multipleValues'), ))
    if self.current is not None and 'current' not in already_processed:
      already_processed.append('current')
      outfile.write(' current=%s' % (self.gds_format_string(quote_attrib(self.current).encode(ExternalEncoding), input_name='current'), ))
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    if self.nearestValue is not None and 'nearestValue' not in already_processed:
      already_processed.append('nearestValue')
      outfile.write(' nearestValue=%s' % (self.gds_format_string(quote_attrib(self.nearestValue).encode(ExternalEncoding), input_name='nearestValue'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='Extent', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Extent'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.default is not None and 'default' not in already_processed:
      already_processed.append('default')
      showIndent(outfile, level)
      outfile.write('default = "%s",\n' % (self.default,))
    if self.multipleValues is not None and 'multipleValues' not in already_processed:
      already_processed.append('multipleValues')
      showIndent(outfile, level)
      outfile.write('multipleValues = "%s",\n' % (self.multipleValues,))
    if self.current is not None and 'current' not in already_processed:
      already_processed.append('current')
      showIndent(outfile, level)
      outfile.write('current = "%s",\n' % (self.current,))
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      showIndent(outfile, level)
      outfile.write('name = "%s",\n' % (self.name,))
    if self.nearestValue is not None and 'nearestValue' not in already_processed:
      already_processed.append('nearestValue')
      showIndent(outfile, level)
      outfile.write('nearestValue = "%s",\n' % (self.nearestValue,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('default', node)
    if value is not None and 'default' not in already_processed:
      already_processed.append('default')
      self.default = value
    value = find_attr_value_('multipleValues', node)
    if value is not None and 'multipleValues' not in already_processed:
      already_processed.append('multipleValues')
      self.multipleValues = value
    value = find_attr_value_('current', node)
    if value is not None and 'current' not in already_processed:
      already_processed.append('current')
      self.current = value
    value = find_attr_value_('name', node)
    if value is not None and 'name' not in already_processed:
      already_processed.append('name')
      self.name = value
    value = find_attr_value_('nearestValue', node)
    if value is not None and 'nearestValue' not in already_processed:
      already_processed.append('nearestValue')
      self.nearestValue = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Extent


class Attribution(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Title=None, OnlineResource=None, LogoURL=None):
    self.Title = Title
    self.OnlineResource = OnlineResource
    self.LogoURL = LogoURL
  def factory(*args_, **kwargs_):
    if Attribution.subclass:
      return Attribution.subclass(*args_, **kwargs_)
    else:
      return Attribution(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Title(self): return self.Title
  def set_Title(self, Title): self.Title = Title
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_LogoURL(self): return self.LogoURL
  def set_LogoURL(self, LogoURL): self.LogoURL = LogoURL
  def export(self, outfile, level, namespace_='', name_='Attribution', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Attribution')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Attribution'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Attribution', fromsubclass_=False):
    if self.Title:
      self.Title.export(outfile, level, namespace_, name_='Title')
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource')
    if self.LogoURL:
      self.LogoURL.export(outfile, level, namespace_, name_='LogoURL')
  def hasContent_(self):
    if (
        self.Title is not None or
        self.OnlineResource is not None or
        self.LogoURL is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Attribution'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Title is not None:
      showIndent(outfile, level)
      outfile.write('Title=model_.Title(\n')
      self.Title.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.LogoURL is not None:
      showIndent(outfile, level)
      outfile.write('LogoURL=model_.LogoURL(\n')
      self.LogoURL.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Title':
      obj_ = Title.factory()
      obj_.build(child_)
      self.set_Title(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
    elif nodeName_ == 'LogoURL':
      obj_ = LogoURL.factory()
      obj_.build(child_)
      self.set_LogoURL(obj_)
# end class Attribution


class LogoURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, width=None, height=None, Format=None, OnlineResource=None):
    self.width = _cast(None, width)
    self.height = _cast(None, height)
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if LogoURL.subclass:
      return LogoURL.subclass(*args_, **kwargs_)
    else:
      return LogoURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_width(self): return self.width
  def set_width(self, width): self.width = width
  def get_height(self): return self.height
  def set_height(self, height): self.height = height
  def export(self, outfile, level, namespace_='', name_='LogoURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='LogoURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogoURL'):
    if self.width is not None and 'width' not in already_processed:
      already_processed.append('width')
      outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
    if self.height is not None and 'height' not in already_processed:
      already_processed.append('height')
      outfile.write(' height=%s' % (self.gds_format_string(quote_attrib(self.height).encode(ExternalEncoding), input_name='height'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='LogoURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='LogoURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.width is not None and 'width' not in already_processed:
      already_processed.append('width')
      showIndent(outfile, level)
      outfile.write('width = "%s",\n' % (self.width,))
    if self.height is not None and 'height' not in already_processed:
      already_processed.append('height')
      showIndent(outfile, level)
      outfile.write('height = "%s",\n' % (self.height,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('width', node)
    if value is not None and 'width' not in already_processed:
      already_processed.append('width')
      self.width = value
    value = find_attr_value_('height', node)
    if value is not None and 'height' not in already_processed:
      already_processed.append('height')
      self.height = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class LogoURL


class MetadataURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, type_=None, Format=None, OnlineResource=None):
    self.type_ = _cast(None, type_)
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if MetadataURL.subclass:
      return MetadataURL.subclass(*args_, **kwargs_)
    else:
      return MetadataURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_type(self): return self.type_
  def set_type(self, type_): self.type_ = type_
  def export(self, outfile, level, namespace_='', name_='MetadataURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='MetadataURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataURL'):
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='MetadataURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='MetadataURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.type_ is not None and 'type_' not in already_processed:
      already_processed.append('type_')
      showIndent(outfile, level)
      outfile.write('type_ = "%s",\n' % (self.type_,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('type', node)
    if value is not None and 'type' not in already_processed:
      already_processed.append('type')
      self.type_ = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class MetadataURL


class AuthorityURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, name=None, OnlineResource=None):
    self.name = _cast(None, name)
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if AuthorityURL.subclass:
      return AuthorityURL.subclass(*args_, **kwargs_)
    else:
      return AuthorityURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_name(self): return self.name
  def set_name(self, name): self.name = name
  def export(self, outfile, level, namespace_='', name_='AuthorityURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='AuthorityURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AuthorityURL'):
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='AuthorityURL', fromsubclass_=False):
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='AuthorityURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.name is not None and 'name' not in already_processed:
      already_processed.append('name')
      showIndent(outfile, level)
      outfile.write('name = "%s",\n' % (self.name,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('name', node)
    if value is not None and 'name' not in already_processed:
      already_processed.append('name')
      self.name = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class AuthorityURL


class Identifier(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, authority=None, valueOf_=None, mixedclass_=None, content_=None):
    self.authority = _cast(None, authority)
    self.valueOf_ = valueOf_
    if mixedclass_ is None:
      self.mixedclass_ = MixedContainer
    else:
      self.mixedclass_ = mixedclass_
    if content_ is None:
      self.content_ = []
    else:
      self.content_ = content_
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if Identifier.subclass:
      return Identifier.subclass(*args_, **kwargs_)
    else:
      return Identifier(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_authority(self): return self.authority
  def set_authority(self, authority): self.authority = authority
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='Identifier', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Identifier')
    outfile.write('>')
    self.exportChildren(outfile, level + 1, namespace_, name_)
    outfile.write('</%s%s>\n' % (namespace_, name_))
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Identifier'):
    if self.authority is not None and 'authority' not in already_processed:
      already_processed.append('authority')
      outfile.write(' authority=%s' % (self.gds_format_string(quote_attrib(self.authority).encode(ExternalEncoding), input_name='authority'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='Identifier', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Identifier'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.authority is not None and 'authority' not in already_processed:
      already_processed.append('authority')
      showIndent(outfile, level)
      outfile.write('authority = "%s",\n' % (self.authority,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    if node.text is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', node.text)
      self.content_.append(obj_)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('authority', node)
    if value is not None and 'authority' not in already_processed:
      already_processed.append('authority')
      self.authority = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if not fromsubclass_ and child_.tail is not None:
      obj_ = self.mixedclass_(MixedContainer.CategoryText,
          MixedContainer.TypeNone, '', child_.tail)
      self.content_.append(obj_)
    pass
# end class Identifier


class DataURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, OnlineResource=None):
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if DataURL.subclass:
      return DataURL.subclass(*args_, **kwargs_)
    else:
      return DataURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def export(self, outfile, level, namespace_='', name_='DataURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='DataURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataURL'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='DataURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='DataURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class DataURL


class FeatureListURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, OnlineResource=None):
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if FeatureListURL.subclass:
      return FeatureListURL.subclass(*args_, **kwargs_)
    else:
      return FeatureListURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def export(self, outfile, level, namespace_='', name_='FeatureListURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='FeatureListURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeatureListURL'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='FeatureListURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='FeatureListURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class FeatureListURL


class Style(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Name=None, Title=None, Abstract=None, LegendURL=None, StyleSheetURL=None, StyleURL=None):
    self.Name = Name
    self.Title = Title
    self.Abstract = Abstract
    if LegendURL is None:
      self.LegendURL = []
    else:
      self.LegendURL = LegendURL
    self.StyleSheetURL = StyleSheetURL
    self.StyleURL = StyleURL
  def factory(*args_, **kwargs_):
    if Style.subclass:
      return Style.subclass(*args_, **kwargs_)
    else:
      return Style(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Name(self): return self.Name
  def set_Name(self, Name): self.Name = Name
  def get_Title(self): return self.Title
  def set_Title(self, Title): self.Title = Title
  def get_Abstract(self): return self.Abstract
  def set_Abstract(self, Abstract): self.Abstract = Abstract
  def get_LegendURL(self): return self.LegendURL
  def set_LegendURL(self, LegendURL): self.LegendURL = LegendURL
  def add_LegendURL(self, value): self.LegendURL.append(value)
  def insert_LegendURL(self, index, value): self.LegendURL[index] = value
  def get_StyleSheetURL(self): return self.StyleSheetURL
  def set_StyleSheetURL(self, StyleSheetURL): self.StyleSheetURL = StyleSheetURL
  def get_StyleURL(self): return self.StyleURL
  def set_StyleURL(self, StyleURL): self.StyleURL = StyleURL
  def export(self, outfile, level, namespace_='', name_='Style', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='Style')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Style'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='Style', fromsubclass_=False):
    if self.Name is not None:
      showIndent(outfile, level)
      outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
    if self.Title:
      self.Title.export(outfile, level, namespace_, name_='Title', )
    if self.Abstract:
      self.Abstract.export(outfile, level, namespace_, name_='Abstract')
    for LegendURL_ in self.LegendURL:
      LegendURL_.export(outfile, level, namespace_, name_='LegendURL')
    if self.StyleSheetURL:
      self.StyleSheetURL.export(outfile, level, namespace_, name_='StyleSheetURL')
    if self.StyleURL:
      self.StyleURL.export(outfile, level, namespace_, name_='StyleURL')
  def hasContent_(self):
    if (
        self.Name is not None or
        self.Title is not None or
        self.Abstract is not None or
        self.LegendURL or
        self.StyleSheetURL is not None or
        self.StyleURL is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='Style'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Name is not None:
      showIndent(outfile, level)
      outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    if self.Title is not None:
      showIndent(outfile, level)
      outfile.write('Title=model_.Title(\n')
      self.Title.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.Abstract is not None:
      showIndent(outfile, level)
      outfile.write('Abstract=model_.Abstract(\n')
      self.Abstract.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    showIndent(outfile, level)
    outfile.write('LegendURL=[\n')
    level += 1
    for LegendURL_ in self.LegendURL:
      showIndent(outfile, level)
      outfile.write('model_.LegendURL(\n')
      LegendURL_.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    level -= 1
    showIndent(outfile, level)
    outfile.write('],\n')
    if self.StyleSheetURL is not None:
      showIndent(outfile, level)
      outfile.write('StyleSheetURL=model_.StyleSheetURL(\n')
      self.StyleSheetURL.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.StyleURL is not None:
      showIndent(outfile, level)
      outfile.write('StyleURL=model_.StyleURL(\n')
      self.StyleURL.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Name':
      Name_ = child_.text
      Name_ = self.gds_validate_string(Name_, node, 'Name')
      self.Name = Name_
    elif nodeName_ == 'Title':
      obj_ = Title.factory()
      obj_.build(child_)
      self.set_Title(obj_)
    elif nodeName_ == 'Abstract':
      obj_ = Abstract.factory()
      obj_.build(child_)
      self.set_Abstract(obj_)
    elif nodeName_ == 'LegendURL':
      obj_ = LegendURL.factory()
      obj_.build(child_)
      self.LegendURL.append(obj_)
    elif nodeName_ == 'StyleSheetURL':
      obj_ = StyleSheetURL.factory()
      obj_.build(child_)
      self.set_StyleSheetURL(obj_)
    elif nodeName_ == 'StyleURL':
      obj_ = StyleURL.factory()
      obj_.build(child_)
      self.set_StyleURL(obj_)
# end class Style


class LegendURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, width=None, height=None, Format=None, OnlineResource=None):
    self.width = _cast(None, width)
    self.height = _cast(None, height)
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if LegendURL.subclass:
      return LegendURL.subclass(*args_, **kwargs_)
    else:
      return LegendURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def get_width(self): return self.width
  def set_width(self, width): self.width = width
  def get_height(self): return self.height
  def set_height(self, height): self.height = height
  def export(self, outfile, level, namespace_='', name_='LegendURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='LegendURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegendURL'):
    if self.width is not None and 'width' not in already_processed:
      already_processed.append('width')
      outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
    if self.height is not None and 'height' not in already_processed:
      already_processed.append('height')
      outfile.write(' height=%s' % (self.gds_format_string(quote_attrib(self.height).encode(ExternalEncoding), input_name='height'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='LegendURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='LegendURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.width is not None and 'width' not in already_processed:
      already_processed.append('width')
      showIndent(outfile, level)
      outfile.write('width = "%s",\n' % (self.width,))
    if self.height is not None and 'height' not in already_processed:
      already_processed.append('height')
      showIndent(outfile, level)
      outfile.write('height = "%s",\n' % (self.height,))
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('width', node)
    if value is not None and 'width' not in already_processed:
      already_processed.append('width')
      self.width = value
    value = find_attr_value_('height', node)
    if value is not None and 'height' not in already_processed:
      already_processed.append('height')
      self.height = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class LegendURL


class StyleSheetURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, OnlineResource=None):
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if StyleSheetURL.subclass:
      return StyleSheetURL.subclass(*args_, **kwargs_)
    else:
      return StyleSheetURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def export(self, outfile, level, namespace_='', name_='StyleSheetURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='StyleSheetURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StyleSheetURL'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='StyleSheetURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='StyleSheetURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class StyleSheetURL


class StyleURL(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, Format=None, OnlineResource=None):
    self.Format = Format
    self.OnlineResource = OnlineResource
  def factory(*args_, **kwargs_):
    if StyleURL.subclass:
      return StyleURL.subclass(*args_, **kwargs_)
    else:
      return StyleURL(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_Format(self): return self.Format
  def set_Format(self, Format): self.Format = Format
  def get_OnlineResource(self): return self.OnlineResource
  def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
  def export(self, outfile, level, namespace_='', name_='StyleURL', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='StyleURL')
    if self.hasContent_():
      outfile.write('>\n')
      self.exportChildren(outfile, level + 1, namespace_, name_)
      showIndent(outfile, level)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StyleURL'):
    pass
  def exportChildren(self, outfile, level, namespace_='', name_='StyleURL', fromsubclass_=False):
    if self.Format:
      self.Format.export(outfile, level, namespace_, name_='Format', )
    if self.OnlineResource:
      self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', )
  def hasContent_(self):
    if (
        self.Format is not None or
        self.OnlineResource is not None
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='StyleURL'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    pass
  def exportLiteralChildren(self, outfile, level, name_):
    if self.Format is not None:
      showIndent(outfile, level)
      outfile.write('Format=model_.Format(\n')
      self.Format.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
    if self.OnlineResource is not None:
      showIndent(outfile, level)
      outfile.write('OnlineResource=model_.OnlineResource(\n')
      self.OnlineResource.exportLiteral(outfile, level)
      showIndent(outfile, level)
      outfile.write('),\n')
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    pass
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    if nodeName_ == 'Format':
      obj_ = Format.factory()
      obj_.build(child_)
      self.set_Format(obj_)
    elif nodeName_ == 'OnlineResource':
      obj_ = OnlineResource.factory()
      obj_.build(child_)
      self.set_OnlineResource(obj_)
# end class StyleURL


class ScaleHint(GeneratedsSuper):
  subclass = None
  superclass = None
  def __init__(self, max=None, min=None, valueOf_=None):
    self.max = _cast(None, max)
    self.min = _cast(None, min)
    self.valueOf_ = valueOf_
  def factory(*args_, **kwargs_):
    if ScaleHint.subclass:
      return ScaleHint.subclass(*args_, **kwargs_)
    else:
      return ScaleHint(*args_, **kwargs_)
  factory = staticmethod(factory)
  def get_max(self): return self.max
  def set_max(self, max): self.max = max
  def get_min(self): return self.min
  def set_min(self, min): self.min = min
  def get_valueOf_(self): return self.valueOf_
  def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
  def export(self, outfile, level, namespace_='', name_='ScaleHint', namespacedef_=''):
    showIndent(outfile, level)
    outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
    self.exportAttributes(outfile, level, [], namespace_, name_='ScaleHint')
    if self.hasContent_():
      outfile.write('>')
      outfile.write(self.valueOf_.encode(ExternalEncoding))
      self.exportChildren(outfile, level + 1, namespace_, name_)
      outfile.write('</%s%s>\n' % (namespace_, name_))
    else:
      outfile.write('/>\n')
  def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScaleHint'):
    if self.max is not None and 'max' not in already_processed:
      already_processed.append('max')
      outfile.write(' max=%s' % (self.gds_format_string(quote_attrib(self.max).encode(ExternalEncoding), input_name='max'), ))
    if self.min is not None and 'min' not in already_processed:
      already_processed.append('min')
      outfile.write(' min=%s' % (self.gds_format_string(quote_attrib(self.min).encode(ExternalEncoding), input_name='min'), ))
  def exportChildren(self, outfile, level, namespace_='', name_='ScaleHint', fromsubclass_=False):
    pass
  def hasContent_(self):
    if (
        self.valueOf_
        ):
      return True
    else:
      return False
  def exportLiteral(self, outfile, level, name_='ScaleHint'):
    level += 1
    self.exportLiteralAttributes(outfile, level, [], name_)
    if self.hasContent_():
      self.exportLiteralChildren(outfile, level, name_)
    showIndent(outfile, level)
    outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
  def exportLiteralAttributes(self, outfile, level, already_processed, name_):
    if self.max is not None and 'max' not in already_processed:
      already_processed.append('max')
      showIndent(outfile, level)
      outfile.write('max = "%s",\n' % (self.max,))
    if self.min is not None and 'min' not in already_processed:
      already_processed.append('min')
      showIndent(outfile, level)
      outfile.write('min = "%s",\n' % (self.min,))
  def exportLiteralChildren(self, outfile, level, name_):
    pass
  def build(self, node):
    self.buildAttributes(node, node.attrib, [])
    self.valueOf_ = get_all_text_(node)
    for child in node:
      nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
      self.buildChildren(child, node, nodeName_)
  def buildAttributes(self, node, attrs, already_processed):
    value = find_attr_value_('max', node)
    if value is not None and 'max' not in already_processed:
      already_processed.append('max')
      self.max = value
    value = find_attr_value_('min', node)
    if value is not None and 'min' not in already_processed:
      already_processed.append('min')
      self.min = value
  def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
    pass
# end class ScaleHint


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
  print USAGE_TEXT
  sys.exit(1)


def get_root_tag(node):
  tag = Tag_pattern_.match(node.tag).groups()[-1]
  rootClass = globals().get(tag)
  return tag, rootClass


def parse(inFileName):
  doc = parsexml_(inFileName)
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'WMT_MS_Capabilities'
    rootClass = WMT_MS_Capabilities
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('<?xml version="1.0" ?>\n')
  rootObj.export(sys.stdout, 0, name_=rootTag,
      namespacedef_='')
  return rootObj


def parseString(inString):
  from StringIO import StringIO
  doc = parsexml_(StringIO(inString))
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'WMT_MS_Capabilities'
    rootClass = WMT_MS_Capabilities
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('<?xml version="1.0" ?>\n')
  rootObj.export(sys.stdout, 0, name_="WMT_MS_Capabilities",
      namespacedef_='')
  return rootObj


def parseLiteral(inFileName):
  doc = parsexml_(inFileName)
  rootNode = doc.getroot()
  rootTag, rootClass = get_root_tag(rootNode)
  if rootClass is None:
    rootTag = 'WMT_MS_Capabilities'
    rootClass = WMT_MS_Capabilities
  rootObj = rootClass.factory()
  rootObj.build(rootNode)
  # Enable Python to collect the space used by the DOM.
  doc = None
  sys.stdout.write('#from capabilites import *\n\n')
  sys.stdout.write('import capabilites as model_\n\n')
  sys.stdout.write('rootObj = model_.rootTag(\n')
  rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
  sys.stdout.write(')\n')
  return rootObj


def main():
  args = sys.argv[1:]
  if len(args) == 1:
    parse(args[0])
  else:
    usage()


if __name__ == '__main__':
  #import pdb; pdb.set_trace()
  main()


__all__ = [
    "Abstract",
    "AccessConstraints",
    "Address",
    "AddressType",
    "Attribution",
    "AuthorityURL",
    "BoundingBox",
    "Capability",
    "City",
    "ContactAddress",
    "ContactElectronicMailAddress",
    "ContactFacsimileTelephone",
    "ContactInformation",
    "ContactOrganization",
    "ContactPerson",
    "ContactPersonPrimary",
    "ContactPosition",
    "ContactVoiceTelephone",
    "Country",
    "DCPType",
    "DataURL",
    "DescribeLayer",
    "Dimension",
    "Exception",
    "Extent",
    "FeatureListURL",
    "Fees",
    "Format",
    "Get",
    "GetCapabilities",
    "GetFeatureInfo",
    "GetLegendGraphic",
    "GetMap",
    "GetStyles",
    "HTTP",
    "Identifier",
    "Keyword",
    "KeywordList",
    "LatLonBoundingBox",
    "Layer",
    "LegendURL",
    "LogoURL",
    "MetadataURL",
    "Name",
    "OnlineResource",
    "Post",
    "PostCode",
    "PutStyles",
    "Request",
    "SRS",
    "ScaleHint",
    "Service",
    "StateOrProvince",
    "Style",
    "StyleSheetURL",
    "StyleURL",
    "Title",
    "UserDefinedSymbolization",
    "WMT_MS_Capabilities"
    ]
