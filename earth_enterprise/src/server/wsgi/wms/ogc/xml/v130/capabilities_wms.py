#!/usr/bin/env python2.7
#
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# -*- coding: utf-8 -*-

#
# Generated Wed Dec 12 14:36:27 2012 by generateDS.py version 2.7c.
#
# generateDS.py has trouble with namespaces, and, as far as I can tell,
# cannot add arbitrary attributes.
# Also, all instances of namespace_='...'  were namespace_='wms:'
# and were all changed to
#   namespace_=''
# All changes except the namespace_='' one are marked with jeffdonner
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
try:
    import defusedxml.ElementTree as etree_
    if Verbose_import_:
        print("running with defusedxml.ElementTree")
except ImportError:
    raise ImportError("Failed to import defusedxml.ElementTree")

def parsexml_(*args, **kwargs):
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
# in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            # jeffdonner - was %f, which made eg 180.0 look like 1.8e2.
            # Unaesthetic if nothing else.
            return '%s' % str(input_data)
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            # Was %e, which made eg 180.0 look like 1.8e2.
            # Unaesthetic if nothing else.
            return '%s' % str(input_data)
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class WMS_Capabilities(GeneratedsSuper):
    """A WMS_Capabilities document is returned in response to a
    GetCapabilities request made on a WMS."""
    subclass = None
    superclass = None
    def __init__(self, updateSequence=None, version=None, Service=None, Capability=None):
        self.updateSequence = _cast(None, updateSequence)
        self.version = _cast(None, version)
        self.Service = Service
        self.Capability = Capability
    def factory(*args_, **kwargs_):
        if WMS_Capabilities.subclass:
            return WMS_Capabilities.subclass(*args_, **kwargs_)
        else:
            return WMS_Capabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Service(self): return self.Service
    def set_Service(self, Service): self.Service = Service
    def get_Capability(self): return self.Capability
    def set_Capability(self, Capability): self.Capability = Capability
    def get_updateSequence(self): return self.updateSequence
    def set_updateSequence(self, updateSequence): self.updateSequence = updateSequence
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='', name_='WMS_Capabilities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WMS_Capabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WMS_Capabilities'):
        if self.updateSequence is not None and 'updateSequence' not in already_processed:
            already_processed.append('updateSequence')
            outfile.write(' updateSequence=%s' % (self.gds_format_string(quote_attrib(self.updateSequence).encode(ExternalEncoding), input_name='updateSequence'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        # jeffdonner added the rest of these attributes
        outfile.write(' xmlns="http://www.opengis.net/wms" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wms http://schemas.opengis.net/wms/1.3.0/capabilities_1_3_0.xsd"')
    def exportChildren(self, outfile, level, namespace_='', name_='WMS_Capabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Service is not None:
            self.Service.export(outfile, level, namespace_, name_='Service', pretty_print=pretty_print)
        if self.Capability is not None:
            self.Capability.export(outfile, level, namespace_, name_='Capability', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Service is not None or
            self.Capability is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WMS_Capabilities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.updateSequence is not None and 'updateSequence' not in already_processed:
            already_processed.append('updateSequence')
            showIndent(outfile, level)
            outfile.write('updateSequence = "%s",\n' % (self.updateSequence,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Service is not None:
            showIndent(outfile, level)
            outfile.write('Service=model_.Service(\n')
            self.Service.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Capability is not None:
            showIndent(outfile, level)
            outfile.write('Capability=model_.Capability(\n')
            self.Capability.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('updateSequence', node)
        if value is not None and 'updateSequence' not in already_processed:
            already_processed.append('updateSequence')
            self.updateSequence = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Service':
            obj_ = Service.factory()
            obj_.build(child_)
            self.set_Service(obj_)
        elif nodeName_ == 'Capability':
            obj_ = Capability.factory()
            obj_.build(child_)
            self.set_Capability(obj_)
# end class WMS_Capabilities


class KeywordList(GeneratedsSuper):
    """List of keywords or keyword phrases to help catalog searching."""
    subclass = None
    superclass = None
    def __init__(self, Keyword=None):
        if Keyword is None:
            self.Keyword = []
        else:
            self.Keyword = Keyword
    def factory(*args_, **kwargs_):
        if KeywordList.subclass:
            return KeywordList.subclass(*args_, **kwargs_)
        else:
            return KeywordList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Keyword(self): return self.Keyword
    def set_Keyword(self, Keyword): self.Keyword = Keyword
    def add_Keyword(self, value): self.Keyword.append(value)
    def insert_Keyword(self, index, value): self.Keyword[index] = value
    def export(self, outfile, level, namespace_='', name_='KeywordList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeywordList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeywordList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeywordList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Keyword_ in self.Keyword:
            Keyword_.export(outfile, level, namespace_, name_='Keyword', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Keyword
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeywordList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Keyword=[\n')
        level += 1
        for Keyword_ in self.Keyword:
            showIndent(outfile, level)
            outfile.write('model_.Keyword(\n')
            Keyword_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Keyword':
            obj_ = Keyword.factory()
            obj_.build(child_)
            self.Keyword.append(obj_)
# end class KeywordList


class Keyword(GeneratedsSuper):
    """A single keyword or phrase."""
    subclass = None
    superclass = None
    def __init__(self, vocabulary=None, valueOf_=None):
        self.vocabulary = _cast(None, vocabulary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Keyword.subclass:
            return Keyword.subclass(*args_, **kwargs_)
        else:
            return Keyword(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Keyword', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Keyword')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Keyword'):
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.append('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Keyword', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Keyword'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.append('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary = "%s",\n' % (self.vocabulary,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.append('vocabulary')
            self.vocabulary = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Keyword


class OnlineResource(GeneratedsSuper):
    """An OnlineResource is typically an HTTP URL. The URL is placed in the
    xlink:href attribute, and the value "simple" is placed in the
    xlink:type attribute."""
    subclass = None
    superclass = None
    def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None):
        self.title = _cast(None, title)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.show = _cast(None, show)
        self.type_ = _cast(None, type_)
        pass
    def factory(*args_, **kwargs_):
        if OnlineResource.subclass:
            return OnlineResource.subclass(*args_, **kwargs_)
        else:
            return OnlineResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='OnlineResource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnlineResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnlineResource'):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            # jeffdonner added xlink:
            outfile.write(' xlink:href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            # jeffdonner added xlink:
            outfile.write(' xlink:type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OnlineResource', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OnlineResource'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OnlineResource


class Service(GeneratedsSuper):
    """General service metadata."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Title=None, Abstract=None, KeywordList=None, OnlineResource=None, ContactInformation=None, Fees=None, AccessConstraints=None, LayerLimit=None, MaxWidth=None, MaxHeight=None):
        self.Name = Name
        self.Title = Title
        self.Abstract = Abstract
        self.KeywordList = KeywordList
        self.OnlineResource = OnlineResource
        self.ContactInformation = ContactInformation
        self.Fees = Fees
        self.AccessConstraints = AccessConstraints
        self.LayerLimit = LayerLimit
        self.MaxWidth = MaxWidth
        self.MaxHeight = MaxHeight
    def factory(*args_, **kwargs_):
        if Service.subclass:
            return Service.subclass(*args_, **kwargs_)
        else:
            return Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Abstract(self): return self.Abstract
    def set_Abstract(self, Abstract): self.Abstract = Abstract
    def get_KeywordList(self): return self.KeywordList
    def set_KeywordList(self, KeywordList): self.KeywordList = KeywordList
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def get_ContactInformation(self): return self.ContactInformation
    def set_ContactInformation(self, ContactInformation): self.ContactInformation = ContactInformation
    def get_Fees(self): return self.Fees
    def set_Fees(self, Fees): self.Fees = Fees
    def get_AccessConstraints(self): return self.AccessConstraints
    def set_AccessConstraints(self, AccessConstraints): self.AccessConstraints = AccessConstraints
    def get_LayerLimit(self): return self.LayerLimit
    def set_LayerLimit(self, LayerLimit): self.LayerLimit = LayerLimit
    def get_MaxWidth(self): return self.MaxWidth
    def set_MaxWidth(self, MaxWidth): self.MaxWidth = MaxWidth
    def get_MaxHeight(self): return self.MaxHeight
    def set_MaxHeight(self, MaxHeight): self.MaxHeight = MaxHeight
    def export(self, outfile, level, namespace_='', name_='Service', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Service'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Service', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.Abstract is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAbstract>%s</%sAbstract>%s' % (namespace_, self.gds_format_string(quote_xml(self.Abstract).encode(ExternalEncoding), input_name='Abstract'), namespace_, eol_))
        if self.KeywordList is not None:
            self.KeywordList.export(outfile, level, namespace_, name_='KeywordList', pretty_print=pretty_print)
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
        if self.ContactInformation is not None:
            self.ContactInformation.export(outfile, level, namespace_, name_='ContactInformation', pretty_print=pretty_print)
        if self.Fees is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFees>%s</%sFees>%s' % (namespace_, self.gds_format_string(quote_xml(self.Fees).encode(ExternalEncoding), input_name='Fees'), namespace_, eol_))
        if self.AccessConstraints is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessConstraints>%s</%sAccessConstraints>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccessConstraints).encode(ExternalEncoding), input_name='AccessConstraints'), namespace_, eol_))
        if self.LayerLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLayerLimit>%s</%sLayerLimit>%s' % (namespace_, self.gds_format_integer(self.LayerLimit, input_name='LayerLimit'), namespace_, eol_))
        if self.MaxWidth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxWidth>%s</%sMaxWidth>%s' % (namespace_, self.gds_format_integer(self.MaxWidth, input_name='MaxWidth'), namespace_, eol_))
        if self.MaxHeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxHeight>%s</%sMaxHeight>%s' % (namespace_, self.gds_format_integer(self.MaxHeight, input_name='MaxHeight'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Title is not None or
            self.Abstract is not None or
            self.KeywordList is not None or
            self.OnlineResource is not None or
            self.ContactInformation is not None or
            self.Fees is not None or
            self.AccessConstraints is not None or
            self.LayerLimit is not None or
            self.MaxWidth is not None or
            self.MaxHeight is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Service'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Abstract is not None:
            showIndent(outfile, level)
            outfile.write('Abstract=%s,\n' % quote_python(self.Abstract).encode(ExternalEncoding))
        if self.KeywordList is not None:
            showIndent(outfile, level)
            outfile.write('KeywordList=model_.KeywordList(\n')
            self.KeywordList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactInformation is not None:
            showIndent(outfile, level)
            outfile.write('ContactInformation=model_.ContactInformation(\n')
            self.ContactInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Fees is not None:
            showIndent(outfile, level)
            outfile.write('Fees=%s,\n' % quote_python(self.Fees).encode(ExternalEncoding))
        if self.AccessConstraints is not None:
            showIndent(outfile, level)
            outfile.write('AccessConstraints=%s,\n' % quote_python(self.AccessConstraints).encode(ExternalEncoding))
        if self.LayerLimit is not None:
            showIndent(outfile, level)
            outfile.write('LayerLimit=%d,\n' % self.LayerLimit)
        if self.MaxWidth is not None:
            showIndent(outfile, level)
            outfile.write('MaxWidth=%d,\n' % self.MaxWidth)
        if self.MaxHeight is not None:
            showIndent(outfile, level)
            outfile.write('MaxHeight=%d,\n' % self.MaxHeight)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Abstract':
            Abstract_ = child_.text
            Abstract_ = self.gds_validate_string(Abstract_, node, 'Abstract')
            self.Abstract = Abstract_
        elif nodeName_ == 'KeywordList':
            obj_ = KeywordList.factory()
            obj_.build(child_)
            self.set_KeywordList(obj_)
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
        elif nodeName_ == 'ContactInformation':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.set_ContactInformation(obj_)
        elif nodeName_ == 'Fees':
            Fees_ = child_.text
            Fees_ = self.gds_validate_string(Fees_, node, 'Fees')
            self.Fees = Fees_
        elif nodeName_ == 'AccessConstraints':
            AccessConstraints_ = child_.text
            AccessConstraints_ = self.gds_validate_string(AccessConstraints_, node, 'AccessConstraints')
            self.AccessConstraints = AccessConstraints_
        elif nodeName_ == 'LayerLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'LayerLimit')
            self.LayerLimit = ival_
        elif nodeName_ == 'MaxWidth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MaxWidth')
            self.MaxWidth = ival_
        elif nodeName_ == 'MaxHeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MaxHeight')
            self.MaxHeight = ival_
# end class Service


class Name(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Name.subclass:
            return Name.subclass(*args_, **kwargs_)
        else:
            return Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Name'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Name', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Name'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Name


class ContactInformation(GeneratedsSuper):
    """Information about a contact person for the service."""
    subclass = None
    superclass = None
    def __init__(self, ContactPersonPrimary=None, ContactPosition=None, ContactAddress=None, ContactVoiceTelephone=None, ContactFacsimileTelephone=None, ContactElectronicMailAddress=None):
        self.ContactPersonPrimary = ContactPersonPrimary
        self.ContactPosition = ContactPosition
        self.ContactAddress = ContactAddress
        self.ContactVoiceTelephone = ContactVoiceTelephone
        self.ContactFacsimileTelephone = ContactFacsimileTelephone
        self.ContactElectronicMailAddress = ContactElectronicMailAddress
    def factory(*args_, **kwargs_):
        if ContactInformation.subclass:
            return ContactInformation.subclass(*args_, **kwargs_)
        else:
            return ContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactPersonPrimary(self): return self.ContactPersonPrimary
    def set_ContactPersonPrimary(self, ContactPersonPrimary): self.ContactPersonPrimary = ContactPersonPrimary
    def get_ContactPosition(self): return self.ContactPosition
    def set_ContactPosition(self, ContactPosition): self.ContactPosition = ContactPosition
    def get_ContactAddress(self): return self.ContactAddress
    def set_ContactAddress(self, ContactAddress): self.ContactAddress = ContactAddress
    def get_ContactVoiceTelephone(self): return self.ContactVoiceTelephone
    def set_ContactVoiceTelephone(self, ContactVoiceTelephone): self.ContactVoiceTelephone = ContactVoiceTelephone
    def get_ContactFacsimileTelephone(self): return self.ContactFacsimileTelephone
    def set_ContactFacsimileTelephone(self, ContactFacsimileTelephone): self.ContactFacsimileTelephone = ContactFacsimileTelephone
    def get_ContactElectronicMailAddress(self): return self.ContactElectronicMailAddress
    def set_ContactElectronicMailAddress(self, ContactElectronicMailAddress): self.ContactElectronicMailAddress = ContactElectronicMailAddress
    def export(self, outfile, level, namespace_='', name_='ContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactPersonPrimary is not None:
            self.ContactPersonPrimary.export(outfile, level, namespace_, name_='ContactPersonPrimary', pretty_print=pretty_print)
        if self.ContactPosition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactPosition>%s</%sContactPosition>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactPosition).encode(ExternalEncoding), input_name='ContactPosition'), namespace_, eol_))
        if self.ContactAddress is not None:
            self.ContactAddress.export(outfile, level, namespace_, name_='ContactAddress', pretty_print=pretty_print)
        if self.ContactVoiceTelephone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactVoiceTelephone>%s</%sContactVoiceTelephone>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactVoiceTelephone).encode(ExternalEncoding), input_name='ContactVoiceTelephone'), namespace_, eol_))
        if self.ContactFacsimileTelephone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactFacsimileTelephone>%s</%sContactFacsimileTelephone>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactFacsimileTelephone).encode(ExternalEncoding), input_name='ContactFacsimileTelephone'), namespace_, eol_))
        if self.ContactElectronicMailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactElectronicMailAddress>%s</%sContactElectronicMailAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactElectronicMailAddress).encode(ExternalEncoding), input_name='ContactElectronicMailAddress'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ContactPersonPrimary is not None or
            self.ContactPosition is not None or
            self.ContactAddress is not None or
            self.ContactVoiceTelephone is not None or
            self.ContactFacsimileTelephone is not None or
            self.ContactElectronicMailAddress is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactInformation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContactPersonPrimary is not None:
            showIndent(outfile, level)
            outfile.write('ContactPersonPrimary=model_.ContactPersonPrimary(\n')
            self.ContactPersonPrimary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactPosition is not None:
            showIndent(outfile, level)
            outfile.write('ContactPosition=%s,\n' % quote_python(self.ContactPosition).encode(ExternalEncoding))
        if self.ContactAddress is not None:
            showIndent(outfile, level)
            outfile.write('ContactAddress=model_.ContactAddress(\n')
            self.ContactAddress.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactVoiceTelephone is not None:
            showIndent(outfile, level)
            outfile.write('ContactVoiceTelephone=%s,\n' % quote_python(self.ContactVoiceTelephone).encode(ExternalEncoding))
        if self.ContactFacsimileTelephone is not None:
            showIndent(outfile, level)
            outfile.write('ContactFacsimileTelephone=%s,\n' % quote_python(self.ContactFacsimileTelephone).encode(ExternalEncoding))
        if self.ContactElectronicMailAddress is not None:
            showIndent(outfile, level)
            outfile.write('ContactElectronicMailAddress=%s,\n' % quote_python(self.ContactElectronicMailAddress).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactPersonPrimary':
            obj_ = ContactPersonPrimary.factory()
            obj_.build(child_)
            self.set_ContactPersonPrimary(obj_)
        elif nodeName_ == 'ContactPosition':
            ContactPosition_ = child_.text
            ContactPosition_ = self.gds_validate_string(ContactPosition_, node, 'ContactPosition')
            self.ContactPosition = ContactPosition_
        elif nodeName_ == 'ContactAddress':
            obj_ = ContactAddress.factory()
            obj_.build(child_)
            self.set_ContactAddress(obj_)
        elif nodeName_ == 'ContactVoiceTelephone':
            ContactVoiceTelephone_ = child_.text
            ContactVoiceTelephone_ = self.gds_validate_string(ContactVoiceTelephone_, node, 'ContactVoiceTelephone')
            self.ContactVoiceTelephone = ContactVoiceTelephone_
        elif nodeName_ == 'ContactFacsimileTelephone':
            ContactFacsimileTelephone_ = child_.text
            ContactFacsimileTelephone_ = self.gds_validate_string(ContactFacsimileTelephone_, node, 'ContactFacsimileTelephone')
            self.ContactFacsimileTelephone = ContactFacsimileTelephone_
        elif nodeName_ == 'ContactElectronicMailAddress':
            ContactElectronicMailAddress_ = child_.text
            ContactElectronicMailAddress_ = self.gds_validate_string(ContactElectronicMailAddress_, node, 'ContactElectronicMailAddress')
            self.ContactElectronicMailAddress = ContactElectronicMailAddress_
# end class ContactInformation


class ContactPersonPrimary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ContactPerson=None, ContactOrganization=None):
        self.ContactPerson = ContactPerson
        self.ContactOrganization = ContactOrganization
    def factory(*args_, **kwargs_):
        if ContactPersonPrimary.subclass:
            return ContactPersonPrimary.subclass(*args_, **kwargs_)
        else:
            return ContactPersonPrimary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactPerson(self): return self.ContactPerson
    def set_ContactPerson(self, ContactPerson): self.ContactPerson = ContactPerson
    def get_ContactOrganization(self): return self.ContactOrganization
    def set_ContactOrganization(self, ContactOrganization): self.ContactOrganization = ContactOrganization
    def export(self, outfile, level, namespace_='', name_='ContactPersonPrimary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactPersonPrimary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactPersonPrimary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactPersonPrimary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactPerson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactPerson>%s</%sContactPerson>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactPerson).encode(ExternalEncoding), input_name='ContactPerson'), namespace_, eol_))
        if self.ContactOrganization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactOrganization>%s</%sContactOrganization>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactOrganization).encode(ExternalEncoding), input_name='ContactOrganization'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ContactPerson is not None or
            self.ContactOrganization is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactPersonPrimary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContactPerson is not None:
            showIndent(outfile, level)
            outfile.write('ContactPerson=%s,\n' % quote_python(self.ContactPerson).encode(ExternalEncoding))
        if self.ContactOrganization is not None:
            showIndent(outfile, level)
            outfile.write('ContactOrganization=%s,\n' % quote_python(self.ContactOrganization).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactPerson':
            ContactPerson_ = child_.text
            ContactPerson_ = self.gds_validate_string(ContactPerson_, node, 'ContactPerson')
            self.ContactPerson = ContactPerson_
        elif nodeName_ == 'ContactOrganization':
            ContactOrganization_ = child_.text
            ContactOrganization_ = self.gds_validate_string(ContactOrganization_, node, 'ContactOrganization')
            self.ContactOrganization = ContactOrganization_
# end class ContactPersonPrimary


class ContactAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressType=None, Address=None, City=None, StateOrProvince=None, PostCode=None, Country=None):
        self.AddressType = AddressType
        self.Address = Address
        self.City = City
        self.StateOrProvince = StateOrProvince
        self.PostCode = PostCode
        self.Country = Country
    def factory(*args_, **kwargs_):
        if ContactAddress.subclass:
            return ContactAddress.subclass(*args_, **kwargs_)
        else:
            return ContactAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressType(self): return self.AddressType
    def set_AddressType(self, AddressType): self.AddressType = AddressType
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateOrProvince(self): return self.StateOrProvince
    def set_StateOrProvince(self, StateOrProvince): self.StateOrProvince = StateOrProvince
    def get_PostCode(self): return self.PostCode
    def set_PostCode(self, PostCode): self.PostCode = PostCode
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    def export(self, outfile, level, namespace_='', name_='ContactAddress', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddressType>%s</%sAddressType>%s' % (namespace_, self.gds_format_string(quote_xml(self.AddressType).encode(ExternalEncoding), input_name='AddressType'), namespace_, eol_))
        if self.Address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddress>%s</%sAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.Address).encode(ExternalEncoding), input_name='Address'), namespace_, eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCity>%s</%sCity>%s' % (namespace_, self.gds_format_string(quote_xml(self.City).encode(ExternalEncoding), input_name='City'), namespace_, eol_))
        if self.StateOrProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStateOrProvince>%s</%sStateOrProvince>%s' % (namespace_, self.gds_format_string(quote_xml(self.StateOrProvince).encode(ExternalEncoding), input_name='StateOrProvince'), namespace_, eol_))
        if self.PostCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostCode>%s</%sPostCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.PostCode).encode(ExternalEncoding), input_name='PostCode'), namespace_, eol_))
        if self.Country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountry>%s</%sCountry>%s' % (namespace_, self.gds_format_string(quote_xml(self.Country).encode(ExternalEncoding), input_name='Country'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.AddressType is not None or
            self.Address is not None or
            self.City is not None or
            self.StateOrProvince is not None or
            self.PostCode is not None or
            self.Country is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AddressType is not None:
            showIndent(outfile, level)
            outfile.write('AddressType=%s,\n' % quote_python(self.AddressType).encode(ExternalEncoding))
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=%s,\n' % quote_python(self.Address).encode(ExternalEncoding))
        if self.City is not None:
            showIndent(outfile, level)
            outfile.write('City=%s,\n' % quote_python(self.City).encode(ExternalEncoding))
        if self.StateOrProvince is not None:
            showIndent(outfile, level)
            outfile.write('StateOrProvince=%s,\n' % quote_python(self.StateOrProvince).encode(ExternalEncoding))
        if self.PostCode is not None:
            showIndent(outfile, level)
            outfile.write('PostCode=%s,\n' % quote_python(self.PostCode).encode(ExternalEncoding))
        if self.Country is not None:
            showIndent(outfile, level)
            outfile.write('Country=%s,\n' % quote_python(self.Country).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressType':
            AddressType_ = child_.text
            AddressType_ = self.gds_validate_string(AddressType_, node, 'AddressType')
            self.AddressType = AddressType_
        elif nodeName_ == 'Address':
            Address_ = child_.text
            Address_ = self.gds_validate_string(Address_, node, 'Address')
            self.Address = Address_
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateOrProvince':
            StateOrProvince_ = child_.text
            StateOrProvince_ = self.gds_validate_string(StateOrProvince_, node, 'StateOrProvince')
            self.StateOrProvince = StateOrProvince_
        elif nodeName_ == 'PostCode':
            PostCode_ = child_.text
            PostCode_ = self.gds_validate_string(PostCode_, node, 'PostCode')
            self.PostCode = PostCode_
        elif nodeName_ == 'Country':
            Country_ = child_.text
            Country_ = self.gds_validate_string(Country_, node, 'Country')
            self.Country = Country_
# end class ContactAddress


class Capability(GeneratedsSuper):
    """A Capability lists available request types, how exceptions may be
    reported, and whether any extended capabilities are defined. It
    also includes an optional list of map layers available from this
    server."""
    subclass = None
    superclass = None
    def __init__(self, Request=None, Exception=None, _ExtendedCapabilities=None, Layer=None):
        self.Request = Request
        self.Exception = Exception
        if _ExtendedCapabilities is None:
            self._ExtendedCapabilities = []
        else:
            self._ExtendedCapabilities = _ExtendedCapabilities
        self.Layer = Layer
    def factory(*args_, **kwargs_):
        if Capability.subclass:
            return Capability.subclass(*args_, **kwargs_)
        else:
            return Capability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_Exception(self): return self.Exception
    def set_Exception(self, Exception): self.Exception = Exception
    def get__ExtendedCapabilities(self): return self._ExtendedCapabilities
    def set__ExtendedCapabilities(self, _ExtendedCapabilities): self._ExtendedCapabilities = _ExtendedCapabilities
    def add__ExtendedCapabilities(self, value): self._ExtendedCapabilities.append(value)
    def insert__ExtendedCapabilities(self, index, value): self._ExtendedCapabilities[index] = value
    def get_Layer(self): return self.Layer
    def set_Layer(self, Layer): self.Layer = Layer
    def export(self, outfile, level, namespace_='', name_='Capability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Capability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Capability'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Capability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_, name_='Request', pretty_print=pretty_print)
        if self.Exception is not None:
            self.Exception.export(outfile, level, namespace_, name_='Exception', pretty_print=pretty_print)
        for _ExtendedCapabilities_ in self.get__ExtendedCapabilities():
            _ExtendedCapabilities_.export(outfile, level, namespace_, name_='_ExtendedCapabilities', pretty_print=pretty_print)
        if self.Layer is not None:
            self.Layer.export(outfile, level, namespace_, name_='Layer', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Request is not None or
            self.Exception is not None or
            self._ExtendedCapabilities or
            self.Layer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Capability'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Request is not None:
            showIndent(outfile, level)
            outfile.write('Request=model_.Request(\n')
            self.Request.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Exception is not None:
            showIndent(outfile, level)
            outfile.write('Exception=model_.Exception(\n')
            self.Exception.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('_ExtendedCapabilities=[\n')
        level += 1
        for _ExtendedCapabilities_ in self._ExtendedCapabilities:
            showIndent(outfile, level)
            outfile.write('model_._ExtendedCapabilities(\n')
            _ExtendedCapabilities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Layer is not None:
            showIndent(outfile, level)
            outfile.write('Layer=model_.Layer(\n')
            self.Layer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = Request.factory()
            obj_.build(child_)
            self.set_Request(obj_)
        elif nodeName_ == 'Exception':
            obj_ = Exception.factory()
            obj_.build(child_)
            self.set_Exception(obj_)
        elif nodeName_ == '_ExtendedCapabilities':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <_ExtendedCapabilities> element')
            self._ExtendedCapabilities.append(obj_)
        elif nodeName_ == 'Layer':
            obj_ = Layer.factory()
            obj_.build(child_)
            self.set_Layer(obj_)
# end class Capability


class Request(GeneratedsSuper):
    """Available WMS Operations are listed in a Request element."""
    subclass = None
    superclass = None
    def __init__(self, GetCapabilities=None, GetMap=None, GetFeatureInfo=None, _ExtendedOperation=None):
        self.GetCapabilities = GetCapabilities
        self.GetMap = GetMap
        self.GetFeatureInfo = GetFeatureInfo
        if _ExtendedOperation is None:
            self._ExtendedOperation = []
        else:
            self._ExtendedOperation = _ExtendedOperation
    def factory(*args_, **kwargs_):
        if Request.subclass:
            return Request.subclass(*args_, **kwargs_)
        else:
            return Request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GetCapabilities(self): return self.GetCapabilities
    def set_GetCapabilities(self, GetCapabilities): self.GetCapabilities = GetCapabilities
    def get_GetMap(self): return self.GetMap
    def set_GetMap(self, GetMap): self.GetMap = GetMap
    def get_GetFeatureInfo(self): return self.GetFeatureInfo
    def set_GetFeatureInfo(self, GetFeatureInfo): self.GetFeatureInfo = GetFeatureInfo
    def get__ExtendedOperation(self): return self._ExtendedOperation
    def set__ExtendedOperation(self, _ExtendedOperation): self._ExtendedOperation = _ExtendedOperation
    def add__ExtendedOperation(self, value): self._ExtendedOperation.append(value)
    def insert__ExtendedOperation(self, index, value): self._ExtendedOperation[index] = value
    def export(self, outfile, level, namespace_='', name_='Request', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Request')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Request'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Request', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GetCapabilities is not None:
            self.GetCapabilities.export(outfile, level, namespace_, name_='GetCapabilities', pretty_print=pretty_print)
        if self.GetMap is not None:
            self.GetMap.export(outfile, level, namespace_, name_='GetMap', pretty_print=pretty_print)
        if self.GetFeatureInfo is not None:
            self.GetFeatureInfo.export(outfile, level, namespace_, name_='GetFeatureInfo', pretty_print=pretty_print)
        for _ExtendedOperation_ in self.get__ExtendedOperation():
            _ExtendedOperation_.export(outfile, level, namespace_, name_='_ExtendedOperation', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.GetCapabilities is not None or
            self.GetMap is not None or
            self.GetFeatureInfo is not None or
            self._ExtendedOperation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GetCapabilities is not None:
            showIndent(outfile, level)
            outfile.write('GetCapabilities=model_.GetCapabilities(\n')
            self.GetCapabilities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GetMap is not None:
            showIndent(outfile, level)
            outfile.write('GetMap=model_.GetMap(\n')
            self.GetMap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GetFeatureInfo is not None:
            showIndent(outfile, level)
            outfile.write('GetFeatureInfo=model_.GetFeatureInfo(\n')
            self.GetFeatureInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('_ExtendedOperation=[\n')
        level += 1
        for _ExtendedOperation_ in self._ExtendedOperation:
            showIndent(outfile, level)
            outfile.write('model_._ExtendedOperation(\n')
            _ExtendedOperation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GetCapabilities':
            obj_ = OperationType.factory()
            obj_.build(child_)
            self.set_GetCapabilities(obj_)
        elif nodeName_ == 'GetMap':
            obj_ = OperationType.factory()
            obj_.build(child_)
            self.set_GetMap(obj_)
        elif nodeName_ == 'GetFeatureInfo':
            obj_ = OperationType.factory()
            obj_.build(child_)
            self.set_GetFeatureInfo(obj_)
        elif nodeName_ == '_ExtendedOperation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <_ExtendedOperation> element')
            self._ExtendedOperation.append(obj_)
# end class Request


class OperationType(GeneratedsSuper):
    """For each operation offered by the server, list the available output
    formats and the online resource."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, DCPType=None):
        if Format is None:
            self.Format = []
        else:
            self.Format = Format
        if DCPType is None:
            self.DCPType = []
        else:
            self.DCPType = DCPType
    def factory(*args_, **kwargs_):
        if OperationType.subclass:
            return OperationType.subclass(*args_, **kwargs_)
        else:
            return OperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def add_Format(self, value): self.Format.append(value)
    def insert_Format(self, index, value): self.Format[index] = value
    def get_DCPType(self): return self.DCPType
    def set_DCPType(self, DCPType): self.DCPType = DCPType
    def add_DCPType(self, value): self.DCPType.append(value)
    def insert_DCPType(self, index, value): self.DCPType[index] = value
    def export(self, outfile, level, namespace_='', name_='OperationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Format_ in self.Format:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(Format_).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        for DCPType_ in self.DCPType:
            DCPType_.export(outfile, level, namespace_, name_='DCPType', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format or
            self.DCPType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Format=[\n')
        level += 1
        for Format_ in self.Format:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Format_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DCPType=[\n')
        level += 1
        for DCPType_ in self.DCPType:
            showIndent(outfile, level)
            outfile.write('model_.DCPType(\n')
            DCPType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format.append(Format_)
        elif nodeName_ == 'DCPType':
            obj_ = DCPType.factory()
            obj_.build(child_)
            self.DCPType.append(obj_)
# end class OperationType


class DCPType(GeneratedsSuper):
    """Available Distributed Computing Platforms (DCPs) are listed here. At
    present, only HTTP is defined."""
    subclass = None
    superclass = None
    def __init__(self, HTTP=None):
        self.HTTP = HTTP
    def factory(*args_, **kwargs_):
        if DCPType.subclass:
            return DCPType.subclass(*args_, **kwargs_)
        else:
            return DCPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP(self): return self.HTTP
    def set_HTTP(self, HTTP): self.HTTP = HTTP
    def export(self, outfile, level, namespace_='', name_='DCPType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCPType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTTP is not None:
            self.HTTP.export(outfile, level, namespace_, name_='HTTP', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.HTTP is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DCPType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HTTP is not None:
            showIndent(outfile, level)
            outfile.write('HTTP=model_.HTTP(\n')
            self.HTTP.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP':
            obj_ = HTTP.factory()
            obj_.build(child_)
            self.set_HTTP(obj_)
# end class DCPType


class HTTP(GeneratedsSuper):
    """Available HTTP request methods. At least "Get" shall be supported."""
    subclass = None
    superclass = None
    def __init__(self, Get=None, Post=None):
        self.Get = Get
        self.Post = Post
    def factory(*args_, **kwargs_):
        if HTTP.subclass:
            return HTTP.subclass(*args_, **kwargs_)
        else:
            return HTTP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Get(self): return self.Get
    def set_Get(self, Get): self.Get = Get
    def get_Post(self): return self.Post
    def set_Post(self, Post): self.Post = Post
    def export(self, outfile, level, namespace_='', name_='HTTP', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HTTP'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HTTP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Get is not None:
            self.Get.export(outfile, level, namespace_, name_='Get', pretty_print=pretty_print)
        if self.Post is not None:
            self.Post.export(outfile, level, namespace_, name_='Post', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Get is not None or
            self.Post is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HTTP'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Get is not None:
            showIndent(outfile, level)
            outfile.write('Get=model_.Get(\n')
            self.Get.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Post is not None:
            showIndent(outfile, level)
            outfile.write('Post=model_.Post(\n')
            self.Post.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Get':
            obj_ = Get.factory()
            obj_.build(child_)
            self.set_Get(obj_)
        elif nodeName_ == 'Post':
            obj_ = Post.factory()
            obj_.build(child_)
            self.set_Post(obj_)
# end class HTTP


class Get(GeneratedsSuper):
    """The URL prefix for the HTTP "Get" request method."""
    subclass = None
    superclass = None
    def __init__(self, OnlineResource=None):
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if Get.subclass:
            return Get.subclass(*args_, **kwargs_)
        else:
            return Get(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def export(self, outfile, level, namespace_='', name_='Get', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Get')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Get'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Get', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Get'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class Get


class Post(GeneratedsSuper):
    """The URL prefix for the HTTP "Post" request method."""
    subclass = None
    superclass = None
    def __init__(self, OnlineResource=None):
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if Post.subclass:
            return Post.subclass(*args_, **kwargs_)
        else:
            return Post(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def export(self, outfile, level, namespace_='', name_='Post', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Post')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Post'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Post', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Post'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class Post


class Exception(GeneratedsSuper):
    """An Exception element indicates which error-reporting formats are
    supported."""
    subclass = None
    superclass = None
    def __init__(self, Format=None):
        if Format is None:
            self.Format = []
        else:
            self.Format = Format
    def factory(*args_, **kwargs_):
        if Exception.subclass:
            return Exception.subclass(*args_, **kwargs_)
        else:
            return Exception(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def add_Format(self, value): self.Format.append(value)
    def insert_Format(self, index, value): self.Format[index] = value
    def export(self, outfile, level, namespace_='', name_='Exception', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Exception')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exception'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Exception', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Format_ in self.Format:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(Format_).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Format
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Exception'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Format=[\n')
        level += 1
        for Format_ in self.Format:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Format_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format.append(Format_)
# end class Exception


class _ExtendedCapabilities(GeneratedsSuper):
    """Individual service providers may use this element to report extended
    capabilities."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if _ExtendedCapabilities.subclass:
            return _ExtendedCapabilities.subclass(*args_, **kwargs_)
        else:
            return _ExtendedCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='_ExtendedCapabilities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='_ExtendedCapabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='_ExtendedCapabilities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='_ExtendedCapabilities', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='_ExtendedCapabilities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _ExtendedCapabilities


class Layer(GeneratedsSuper):
    """Nested list of zero or more map Layers offered by this server."""
    subclass = None
    superclass = None
    def __init__(self, opaque=False, cascaded=None, fixedHeight=None, fixedWidth=None, noSubsets=False, queryable=False, Name=None, Title=None, Abstract=None, KeywordList=None, CRS=None, EX_GeographicBoundingBox=None, BoundingBox=None, Dimension=None, Attribution=None, AuthorityURL=None, Identifier=None, MetadataURL=None, DataURL=None, FeatureListURL=None, Style=None, MinScaleDenominator=None, MaxScaleDenominator=None, Layer=None):
        self.opaque = _cast(bool, opaque)
        self.cascaded = _cast(int, cascaded)
        self.fixedHeight = _cast(int, fixedHeight)
        self.fixedWidth = _cast(int, fixedWidth)
        self.noSubsets = _cast(bool, noSubsets)
        self.queryable = _cast(bool, queryable)
        self.Name = Name
        self.Title = Title
        self.Abstract = Abstract
        self.KeywordList = KeywordList
        if CRS is None:
            self.CRS = []
        else:
            self.CRS = CRS
        self.EX_GeographicBoundingBox = EX_GeographicBoundingBox
        if BoundingBox is None:
            self.BoundingBox = []
        else:
            self.BoundingBox = BoundingBox
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        self.Attribution = Attribution
        if AuthorityURL is None:
            self.AuthorityURL = []
        else:
            self.AuthorityURL = AuthorityURL
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        if MetadataURL is None:
            self.MetadataURL = []
        else:
            self.MetadataURL = MetadataURL
        if DataURL is None:
            self.DataURL = []
        else:
            self.DataURL = DataURL
        if FeatureListURL is None:
            self.FeatureListURL = []
        else:
            self.FeatureListURL = FeatureListURL
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.MinScaleDenominator = MinScaleDenominator
        self.MaxScaleDenominator = MaxScaleDenominator
        if Layer is None:
            self.Layer = []
        else:
            self.Layer = Layer
    def factory(*args_, **kwargs_):
        if Layer.subclass:
            return Layer.subclass(*args_, **kwargs_)
        else:
            return Layer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_Name(self, value):
        # Validate type Name, a restriction on string.
        pass
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Abstract(self): return self.Abstract
    def set_Abstract(self, Abstract): self.Abstract = Abstract
    def get_KeywordList(self): return self.KeywordList
    def set_KeywordList(self, KeywordList): self.KeywordList = KeywordList
    def get_CRS(self): return self.CRS
    def set_CRS(self, CRS): self.CRS = CRS
    def add_CRS(self, value): self.CRS.append(value)
    def insert_CRS(self, index, value): self.CRS[index] = value
    def get_EX_GeographicBoundingBox(self): return self.EX_GeographicBoundingBox
    def set_EX_GeographicBoundingBox(self, EX_GeographicBoundingBox): self.EX_GeographicBoundingBox = EX_GeographicBoundingBox
    def get_BoundingBox(self): return self.BoundingBox
    def set_BoundingBox(self, BoundingBox): self.BoundingBox = BoundingBox
    def add_BoundingBox(self, value): self.BoundingBox.append(value)
    def insert_BoundingBox(self, index, value): self.BoundingBox[index] = value
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def add_Dimension(self, value): self.Dimension.append(value)
    def insert_Dimension(self, index, value): self.Dimension[index] = value
    def get_Attribution(self): return self.Attribution
    def set_Attribution(self, Attribution): self.Attribution = Attribution
    def get_AuthorityURL(self): return self.AuthorityURL
    def set_AuthorityURL(self, AuthorityURL): self.AuthorityURL = AuthorityURL
    def add_AuthorityURL(self, value): self.AuthorityURL.append(value)
    def insert_AuthorityURL(self, index, value): self.AuthorityURL[index] = value
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def get_MetadataURL(self): return self.MetadataURL
    def set_MetadataURL(self, MetadataURL): self.MetadataURL = MetadataURL
    def add_MetadataURL(self, value): self.MetadataURL.append(value)
    def insert_MetadataURL(self, index, value): self.MetadataURL[index] = value
    def get_DataURL(self): return self.DataURL
    def set_DataURL(self, DataURL): self.DataURL = DataURL
    def add_DataURL(self, value): self.DataURL.append(value)
    def insert_DataURL(self, index, value): self.DataURL[index] = value
    def get_FeatureListURL(self): return self.FeatureListURL
    def set_FeatureListURL(self, FeatureListURL): self.FeatureListURL = FeatureListURL
    def add_FeatureListURL(self, value): self.FeatureListURL.append(value)
    def insert_FeatureListURL(self, index, value): self.FeatureListURL[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_MinScaleDenominator(self): return self.MinScaleDenominator
    def set_MinScaleDenominator(self, MinScaleDenominator): self.MinScaleDenominator = MinScaleDenominator
    def get_MaxScaleDenominator(self): return self.MaxScaleDenominator
    def set_MaxScaleDenominator(self, MaxScaleDenominator): self.MaxScaleDenominator = MaxScaleDenominator
    def get_Layer(self): return self.Layer
    def set_Layer(self, Layer): self.Layer = Layer
    def add_Layer(self, value): self.Layer.append(value)
    def insert_Layer(self, index, value): self.Layer[index] = value
    def get_opaque(self): return self.opaque
    def set_opaque(self, opaque): self.opaque = opaque
    def get_cascaded(self): return self.cascaded
    def set_cascaded(self, cascaded): self.cascaded = cascaded
    def get_fixedHeight(self): return self.fixedHeight
    def set_fixedHeight(self, fixedHeight): self.fixedHeight = fixedHeight
    def get_fixedWidth(self): return self.fixedWidth
    def set_fixedWidth(self, fixedWidth): self.fixedWidth = fixedWidth
    def get_noSubsets(self): return self.noSubsets
    def set_noSubsets(self, noSubsets): self.noSubsets = noSubsets
    def get_queryable(self): return self.queryable
    def set_queryable(self, queryable): self.queryable = queryable
    def export(self, outfile, level, namespace_='', name_='Layer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Layer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Layer'):
        if self.opaque is not None and 'opaque' not in already_processed:
            already_processed.append('opaque')
            outfile.write(' opaque="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.opaque)), input_name='opaque'))
        if self.cascaded is not None and 'cascaded' not in already_processed:
            already_processed.append('cascaded')
            outfile.write(' cascaded="%s"' % self.gds_format_integer(self.cascaded, input_name='cascaded'))
        if self.fixedHeight is not None and 'fixedHeight' not in already_processed:
            already_processed.append('fixedHeight')
            outfile.write(' fixedHeight="%s"' % self.gds_format_integer(self.fixedHeight, input_name='fixedHeight'))
        if self.fixedWidth is not None and 'fixedWidth' not in already_processed:
            already_processed.append('fixedWidth')
            outfile.write(' fixedWidth="%s"' % self.gds_format_integer(self.fixedWidth, input_name='fixedWidth'))
        if self.noSubsets is not None and 'noSubsets' not in already_processed:
            already_processed.append('noSubsets')
            outfile.write(' noSubsets="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.noSubsets)), input_name='noSubsets'))
        if self.queryable is not None and 'queryable' not in already_processed:
            already_processed.append('queryable')
            outfile.write(' queryable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.queryable)), input_name='queryable'))
    def exportChildren(self, outfile, level, namespace_='', name_='Layer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.Abstract is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAbstract>%s</%sAbstract>%s' % (namespace_, self.gds_format_string(quote_xml(self.Abstract).encode(ExternalEncoding), input_name='Abstract'), namespace_, eol_))
        if self.KeywordList is not None:
            self.KeywordList.export(outfile, level, namespace_, name_='KeywordList', pretty_print=pretty_print)
        for CRS_ in self.CRS:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCRS>%s</%sCRS>%s' % (namespace_, self.gds_format_string(quote_xml(CRS_).encode(ExternalEncoding), input_name='CRS'), namespace_, eol_))
        if self.EX_GeographicBoundingBox is not None:
            self.EX_GeographicBoundingBox.export(outfile, level, namespace_, name_='EX_GeographicBoundingBox', pretty_print=pretty_print)
        for BoundingBox_ in self.BoundingBox:
            BoundingBox_.export(outfile, level, namespace_, name_='BoundingBox', pretty_print=pretty_print)
        for Dimension_ in self.Dimension:
            Dimension_.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        if self.Attribution is not None:
            self.Attribution.export(outfile, level, namespace_, name_='Attribution', pretty_print=pretty_print)
        for AuthorityURL_ in self.AuthorityURL:
            AuthorityURL_.export(outfile, level, namespace_, name_='AuthorityURL', pretty_print=pretty_print)
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
        for MetadataURL_ in self.MetadataURL:
            MetadataURL_.export(outfile, level, namespace_, name_='MetadataURL', pretty_print=pretty_print)
        for DataURL_ in self.DataURL:
            DataURL_.export(outfile, level, namespace_, name_='DataURL', pretty_print=pretty_print)
        for FeatureListURL_ in self.FeatureListURL:
            FeatureListURL_.export(outfile, level, namespace_, name_='FeatureListURL', pretty_print=pretty_print)
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style', pretty_print=pretty_print)
        if self.MinScaleDenominator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinScaleDenominator>%s</%sMinScaleDenominator>%s' % (namespace_, self.gds_format_double(self.MinScaleDenominator, input_name='MinScaleDenominator'), namespace_, eol_))
        if self.MaxScaleDenominator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxScaleDenominator>%s</%sMaxScaleDenominator>%s' % (namespace_, self.gds_format_double(self.MaxScaleDenominator, input_name='MaxScaleDenominator'), namespace_, eol_))
        for Layer_ in self.Layer:
            Layer_.export(outfile, level, namespace_, name_='Layer', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Title is not None or
            self.Abstract is not None or
            self.KeywordList is not None or
            self.CRS or
            self.EX_GeographicBoundingBox is not None or
            self.BoundingBox or
            self.Dimension or
            self.Attribution is not None or
            self.AuthorityURL or
            self.Identifier or
            self.MetadataURL or
            self.DataURL or
            self.FeatureListURL or
            self.Style or
            self.MinScaleDenominator is not None or
            self.MaxScaleDenominator is not None or
            self.Layer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Layer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.opaque is not None and 'opaque' not in already_processed:
            already_processed.append('opaque')
            showIndent(outfile, level)
            outfile.write('opaque = %s,\n' % (self.opaque,))
        if self.cascaded is not None and 'cascaded' not in already_processed:
            already_processed.append('cascaded')
            showIndent(outfile, level)
            outfile.write('cascaded = %d,\n' % (self.cascaded,))
        if self.fixedHeight is not None and 'fixedHeight' not in already_processed:
            already_processed.append('fixedHeight')
            showIndent(outfile, level)
            outfile.write('fixedHeight = %d,\n' % (self.fixedHeight,))
        if self.fixedWidth is not None and 'fixedWidth' not in already_processed:
            already_processed.append('fixedWidth')
            showIndent(outfile, level)
            outfile.write('fixedWidth = %d,\n' % (self.fixedWidth,))
        if self.noSubsets is not None and 'noSubsets' not in already_processed:
            already_processed.append('noSubsets')
            showIndent(outfile, level)
            outfile.write('noSubsets = %s,\n' % (self.noSubsets,))
        if self.queryable is not None and 'queryable' not in already_processed:
            already_processed.append('queryable')
            showIndent(outfile, level)
            outfile.write('queryable = %s,\n' % (self.queryable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Abstract is not None:
            showIndent(outfile, level)
            outfile.write('Abstract=%s,\n' % quote_python(self.Abstract).encode(ExternalEncoding))
        if self.KeywordList is not None:
            showIndent(outfile, level)
            outfile.write('KeywordList=model_.KeywordList(\n')
            self.KeywordList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CRS=[\n')
        level += 1
        for CRS_ in self.CRS:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CRS_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EX_GeographicBoundingBox is not None:
            showIndent(outfile, level)
            outfile.write('EX_GeographicBoundingBox=model_.EX_GeographicBoundingBox(\n')
            self.EX_GeographicBoundingBox.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('BoundingBox=[\n')
        level += 1
        for BoundingBox_ in self.BoundingBox:
            showIndent(outfile, level)
            outfile.write('model_.BoundingBox(\n')
            BoundingBox_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Dimension=[\n')
        level += 1
        for Dimension_ in self.Dimension:
            showIndent(outfile, level)
            outfile.write('model_.Dimension(\n')
            Dimension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Attribution is not None:
            showIndent(outfile, level)
            outfile.write('Attribution=model_.Attribution(\n')
            self.Attribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AuthorityURL=[\n')
        level += 1
        for AuthorityURL_ in self.AuthorityURL:
            showIndent(outfile, level)
            outfile.write('model_.AuthorityURL(\n')
            AuthorityURL_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.Identifier(\n')
            Identifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataURL=[\n')
        level += 1
        for MetadataURL_ in self.MetadataURL:
            showIndent(outfile, level)
            outfile.write('model_.MetadataURL(\n')
            MetadataURL_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataURL=[\n')
        level += 1
        for DataURL_ in self.DataURL:
            showIndent(outfile, level)
            outfile.write('model_.DataURL(\n')
            DataURL_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FeatureListURL=[\n')
        level += 1
        for FeatureListURL_ in self.FeatureListURL:
            showIndent(outfile, level)
            outfile.write('model_.FeatureListURL(\n')
            FeatureListURL_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.Style(\n')
            Style_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MinScaleDenominator is not None:
            showIndent(outfile, level)
            outfile.write('MinScaleDenominator=%e,\n' % self.MinScaleDenominator)
        if self.MaxScaleDenominator is not None:
            showIndent(outfile, level)
            outfile.write('MaxScaleDenominator=%e,\n' % self.MaxScaleDenominator)
        showIndent(outfile, level)
        outfile.write('Layer=[\n')
        level += 1
        for Layer_ in self.Layer:
            showIndent(outfile, level)
            outfile.write('model_.Layer(\n')
            Layer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('opaque', node)
        if value is not None and 'opaque' not in already_processed:
            already_processed.append('opaque')
            if value in ('true', '1'):
                self.opaque = True
            elif value in ('false', '0'):
                self.opaque = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('cascaded', node)
        if value is not None and 'cascaded' not in already_processed:
            already_processed.append('cascaded')
            try:
                self.cascaded = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.cascaded < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('fixedHeight', node)
        if value is not None and 'fixedHeight' not in already_processed:
            already_processed.append('fixedHeight')
            try:
                self.fixedHeight = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.fixedHeight < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('fixedWidth', node)
        if value is not None and 'fixedWidth' not in already_processed:
            already_processed.append('fixedWidth')
            try:
                self.fixedWidth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.fixedWidth < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('noSubsets', node)
        if value is not None and 'noSubsets' not in already_processed:
            already_processed.append('noSubsets')
            if value in ('true', '1'):
                self.noSubsets = True
            elif value in ('false', '0'):
                self.noSubsets = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('queryable', node)
        if value is not None and 'queryable' not in already_processed:
            already_processed.append('queryable')
            if value in ('true', '1'):
                self.queryable = True
            elif value in ('false', '0'):
                self.queryable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            self.validate_Name(self.Name)    # validate type Name
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Abstract':
            Abstract_ = child_.text
            Abstract_ = self.gds_validate_string(Abstract_, node, 'Abstract')
            self.Abstract = Abstract_
        elif nodeName_ == 'KeywordList':
            obj_ = KeywordList.factory()
            obj_.build(child_)
            self.set_KeywordList(obj_)
        elif nodeName_ == 'CRS':
            CRS_ = child_.text
            CRS_ = self.gds_validate_string(CRS_, node, 'CRS')
            self.CRS.append(CRS_)
        elif nodeName_ == 'EX_GeographicBoundingBox':
            obj_ = EX_GeographicBoundingBox.factory()
            obj_.build(child_)
            self.set_EX_GeographicBoundingBox(obj_)
        elif nodeName_ == 'BoundingBox':
            obj_ = BoundingBox.factory()
            obj_.build(child_)
            self.BoundingBox.append(obj_)
        elif nodeName_ == 'Dimension':
            obj_ = Dimension.factory()
            obj_.build(child_)
            self.Dimension.append(obj_)
        elif nodeName_ == 'Attribution':
            obj_ = Attribution.factory()
            obj_.build(child_)
            self.set_Attribution(obj_)
        elif nodeName_ == 'AuthorityURL':
            obj_ = AuthorityURL.factory()
            obj_.build(child_)
            self.AuthorityURL.append(obj_)
        elif nodeName_ == 'Identifier':
            obj_ = Identifier.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
        elif nodeName_ == 'MetadataURL':
            obj_ = MetadataURL.factory()
            obj_.build(child_)
            self.MetadataURL.append(obj_)
        elif nodeName_ == 'DataURL':
            obj_ = DataURL.factory()
            obj_.build(child_)
            self.DataURL.append(obj_)
        elif nodeName_ == 'FeatureListURL':
            obj_ = FeatureListURL.factory()
            obj_.build(child_)
            self.FeatureListURL.append(obj_)
        elif nodeName_ == 'Style':
            obj_ = Style.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'MinScaleDenominator':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MinScaleDenominator')
            self.MinScaleDenominator = fval_
        elif nodeName_ == 'MaxScaleDenominator':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxScaleDenominator')
            self.MaxScaleDenominator = fval_
        elif nodeName_ == 'Layer':
            obj_ = Layer.factory()
            obj_.build(child_)
            self.Layer.append(obj_)
# end class Layer


class EX_GeographicBoundingBox(GeneratedsSuper):
    """The EX_GeographicBoundingBox attributes indicate the limits of the
    enclosing rectangle in longitude and latitude decimal degrees."""
    subclass = None
    superclass = None
    def __init__(self, westBoundLongitude=None, eastBoundLongitude=None, southBoundLatitude=None, northBoundLatitude=None):
        self.westBoundLongitude = westBoundLongitude
        self.eastBoundLongitude = eastBoundLongitude
        self.southBoundLatitude = southBoundLatitude
        self.northBoundLatitude = northBoundLatitude
    def factory(*args_, **kwargs_):
        if EX_GeographicBoundingBox.subclass:
            return EX_GeographicBoundingBox.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicBoundingBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_westBoundLongitude(self): return self.westBoundLongitude
    def set_westBoundLongitude(self, westBoundLongitude): self.westBoundLongitude = westBoundLongitude
    def validate_longitudeType(self, value):
        # Validate type longitudeType, a restriction on double.
        pass
    def get_eastBoundLongitude(self): return self.eastBoundLongitude
    def set_eastBoundLongitude(self, eastBoundLongitude): self.eastBoundLongitude = eastBoundLongitude
    def get_southBoundLatitude(self): return self.southBoundLatitude
    def set_southBoundLatitude(self, southBoundLatitude): self.southBoundLatitude = southBoundLatitude
    def validate_latitudeType(self, value):
        # Validate type latitudeType, a restriction on double.
        pass
    def get_northBoundLatitude(self): return self.northBoundLatitude
    def set_northBoundLatitude(self, northBoundLatitude): self.northBoundLatitude = northBoundLatitude
    def export(self, outfile, level, namespace_='', name_='EX_GeographicBoundingBox', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicBoundingBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_GeographicBoundingBox'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EX_GeographicBoundingBox', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.westBoundLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swestBoundLongitude>%s</%swestBoundLongitude>%s' % (namespace_, self.gds_format_double(self.westBoundLongitude, input_name='westBoundLongitude'), namespace_, eol_))
        if self.eastBoundLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seastBoundLongitude>%s</%seastBoundLongitude>%s' % (namespace_, self.gds_format_double(self.eastBoundLongitude, input_name='eastBoundLongitude'), namespace_, eol_))
        if self.southBoundLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssouthBoundLatitude>%s</%ssouthBoundLatitude>%s' % (namespace_, self.gds_format_double(self.southBoundLatitude, input_name='southBoundLatitude'), namespace_, eol_))
        if self.northBoundLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snorthBoundLatitude>%s</%snorthBoundLatitude>%s' % (namespace_, self.gds_format_double(self.northBoundLatitude, input_name='northBoundLatitude'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.westBoundLongitude is not None or
            self.eastBoundLongitude is not None or
            self.southBoundLatitude is not None or
            self.northBoundLatitude is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_GeographicBoundingBox'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.westBoundLongitude is not None:
            showIndent(outfile, level)
            # jeffdonner %e -> %s, & str()
            outfile.write('westBoundLongitude=%s,\n' % str(self.westBoundLongitude))
        if self.eastBoundLongitude is not None:
            showIndent(outfile, level)
            # jeffdonner %e -> %s, & str()
            outfile.write('eastBoundLongitude=%s,\n' % str(self.eastBoundLongitude))
        if self.southBoundLatitude is not None:
            showIndent(outfile, level)
            # jeffdonner %e -> %s, & str()
            outfile.write('southBoundLatitude=%s,\n' % str(self.southBoundLatitude))
        if self.northBoundLatitude is not None:
            showIndent(outfile, level)
            # jeffdonner %e -> %s, & str()
            outfile.write('northBoundLatitude=%s,\n' % str(self.northBoundLatitude))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'westBoundLongitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'westBoundLongitude')
            self.westBoundLongitude = fval_
            self.validate_longitudeType(self.westBoundLongitude)    # validate type longitudeType
        elif nodeName_ == 'eastBoundLongitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'eastBoundLongitude')
            self.eastBoundLongitude = fval_
            self.validate_longitudeType(self.eastBoundLongitude)    # validate type longitudeType
        elif nodeName_ == 'southBoundLatitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'southBoundLatitude')
            self.southBoundLatitude = fval_
            self.validate_latitudeType(self.southBoundLatitude)    # validate type latitudeType
        elif nodeName_ == 'northBoundLatitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'northBoundLatitude')
            self.northBoundLatitude = fval_
            self.validate_latitudeType(self.northBoundLatitude)    # validate type latitudeType
# end class EX_GeographicBoundingBox


class BoundingBox(GeneratedsSuper):
    """The BoundingBox attributes indicate the limits of the bounding box
    in units of the specified coordinate reference system."""
    subclass = None
    superclass = None
    def __init__(self, CRS=None, maxx=None, maxy=None, resx=None, minx=None, miny=None, resy=None):
        self.CRS = _cast(None, CRS)
        self.maxx = _cast(float, maxx)
        self.maxy = _cast(float, maxy)
        self.resx = _cast(float, resx)
        self.minx = _cast(float, minx)
        self.miny = _cast(float, miny)
        self.resy = _cast(float, resy)
        pass
    def factory(*args_, **kwargs_):
        if BoundingBox.subclass:
            return BoundingBox.subclass(*args_, **kwargs_)
        else:
            return BoundingBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CRS(self): return self.CRS
    def set_CRS(self, CRS): self.CRS = CRS
    def get_maxx(self): return self.maxx
    def set_maxx(self, maxx): self.maxx = maxx
    def get_maxy(self): return self.maxy
    def set_maxy(self, maxy): self.maxy = maxy
    def get_resx(self): return self.resx
    def set_resx(self, resx): self.resx = resx
    def get_minx(self): return self.minx
    def set_minx(self, minx): self.minx = minx
    def get_miny(self): return self.miny
    def set_miny(self, miny): self.miny = miny
    def get_resy(self): return self.resy
    def set_resy(self, resy): self.resy = resy
    def export(self, outfile, level, namespace_='', name_='BoundingBox', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoundingBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundingBox'):
        if self.CRS is not None and 'CRS' not in already_processed:
            already_processed.append('CRS')
            outfile.write(' CRS=%s' % (self.gds_format_string(quote_attrib(self.CRS).encode(ExternalEncoding), input_name='CRS'), ))
        if self.maxx is not None and 'maxx' not in already_processed:
            already_processed.append('maxx')
            outfile.write(' maxx="%s"' % self.gds_format_double(self.maxx, input_name='maxx'))
        if self.maxy is not None and 'maxy' not in already_processed:
            already_processed.append('maxy')
            outfile.write(' maxy="%s"' % self.gds_format_double(self.maxy, input_name='maxy'))
        if self.resx is not None and 'resx' not in already_processed:
            already_processed.append('resx')
            outfile.write(' resx="%s"' % self.gds_format_double(self.resx, input_name='resx'))
        if self.minx is not None and 'minx' not in already_processed:
            already_processed.append('minx')
            outfile.write(' minx="%s"' % self.gds_format_double(self.minx, input_name='minx'))
        if self.miny is not None and 'miny' not in already_processed:
            already_processed.append('miny')
            outfile.write(' miny="%s"' % self.gds_format_double(self.miny, input_name='miny'))
        if self.resy is not None and 'resy' not in already_processed:
            already_processed.append('resy')
            outfile.write(' resy="%s"' % self.gds_format_double(self.resy, input_name='resy'))
    def exportChildren(self, outfile, level, namespace_='', name_='BoundingBox', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BoundingBox'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CRS is not None and 'CRS' not in already_processed:
            already_processed.append('CRS')
            showIndent(outfile, level)
            outfile.write('CRS = "%s",\n' % (self.CRS,))
        if self.maxx is not None and 'maxx' not in already_processed:
            already_processed.append('maxx')
            showIndent(outfile, level)
            outfile.write('maxx = %e,\n' % (self.maxx,))
        if self.maxy is not None and 'maxy' not in already_processed:
            already_processed.append('maxy')
            showIndent(outfile, level)
            outfile.write('maxy = %e,\n' % (self.maxy,))
        if self.resx is not None and 'resx' not in already_processed:
            already_processed.append('resx')
            showIndent(outfile, level)
            outfile.write('resx = %e,\n' % (self.resx,))
        if self.minx is not None and 'minx' not in already_processed:
            already_processed.append('minx')
            showIndent(outfile, level)
            outfile.write('minx = %e,\n' % (self.minx,))
        if self.miny is not None and 'miny' not in already_processed:
            already_processed.append('miny')
            showIndent(outfile, level)
            outfile.write('miny = %e,\n' % (self.miny,))
        if self.resy is not None and 'resy' not in already_processed:
            already_processed.append('resy')
            showIndent(outfile, level)
            outfile.write('resy = %e,\n' % (self.resy,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CRS', node)
        if value is not None and 'CRS' not in already_processed:
            already_processed.append('CRS')
            self.CRS = value
        value = find_attr_value_('maxx', node)
        if value is not None and 'maxx' not in already_processed:
            already_processed.append('maxx')
            try:
                self.maxx = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (maxx): %s' % exp)
        value = find_attr_value_('maxy', node)
        if value is not None and 'maxy' not in already_processed:
            already_processed.append('maxy')
            try:
                self.maxy = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (maxy): %s' % exp)
        value = find_attr_value_('resx', node)
        if value is not None and 'resx' not in already_processed:
            already_processed.append('resx')
            try:
                self.resx = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (resx): %s' % exp)
        value = find_attr_value_('minx', node)
        if value is not None and 'minx' not in already_processed:
            already_processed.append('minx')
            try:
                self.minx = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (minx): %s' % exp)
        value = find_attr_value_('miny', node)
        if value is not None and 'miny' not in already_processed:
            already_processed.append('miny')
            try:
                self.miny = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (miny): %s' % exp)
        value = find_attr_value_('resy', node)
        if value is not None and 'resy' not in already_processed:
            already_processed.append('resy')
            try:
                self.resy = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (resy): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoundingBox


class Dimension(GeneratedsSuper):
    """The Dimension element declares the existence of a dimension and
    indicates what values along a dimension are valid."""
    subclass = None
    superclass = None
    def __init__(self, current=None, name=None, default=None, multipleValues=None, unitSymbol=None, nearestValue=None, units=None, valueOf_=None):
        self.current = _cast(bool, current)
        self.name = _cast(None, name)
        self.default = _cast(None, default)
        self.multipleValues = _cast(bool, multipleValues)
        self.unitSymbol = _cast(None, unitSymbol)
        self.nearestValue = _cast(bool, nearestValue)
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Dimension.subclass:
            return Dimension.subclass(*args_, **kwargs_)
        else:
            return Dimension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_current(self): return self.current
    def set_current(self, current): self.current = current
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_multipleValues(self): return self.multipleValues
    def set_multipleValues(self, multipleValues): self.multipleValues = multipleValues
    def get_unitSymbol(self): return self.unitSymbol
    def set_unitSymbol(self, unitSymbol): self.unitSymbol = unitSymbol
    def get_nearestValue(self): return self.nearestValue
    def set_nearestValue(self, nearestValue): self.nearestValue = nearestValue
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Dimension', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Dimension')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Dimension'):
        if self.current is not None and 'current' not in already_processed:
            already_processed.append('current')
            outfile.write(' current="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.current)), input_name='current'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.multipleValues is not None and 'multipleValues' not in already_processed:
            already_processed.append('multipleValues')
            outfile.write(' multipleValues="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.multipleValues)), input_name='multipleValues'))
        if self.unitSymbol is not None and 'unitSymbol' not in already_processed:
            already_processed.append('unitSymbol')
            outfile.write(' unitSymbol=%s' % (self.gds_format_string(quote_attrib(self.unitSymbol).encode(ExternalEncoding), input_name='unitSymbol'), ))
        if self.nearestValue is not None and 'nearestValue' not in already_processed:
            already_processed.append('nearestValue')
            outfile.write(' nearestValue="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.nearestValue)), input_name='nearestValue'))
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Dimension', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Dimension'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.current is not None and 'current' not in already_processed:
            already_processed.append('current')
            showIndent(outfile, level)
            outfile.write('current = %s,\n' % (self.current,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.multipleValues is not None and 'multipleValues' not in already_processed:
            already_processed.append('multipleValues')
            showIndent(outfile, level)
            outfile.write('multipleValues = %s,\n' % (self.multipleValues,))
        if self.unitSymbol is not None and 'unitSymbol' not in already_processed:
            already_processed.append('unitSymbol')
            showIndent(outfile, level)
            outfile.write('unitSymbol = "%s",\n' % (self.unitSymbol,))
        if self.nearestValue is not None and 'nearestValue' not in already_processed:
            already_processed.append('nearestValue')
            showIndent(outfile, level)
            outfile.write('nearestValue = %s,\n' % (self.nearestValue,))
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('current', node)
        if value is not None and 'current' not in already_processed:
            already_processed.append('current')
            if value in ('true', '1'):
                self.current = True
            elif value in ('false', '0'):
                self.current = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('multipleValues', node)
        if value is not None and 'multipleValues' not in already_processed:
            already_processed.append('multipleValues')
            if value in ('true', '1'):
                self.multipleValues = True
            elif value in ('false', '0'):
                self.multipleValues = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('unitSymbol', node)
        if value is not None and 'unitSymbol' not in already_processed:
            already_processed.append('unitSymbol')
            self.unitSymbol = value
        value = find_attr_value_('nearestValue', node)
        if value is not None and 'nearestValue' not in already_processed:
            already_processed.append('nearestValue')
            if value in ('true', '1'):
                self.nearestValue = True
            elif value in ('false', '0'):
                self.nearestValue = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Dimension


class Attribution(GeneratedsSuper):
    """Attribution indicates the provider of a Layer or collection of
    Layers. The provider's URL, descriptive title string, and/or
    logo image URL may be supplied. Client applications may choose
    to display one or more of these items. A format element
    indicates the MIME type of the logo image located at LogoURL.
    The logo image's width and height assist client applications in
    laying out space to display the logo."""
    subclass = None
    superclass = None
    def __init__(self, Title=None, OnlineResource=None, LogoURL=None):
        self.Title = Title
        self.OnlineResource = OnlineResource
        self.LogoURL = LogoURL
    def factory(*args_, **kwargs_):
        if Attribution.subclass:
            return Attribution.subclass(*args_, **kwargs_)
        else:
            return Attribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def get_LogoURL(self): return self.LogoURL
    def set_LogoURL(self, LogoURL): self.LogoURL = LogoURL
    def export(self, outfile, level, namespace_='', name_='Attribution', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Attribution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Attribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
        if self.LogoURL is not None:
            self.LogoURL.export(outfile, level, namespace_, name_='LogoURL', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Title is not None or
            self.OnlineResource is not None or
            self.LogoURL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attribution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LogoURL is not None:
            showIndent(outfile, level)
            outfile.write('LogoURL=model_.LogoURL(\n')
            self.LogoURL.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
        elif nodeName_ == 'LogoURL':
            obj_ = LogoURL.factory()
            obj_.build(child_)
            self.set_LogoURL(obj_)
# end class Attribution


class LogoURL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, height=None, Format=None, OnlineResource=None):
        self.width = _cast(int, width)
        self.height = _cast(int, height)
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if LogoURL.subclass:
            return LogoURL.subclass(*args_, **kwargs_)
        else:
            return LogoURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def export(self, outfile, level, namespace_='', name_='LogoURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogoURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogoURL'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='LogoURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LogoURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = %d,\n' % (self.width,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            showIndent(outfile, level)
            outfile.write('height = %d,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            try:
                self.width = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.width <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.append('height')
            try:
                self.height = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.height <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class LogoURL


class MetadataURL(GeneratedsSuper):
    """A Map Server may use zero or more MetadataURL elements to offer
    detailed, standardized metadata about the data underneath a
    particular layer. The type attribute indicates the standard to
    which the metadata complies. The format element indicates how
    the metadata is structured."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Format=None, OnlineResource=None):
        self.type_ = _cast(None, type_)
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if MetadataURL.subclass:
            return MetadataURL.subclass(*args_, **kwargs_)
        else:
            return MetadataURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='MetadataURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataURL'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MetadataURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class MetadataURL


class AuthorityURL(GeneratedsSuper):
    """A Map Server may use zero or more Identifier elements to list ID
    numbers or labels defined by a particular Authority. For
    example, the Global Change Master Directory (gcmd.gsfc.nasa.gov)
    defines a DIF_ID label for every dataset. The authority name and
    explanatory URL are defined in a separate AuthorityURL element,
    which may be defined once and inherited by subsidiary layers.
    Identifiers themselves are not inherited."""
    subclass = None
    superclass = None
    def __init__(self, name=None, OnlineResource=None):
        self.name = _cast(None, name)
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if AuthorityURL.subclass:
            return AuthorityURL.subclass(*args_, **kwargs_)
        else:
            return AuthorityURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='AuthorityURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuthorityURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AuthorityURL'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AuthorityURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AuthorityURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class AuthorityURL


class Identifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, authority=None, valueOf_=None):
        self.authority = _cast(None, authority)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Identifier.subclass:
            return Identifier.subclass(*args_, **kwargs_)
        else:
            return Identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authority(self): return self.authority
    def set_authority(self, authority): self.authority = authority
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Identifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Identifier'):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.append('authority')
            outfile.write(' authority=%s' % (self.gds_format_string(quote_attrib(self.authority).encode(ExternalEncoding), input_name='authority'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Identifier', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Identifier'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.append('authority')
            showIndent(outfile, level)
            outfile.write('authority = "%s",\n' % (self.authority,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.append('authority')
            self.authority = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Identifier


class DataURL(GeneratedsSuper):
    """A Map Server may use DataURL offer a link to the underlying data
    represented by a particular layer."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, OnlineResource=None):
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if DataURL.subclass:
            return DataURL.subclass(*args_, **kwargs_)
        else:
            return DataURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def export(self, outfile, level, namespace_='', name_='DataURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataURL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class DataURL


class FeatureListURL(GeneratedsSuper):
    """A Map Server may use FeatureListURL to point to a list of the
    features represented in a Layer."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, OnlineResource=None):
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if FeatureListURL.subclass:
            return FeatureListURL.subclass(*args_, **kwargs_)
        else:
            return FeatureListURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def export(self, outfile, level, namespace_='', name_='FeatureListURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureListURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeatureListURL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FeatureListURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FeatureListURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class FeatureListURL


class Style(GeneratedsSuper):
    """A Style element lists the name by which a style is requested and a
    human-readable title for pick lists, optionally (and ideally)
    provides a human-readable description, and optionally gives a
    style URL."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Title=None, Abstract=None, LegendURL=None, StyleSheetURL=None, StyleURL=None):
        self.Name = Name
        self.Title = Title
        self.Abstract = Abstract
        if LegendURL is None:
            self.LegendURL = []
        else:
            self.LegendURL = LegendURL
        self.StyleSheetURL = StyleSheetURL
        self.StyleURL = StyleURL
    def factory(*args_, **kwargs_):
        if Style.subclass:
            return Style.subclass(*args_, **kwargs_)
        else:
            return Style(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_Name(self, value):
        # Validate type Name, a restriction on string.
        pass
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Abstract(self): return self.Abstract
    def set_Abstract(self, Abstract): self.Abstract = Abstract
    def get_LegendURL(self): return self.LegendURL
    def set_LegendURL(self, LegendURL): self.LegendURL = LegendURL
    def add_LegendURL(self, value): self.LegendURL.append(value)
    def insert_LegendURL(self, index, value): self.LegendURL[index] = value
    def get_StyleSheetURL(self): return self.StyleSheetURL
    def set_StyleSheetURL(self, StyleSheetURL): self.StyleSheetURL = StyleSheetURL
    def get_StyleURL(self): return self.StyleURL
    def set_StyleURL(self, StyleURL): self.StyleURL = StyleURL
    def export(self, outfile, level, namespace_='', name_='Style', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Style')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Style'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Style', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.Abstract is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAbstract>%s</%sAbstract>%s' % (namespace_, self.gds_format_string(quote_xml(self.Abstract).encode(ExternalEncoding), input_name='Abstract'), namespace_, eol_))
        for LegendURL_ in self.LegendURL:
            LegendURL_.export(outfile, level, namespace_, name_='LegendURL', pretty_print=pretty_print)
        if self.StyleSheetURL is not None:
            self.StyleSheetURL.export(outfile, level, namespace_, name_='StyleSheetURL', pretty_print=pretty_print)
        if self.StyleURL is not None:
            self.StyleURL.export(outfile, level, namespace_, name_='StyleURL', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Title is not None or
            self.Abstract is not None or
            self.LegendURL or
            self.StyleSheetURL is not None or
            self.StyleURL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Style'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Abstract is not None:
            showIndent(outfile, level)
            outfile.write('Abstract=%s,\n' % quote_python(self.Abstract).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('LegendURL=[\n')
        level += 1
        for LegendURL_ in self.LegendURL:
            showIndent(outfile, level)
            outfile.write('model_.LegendURL(\n')
            LegendURL_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StyleSheetURL is not None:
            showIndent(outfile, level)
            outfile.write('StyleSheetURL=model_.StyleSheetURL(\n')
            self.StyleSheetURL.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StyleURL is not None:
            showIndent(outfile, level)
            outfile.write('StyleURL=model_.StyleURL(\n')
            self.StyleURL.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            self.validate_Name(self.Name)    # validate type Name
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Abstract':
            Abstract_ = child_.text
            Abstract_ = self.gds_validate_string(Abstract_, node, 'Abstract')
            self.Abstract = Abstract_
        elif nodeName_ == 'LegendURL':
            obj_ = LegendURL.factory()
            obj_.build(child_)
            self.LegendURL.append(obj_)
        elif nodeName_ == 'StyleSheetURL':
            obj_ = StyleSheetURL.factory()
            obj_.build(child_)
            self.set_StyleSheetURL(obj_)
        elif nodeName_ == 'StyleURL':
            obj_ = StyleURL.factory()
            obj_.build(child_)
            self.set_StyleURL(obj_)
# end class Style


class LegendURL(GeneratedsSuper):
    """A Map Server may use zero or more LegendURL elements to provide an
    image(s) of a legend relevant to each Style of a Layer. The
    Format element indicates the MIME type of the legend. Width and
    height attributes may be provided to assist client applications
    in laying out space to display the legend."""
    subclass = None
    superclass = None
    def __init__(self, width=None, height=None, Format=None, OnlineResource=None):
        self.width = _cast(int, width)
        self.height = _cast(int, height)
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if LegendURL.subclass:
            return LegendURL.subclass(*args_, **kwargs_)
        else:
            return LegendURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def export(self, outfile, level, namespace_='', name_='LegendURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegendURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegendURL'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='LegendURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LegendURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = %d,\n' % (self.width,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            showIndent(outfile, level)
            outfile.write('height = %d,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            try:
                self.width = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.width <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.append('height')
            try:
                self.height = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.height <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class LegendURL


class StyleSheetURL(GeneratedsSuper):
    """StyleSheeetURL provides symbology information for each Style of a
    Layer."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, OnlineResource=None):
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if StyleSheetURL.subclass:
            return StyleSheetURL.subclass(*args_, **kwargs_)
        else:
            return StyleSheetURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def export(self, outfile, level, namespace_='', name_='StyleSheetURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StyleSheetURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StyleSheetURL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StyleSheetURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StyleSheetURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class StyleSheetURL


class StyleURL(GeneratedsSuper):
    """A Map Server may use StyleURL to offer more information about the
    data or symbology underlying a particular Style. While the
    semantics are not well-defined, as long as the results of an
    HTTP GET request against the StyleURL are properly MIME-typed,
    Viewer Clients and Cascading Map Servers can make use of this. A
    possible use could be to allow a Map Server to provide legend
    information."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, OnlineResource=None):
        self.Format = Format
        self.OnlineResource = OnlineResource
    def factory(*args_, **kwargs_):
        if StyleURL.subclass:
            return StyleURL.subclass(*args_, **kwargs_)
        else:
            return StyleURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_OnlineResource(self): return self.OnlineResource
    def set_OnlineResource(self, OnlineResource): self.OnlineResource = OnlineResource
    def export(self, outfile, level, namespace_='', name_='StyleURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StyleURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StyleURL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StyleURL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFormat>%s</%sFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.Format).encode(ExternalEncoding), input_name='Format'), namespace_, eol_))
        if self.OnlineResource is not None:
            self.OnlineResource.export(outfile, level, namespace_, name_='OnlineResource', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Format is not None or
            self.OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StyleURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Format is not None:
            showIndent(outfile, level)
            outfile.write('Format=%s,\n' % quote_python(self.Format).encode(ExternalEncoding))
        if self.OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('OnlineResource=model_.OnlineResource(\n')
            self.OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'OnlineResource':
            obj_ = OnlineResource.factory()
            obj_.build(child_)
            self.set_OnlineResource(obj_)
# end class StyleURL


class simple(GeneratedsSuper):
    """Intended for use as the type of user-declared elements to make them
    simple links."""
    subclass = None
    superclass = None
    def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.title = _cast(None, title)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.show = _cast(None, show)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if simple.subclass:
            return simple.subclass(*args_, **kwargs_)
        else:
            return simple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='simple', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simple')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='simple'):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simple', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simple'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class simple


class extended(GeneratedsSuper):
    """Intended for use as the type of user-declared elements to make them
    extended links. Note that the elements referenced in the content
    model are all abstract. The intention is that by simply
    declaring elements with these as their substitutionGroup, all
    the right things will happen."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, role=None, title_attr=None, title=None, resource=None, locator=None, arc=None):
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.title_attr = _cast(None, title_attr)
        if title is None:
            self.title = []
        else:
            self.title = title
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
        if locator is None:
            self.locator = []
        else:
            self.locator = locator
        if arc is None:
            self.arc = []
        else:
            self.arc = arc
    def factory(*args_, **kwargs_):
        if extended.subclass:
            return extended.subclass(*args_, **kwargs_)
        else:
            return extended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource(self, index, value): self.resource[index] = value
    def get_locator(self): return self.locator
    def set_locator(self, locator): self.locator = locator
    def add_locator(self, value): self.locator.append(value)
    def insert_locator(self, index, value): self.locator[index] = value
    def get_arc(self): return self.arc
    def set_arc(self, arc): self.arc = arc
    def add_arc(self, value): self.arc.append(value)
    def insert_arc(self, index, value): self.arc[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def export(self, outfile, level, namespace_='', name_='extended', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='extended'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            outfile.write(' title_attr=%s' % (quote_attrib(self.title_attr), ))
    def exportChildren(self, outfile, level, namespace_='', name_='extended', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.get_title():
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for resource_ in self.get_resource():
            resource_.export(outfile, level, namespace_, name_='resource', pretty_print=pretty_print)
        for locator_ in self.get_locator():
            locator_.export(outfile, level, namespace_, name_='locator', pretty_print=pretty_print)
        for arc_ in self.get_arc():
            arc_.export(outfile, level, namespace_, name_='arc', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.title or
            self.resource or
            self.locator or
            self.arc
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='extended'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            showIndent(outfile, level)
            outfile.write('title_attr = %s,\n' % (self.title_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resource=[\n')
        level += 1
        for resource_ in self.resource:
            showIndent(outfile, level)
            outfile.write('model_.resource(\n')
            resource_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('locator=[\n')
        level += 1
        for locator_ in self.locator:
            showIndent(outfile, level)
            outfile.write('model_.locator(\n')
            locator_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('arc=[\n')
        level += 1
        for arc_ in self.arc:
            showIndent(outfile, level)
            outfile.write('model_.arc(\n')
            arc_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('title_attr', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            self.title_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
        elif nodeName_ == 'resource':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <resource> element')
            self.resource.append(obj_)
        elif nodeName_ == 'locator':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <locator> element')
            self.locator.append(obj_)
        elif nodeName_ == 'arc':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arc> element')
            self.arc.append(obj_)
# end class extended


class titleEltType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if titleEltType.subclass:
            return titleEltType.subclass(*args_, **kwargs_)
        else:
            return titleEltType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='titleEltType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='titleEltType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='titleEltType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='titleEltType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='titleEltType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class titleEltType


class resourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, title=None, role=None, label=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.type_ = _cast(None, type_)
        self.title = _cast(None, title)
        self.role = _cast(None, role)
        self.label = _cast(None, label)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resourceType.subclass:
            return resourceType.subclass(*args_, **kwargs_)
        else:
            return resourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='resourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='resourceType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='resourceType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class resourceType


class locatorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title_attr=None, label=None, href=None, role=None, type_=None, title=None):
        self.title_attr = _cast(None, title_attr)
        self.label = _cast(None, label)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.type_ = _cast(None, type_)
        if title is None:
            self.title = []
        else:
            self.title = title
    def factory(*args_, **kwargs_):
        if locatorType.subclass:
            return locatorType.subclass(*args_, **kwargs_)
        else:
            return locatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='locatorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='locatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='locatorType'):
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            outfile.write(' title_attr=%s' % (quote_attrib(self.title_attr), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='locatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.get_title():
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.title
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='locatorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            showIndent(outfile, level)
            outfile.write('title_attr = %s,\n' % (self.title_attr,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title_attr', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            self.title_attr = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
# end class locatorType


class arcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fromxx=None, title_attr=None, arcrole=None, actuate=None, to=None, show=None, type_=None, title=None):
        self.fromxx = _cast(None, fromxx)
        self.title_attr = _cast(None, title_attr)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.to = _cast(None, to)
        self.show = _cast(None, show)
        self.type_ = _cast(None, type_)
        if title is None:
            self.title = []
        else:
            self.title = title
    def factory(*args_, **kwargs_):
        if arcType.subclass:
            return arcType.subclass(*args_, **kwargs_)
        else:
            return arcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_from(self): return self.fromxx
    def set_from(self, fromxx): self.fromxx = fromxx
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='arcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='arcType'):
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            outfile.write(' title_attr=%s' % (quote_attrib(self.title_attr), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='arcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.get_title():
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.title
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='arcType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            showIndent(outfile, level)
            outfile.write('title_attr = %s,\n' % (self.title_attr,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('title_attr', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            self.title_attr = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
# end class arcType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'WMS_Capabilities'
        rootClass = WMS_Capabilities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'WMS_Capabilities'
        rootClass = WMS_Capabilities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="WMS_Capabilities",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'WMS_Capabilities'
        rootClass = WMS_Capabilities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from capabilities import *\n\n')
    sys.stdout.write('import capabilities as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Attribution",
    "AuthorityURL",
    "BoundingBox",
    "Capability",
    "ContactAddress",
    "ContactInformation",
    "ContactPersonPrimary",
    "DCPType",
    "DataURL",
    "Dimension",
    "EX_GeographicBoundingBox",
    "Exception",
    "FeatureListURL",
    "Get",
    "HTTP",
    "Identifier",
    "Keyword",
    "KeywordList",
    "Layer",
    "LegendURL",
    "LogoURL",
    "MetadataURL",
    "Name",
    "OnlineResource",
    "OperationType",
    "Post",
    "Request",
    "Service",
    "Style",
    "StyleSheetURL",
    "StyleURL",
    "WMS_Capabilities",
    "_ExtendedCapabilities",
    "arcType",
    "extended",
    "locatorType",
    "resourceType",
    "simple",
    "titleEltType"
    ]
