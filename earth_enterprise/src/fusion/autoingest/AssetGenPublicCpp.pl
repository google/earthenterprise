#!/usr/bin/perl -w-
#
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


use strict;
use FindBin;
use Getopt::Long;
use File::Basename;
use lib $FindBin::Bin;
use AssetGen;

my $help = 0;
our $thiscommand = "@ARGV";

sub usage() {
    die "usage: $FindBin::Script <.srcfile> <outputfile>\n";
}
GetOptions("help|?"    => \$help) || usage();
usage() if $help;

my $srcfile = shift;
if (!$srcfile) {
    warn "No .srcfile specified\n";
    usage();
}

my $public_cpp = shift;
if (!$public_cpp) {
    warn "No output file specified\n";
    usage();
}


# ****************************************************************************
# ***  Read .src file
# ****************************************************************************
my %config;
ReadSrcFile($srcfile, \%config);


# *****************************************************************************
# ***  ${name}AssetImpl.h
# ****************************************************************************#
EnsureDirExists($public_cpp);
my $fh;
chmod 0777, $public_cpp;
open($fh, "> $public_cpp") || die "Unable to open $public_cpp: $!\n";
EmitAutoGeneratedWarning($fh);

print $fh <<EOF;


#include "${name}Asset.h"
#include <autoingest/AssetThrowPolicy.h>
#include <khFileUtils.h>
#include <khGuard.h>
#include <khxml/khdom.h>
#include <memory>
#include <autoingest/AssetRegistry.h>
using namespace khxml;


// ****************************************************************************
// ***  Supplied from ${name}.src
// ****************************************************************************
$config{"Asset.cpp"}


// ****************************************************************************
// ***  ${name}AssetImpl - Auto generated
// ****************************************************************************
namespace {
    void GetConfig(DOMElement *elem, $config &config);
}



namespace{
    // Define the plugin interface for ${name}Asset. Clients can get
    // the interface via AssetRegistry::GetPlugin.
    auto assetPlugin =
        std::unique_ptr<AssetRegistry<AssetImpl>::AssetPluginInterface>(
            new AssetRegistry<AssetImpl>::AssetPluginInterface(
                ${name}AssetImpl::NewFromDOM,
                ${name}AssetImpl::NewInvalid
            )
        );

    // The constructor of the PluginRegistrar takes care of registering the
    // plugin for us. Using std::move because AssetPluginInterface disallows
    // copying.
    AssetRegistry<AssetImpl>::PluginRegistrar assetPluginRegistrar(
        "${name}Asset", std::move(assetPlugin));
}

extern void FromElement(DOMElement *elem, AssetStorage &self);

std::shared_ptr<${name}AssetImpl>
${name}AssetImpl::NewFromDOM(void *e)
{
    DOMElement *elem = (DOMElement*)e;
    AssetStorage storage;
    Config      config;
    FromElement(elem, storage);
    GetConfig(elem, config);
    return NewFromStorage(storage, config);
}

std::shared_ptr<${name}AssetImpl>
${name}AssetImpl::NewInvalid(const std::string &ref)
{
    AssetStorage storage;
    Config      config;
    storage.SetInvalid(ref);
    return NewFromStorage(storage, config);
}


// ****************************************************************************
// ***  ${name}AssetVersionImpl - Auto generated
// ****************************************************************************
extern void FromElement(DOMElement *elem, AssetVersionStorage &self);

namespace{
    // Define the plugin interface for ${name}AssetVersion. Clients can get
    // the interface via AssetRegistry::GetPlugin.
    auto assetVersionPlugin =
        std::unique_ptr<AssetRegistry<AssetVersionImpl>::AssetPluginInterface>(
            new AssetRegistry<AssetVersionImpl>::AssetPluginInterface(
                ${name}AssetVersionImpl::NewFromDOM,
                ${name}AssetVersionImpl::NewInvalid
            )
        );

    // The constructor of the PluginRegistrar takes care of registering the
    // plugin for us. Using std::move because AssetPluginInterface disallows
    // copying.
    AssetRegistry<AssetVersionImpl>::PluginRegistrar assetVersionPluginRegistrar(
        "${name}AssetVersion", std::move(assetVersionPlugin));
}

std::shared_ptr<${name}AssetVersionImpl>
${name}AssetVersionImpl::NewFromDOM(void *e)
{
    DOMElement *elem = (DOMElement*)e;
    AssetVersionStorage storage;
    Config      config;
    FromElement(elem, storage);
    GetConfig(elem, config);
    return NewFromStorage(storage, config);
}

std::shared_ptr<${name}AssetVersionImpl>
${name}AssetVersionImpl::NewInvalid(const std::string &ref)
{
    AssetVersionStorage storage;
    Config      config;
    storage.SetInvalid(ref);
    return NewFromStorage(storage, config);
}

std::string ${name}AssetVersionImpl::PluginName(void) const {
  return "${name}";
}


EOF


for (my $i = 0; $i < @ConfigHistory; ++$i) {
    print $fh "extern void FromElement(DOMElement *elem, $ConfigHistory[$i] &self);\n";
}

if (@ConfigHistory > 1) {
    print $fh "#include <khxml/khVersionedDOM.h>\n";
}

print $fh "namespace {\n";
print $fh "  void GetConfig(DOMElement *elem, $config &config) {\n";
if ($missingconfigok) {
    print $fh "    GetElementOrDefault(elem, \"config\", config, $config());\n";
} elsif (@ConfigHistory == 1) {
    print $fh "    GetElement(elem, \"config\", config);\n";
} else {
    my $count = @ConfigHistory;
    print $fh "    Get${count}VersionedElement<";
    for (my $i = 0; $i < @ConfigHistory; ++$i) {
        if ($i != 0) {
            print $fh "                        ";
        }
        print $fh "$ConfigHistory[$i]";
        if ($i == $#ConfigHistory) {
            print $fh "\n";
        } else {
            print $fh ",\n";
        }
    }
    print $fh "                       >(elem, \"config\", config);\n";
}
print $fh "  }\n";
print $fh "} // anonymous namespace\n\n";

    
close($fh);
chmod 0444, $public_cpp;
