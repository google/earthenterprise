// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#config Name      PacketGen
#config Base      Composite
#config Config    PacketGenConfig
#config Subtype   PacketGen
#config WithReuse 1
#config HaveExtraUpdateInfo 1
#config NoInputs 1


// ===== PacketGenAsset.h =====
#include <autoingest/.idl/storage/PacketGenConfig.h>


// ===== PacketGenAsset.cpp =====



// ===== PacketGenAssetD.h =====
#include <InsetInfo.h>

template <typename ProductAssetVersion>
class PacketGenExtraUpdateArg {
 public:
  std::vector<const InsetInfo<ProductAssetVersion>*> insetInfo;
  std::vector<const PacketGenInfo *> genInfo;
};


// ===== PacketGenAssetD.cpp =====
#include <autoingest/sysman/plugins/PacketLevelAssetD.h>
#include <autoingest/plugins/RasterProductAsset.h>
#include <autoingest/plugins/MercatorRasterProductAsset.h>
#include <chrono>


template
MutablePacketGenAssetVersionD
PacketGenFactory::ReuseOrMakeAndUpdate(
    const std::string &ref_ , AssetDefs::Type type_,
    const khMetaData &meta_,
    const PacketGenConfig& config_,
    const PacketGenExtraUpdateArg<RasterProductAssetVersion> &extra);

template
MutablePacketGenAssetVersionD
PacketGenFactory::ReuseOrMakeAndUpdate(
    const std::string &ref_ , AssetDefs::Type type_,
    const khMetaData &meta_,
    const PacketGenConfig& config_,
    const PacketGenExtraUpdateArg<MercatorRasterProductAssetVersion> &extra);

template
MutablePacketGenAssetVersionD
PacketGenFactory::ReuseOrMakeAndUpdateSubAsset(
    const std::string &parentAssetRef,
    AssetDefs::Type type_,
    const std::string &basename,
    const khMetaData &meta_,
    const PacketGenConfig& config_,
    const PacketGenExtraUpdateArg<RasterProductAssetVersion> &extra);

template
MutablePacketGenAssetVersionD
PacketGenFactory::ReuseOrMakeAndUpdateSubAsset(
    const std::string &parentAssetRef,
    AssetDefs::Type type_,
    const std::string &basename,
    const khMetaData &meta_,
    const PacketGenConfig& config_,
    const PacketGenExtraUpdateArg<MercatorRasterProductAssetVersion> &extra);

template <typename ProductAssetVersion>
void PacketGenAssetVersionImplD::UpdateChildren(
    const PacketGenExtraUpdateArg<ProductAssetVersion> &extra) {
  std::string assetRef = GetAssetRef();

  uint numLevels = config.coverage.numLevels();
  if (numLevels == 0) {
    throw khException(kh::tr("Internal Error: No levels to build"));
  }

  uint numInsets = extra.insetInfo.size();
  if (numInsets == 0) {
    throw khException(kh::tr("Internal Error: No insets"));
  }

  std::vector<MutableAssetVersionD> kids;
  kids.reserve(numLevels);

  std::chrono::high_resolution_clock::time_point prevTime = std::chrono::high_resolution_clock::now();
  std::chrono::high_resolution_clock::time_point curTime;
  std::chrono::duration<double> timeDiff; 
  notify(NFY_INFO2, "UpdateChildren starting for %s", assetRef.c_str());
  // Create my children giving them each a different level
  // Go from end to begin so we can use the results from one level to make
  // the next lower resolution level
  uint level = config.coverage.endLevel();
  while (level > config.coverage.beginLevel()) {
    --level;

    curTime = std::chrono::high_resolution_clock::now();
    // note: this will give a floating point difference in seconds
    timeDiff = std::chrono::duration<double>(curTime - prevTime);
    notify(NFY_INFO2, "UpdateChildren starting to find needed insets for level %d.  %f seconds elapsed",
           level, timeDiff.count());
    prevTime = curTime;

    // Determine which insets intersect us at this level
    const khLevelCoverage levCov(config.coverage.levelCoverage(level));
    std::vector<uint> neededIndexes;
    neededIndexes.reserve(numInsets);
    if (type == AssetDefs::Imagery) {
      FindNeededImageryInsets(khInsetCoverage(levCov),
                              extra.insetInfo, numInsets,
                              neededIndexes,
                              config.beginMinifyLevel,
                              config.endMinifyLevel);
    } else {
      FindNeededTerrainInsets(khInsetCoverage(levCov),
                              extra.insetInfo, numInsets,
                              neededIndexes,
                              config.beginMinifyLevel,
                              config.endMinifyLevel);
    }

    curTime = std::chrono::high_resolution_clock::now();
    timeDiff = std::chrono::duration<double>(curTime - prevTime);
    notify(NFY_INFO2, "UpdateChildren finished finding insets for level %d. %f seconds elapsed",
           level, timeDiff.count());
    prevTime = curTime;

    // Build most of PacketLevelConfig
    PacketLevelConfig packetLevelConfig;
    packetLevelConfig.coverage = levCov;
    packetLevelConfig.minify =
      ((level >= config.beginMinifyLevel) &&
       (level < config.endMinifyLevel));
    packetLevelConfig.skipTransparent =
      (level >= config.beginSkipTransparentLevel);

    if (type == AssetDefs::Terrain) {
      if (level < config.beginSimplifyLevel) {
        // normal processing
        // decimate from 32x32 samples (4 @ 17x17 tmeshes)
        packetLevelConfig.decimate   = true;
        packetLevelConfig.sampleSize = TmeshQuadnodeResolution;
      } else {
        uint diff = level - config.beginSimplifyLevel;
        switch (diff) {
          case 0:
            // decimate from 16x16 samples (4 @ 9x9 tmeshes)
            packetLevelConfig.decimate   = true;
            packetLevelConfig.sampleSize = TmeshQuadnodeResolution/2;
            break;
          case 1:
            // decimate from 8x8 samples (4 @ 5x5 tmeshes)
            packetLevelConfig.decimate   = true;
            packetLevelConfig.sampleSize = TmeshQuadnodeResolution/4;
            break;
          default:
            // no-decimation from 4x4 samples (4 @ 3x3 tmeshes)
            packetLevelConfig.decimate   = false;
            packetLevelConfig.sampleSize = TmeshQuadnodeResolution/8;
            break;
        }
      }
    }

    std::vector<SharedString> levInputs;
    std::vector<AssetVersion> levInputVers;
    if (!packetLevelConfig.minify) {
      // ***** Normal Blend *****

      curTime = std::chrono::high_resolution_clock::now();
      timeDiff = std::chrono::duration<double>(curTime - prevTime);
      notify(NFY_INFO2, "UpdateChildren starting normal blend for level %d.  %f seconds elapsed",
             level, timeDiff.count());
      prevTime = curTime;

      // we cache the raster if we're in the appropriate range
      // and if we've been told to (because we have alpha)
      packetLevelConfig.cacheRaster =
        (config.cacheRaster &&
         (level > config.beginMinifyLevel) &&
         (level <= config.endMinifyLevel));

      // populate inputs and inputVers & config.insets
      levInputs.reserve(neededIndexes.size());
      levInputVers.reserve(neededIndexes.size());
      packetLevelConfig.insets.reserve(neededIndexes.size());
      packetLevelConfig.attributions.reserve(neededIndexes.size());

      for (std::vector<uint>::const_iterator idx = neededIndexes.begin();
           idx != neededIndexes.end(); ++idx) {
        const InsetInfo<ProductAssetVersion> &inset(*extra.insetInfo[*idx]);
        levInputs.push_back(inset.combinedrp_->GetRef());
        levInputVers.push_back(inset.combinedrp_);
        packetLevelConfig.insets.push_back
          (PacketLevelConfig::Inset(inset.dataRPFile,
                                    inset.alphaRPFile,
                                    SharedString(), /* cached blend */
                                    SharedString()  /* cached blend alpha */));
        packetLevelConfig.attributions.push_back
          (PacketLevelConfig::Attribution(
              inset.dataRPFile,
              inset.combinedrp_->config.fuid_resource_));
      }
      curTime = std::chrono::high_resolution_clock::now();
      timeDiff = std::chrono::duration<double>(curTime - prevTime);
      notify(NFY_INFO2, "UpdateChildren normal blend level %d finished inner loop over %lu other insets.  %f seconds elapsed",
             level, neededIndexes.size(), timeDiff.count());
      prevTime = curTime;
    } else {
      // ***** Minify *****

      curTime = std::chrono::high_resolution_clock::now();
      timeDiff = std::chrono::duration<double>(curTime - prevTime);
      notify(NFY_INFO2, "UpdateChildren starting minification for level %d.  %f seconds elapsed",
             level, timeDiff.count());
      prevTime = curTime;
      // if we want to short circuit the merge with opaque product
      // tiles, fill in the info about our top product
      if (config.useOpaqueTopInsetInsteadOfMerge) {
        packetLevelConfig.mergeTopDataRP =
          extra.insetInfo.back()->dataRPFile;
        packetLevelConfig.mergeTopAlphaRP =
          extra.insetInfo.back()->alphaRPFile;
      }

      // we cache the raster only if we're in the appropriate range
      // we no longer care if the burn inset has alpha
      packetLevelConfig.cacheRaster =
        ((level > config.beginMinifyLevel) &&
         (level <= config.endMinifyLevel));

      const uint minifySrcLevel = level + 1;
      bool highestResMinify = (level+1 == config.endMinifyLevel);

      // for attribution we care about everybody
      packetLevelConfig.attributions.reserve(neededIndexes.size() + 1);
      for (std::vector<uint>::const_iterator idx = neededIndexes.begin();
           idx != neededIndexes.end(); ++idx) {
        const InsetInfo<ProductAssetVersion> &inset(*extra.insetInfo[*idx]);
        packetLevelConfig.attributions.push_back
          (PacketLevelConfig::Attribution(
              inset.dataRPFile,
              inset.combinedrp_->config.fuid_resource_));
      }

      curTime = std::chrono::high_resolution_clock::now();
      timeDiff = std::chrono::duration<double>(curTime - prevTime);
      notify(NFY_INFO2, "UpdateChildren packet level attributions for level %d finished inner loop over %lu other insets.  %f seconds elapsed",
             level, neededIndexes.size(), timeDiff.count());
      prevTime = curTime;

      // for insets we only care about those that have done work at
      // minifySrcLevel
      std::vector<uint> mergeIndexes;
      mergeIndexes.reserve(neededIndexes.size());
      for (std::vector<uint>::const_iterator idx = neededIndexes.begin();
           idx != neededIndexes.end(); ++idx) {
        if (extra.genInfo[*idx]->coverage.hasLevel(minifySrcLevel)) {
          mergeIndexes.push_back(*idx);
        }
      }

      curTime = std::chrono::high_resolution_clock::now();
      timeDiff = std::chrono::duration<double>(curTime - prevTime);
      notify(NFY_INFO2, "UpdateChildren finished adding to mergeIndexes for level %d result is %lu items.  %f seconds elapsed",
             level, mergeIndexes.size(), timeDiff.count());
      prevTime = curTime;

      // populate inputs and inputVers & config.insets
      levInputs.reserve(mergeIndexes.size() * 2 + 1);
      levInputVers.reserve(mergeIndexes.size() * 2 + 1);
      packetLevelConfig.insets.reserve(mergeIndexes.size() + 1);
      for (std::vector<uint>::const_iterator idx = mergeIndexes.begin();
           idx != mergeIndexes.end(); ++idx) {
        const InsetInfo<ProductAssetVersion> &inset(*extra.insetInfo[*idx]);
        const PacketGenInfo &genInfo(*extra.genInfo[*idx]);
        AssetVersion blendVer;
        if (!inset.alphaRPFile.empty() &&
            (genInfo.packetLevels.size() > minifySrcLevel)) {
          blendVer = genInfo.packetLevels[minifySrcLevel];
        }

        if (!blendVer) {
          // This inset doesn't have a cached blend file. This
          // will only happen for things that have no alpha mask.
          // In these cases we pull directly from the product. It
          // will also happen for the last thing on the stack who
          // hasn't had his blendvers filled in yet.
          levInputs.push_back(inset.combinedrp_->GetRef());
          levInputVers.push_back(inset.combinedrp_);

          packetLevelConfig.insets.push_back
            (PacketLevelConfig::Inset(
                inset.dataRPFile,
                inset.alphaRPFile,
                SharedString(), /* cached blend */
                SharedString()  /* cached blend alpha */));
        } else if (highestResMinify) {
          // This is the first merge (from cached blends)
          // It is possible that some of the cached blends are only
          // partially populated. So we pull from both the cached
          // blend and the product
          levInputs.push_back(inset.combinedrp_->GetRef());
          levInputVers.push_back(inset.combinedrp_);
          levInputs.push_back(blendVer.Ref());
          levInputVers.push_back(blendVer);

          // Note: Before creating a merge inset, we check if the cached alpha
          // blend directory exists for the asset since in GEE-5.x we need to
          // pick up the GEE-4.x Imagery/Terrain Projects (the PacketLevel
          // assets) that have no alpha blend cached.
          const std::string cache_alpha_path =
              blendVer->GetOutputFilename(0) + "/cache_alpha.pack";
          const bool cache_alpha_exist = khExists(cache_alpha_path);

          packetLevelConfig.insets.push_back
            (PacketLevelConfig::Inset(
                inset.dataRPFile,
                inset.alphaRPFile,
                blendVer.Ref(), /* cached blend */
                cache_alpha_exist ?
                    blendVer.Ref() : SharedString() /* cached blend alpha */));
        } else {
          // This is a subsequent merge (from cached merges) It's
          // possible that earlier merges also short circuited the
          // merge with opaque top tiles. So we may need to pull
          // from the product too.

          // NOTE: For now this case should be identical to the
          // one above. Maybe later we can put some more smarts
          // here to limit dependencies on the products?

          levInputs.push_back(inset.combinedrp_->GetRef());
          levInputVers.push_back(inset.combinedrp_);
          levInputs.push_back(blendVer.Ref());
          levInputVers.push_back(blendVer);

          // Note: Before creating a merge inset, we check if the cached alpha
          // blend directory exists for the asset since in GEE-5.x we need to
          // pick up the GEE-4.x Imagery/Terrain Projects (the PacketLevel
          // assets) that have no alpha blend cached.
          const std::string cache_alpha_path =
              blendVer->GetOutputFilename(0) + "/cache_alpha.pack";
          const bool cache_alpha_exist = khExists(cache_alpha_path);

          packetLevelConfig.insets.push_back
            (PacketLevelConfig::Inset(
                inset.dataRPFile,
                inset.alphaRPFile,
                blendVer.Ref(), /* cached blend */
                cache_alpha_exist ?
                    blendVer.Ref() : SharedString()  /* cached blend alpha */));
        }
      }

      curTime = std::chrono::high_resolution_clock::now();
      timeDiff = std::chrono::duration<double>(curTime - prevTime);
      notify(NFY_INFO2, "UpdateChildren finished looping over mergeIndexes for level %d.  %f seconds elapsed",
             level, timeDiff.count());
      prevTime = curTime;

      if (config.cacheRaster) {
        // If I've cached my raster blends, I should
        // start by trying to minify from them
        if (kids.empty()) {
          throw khException
            (kh::tr("Internal Error: No kids to minify"));
        }
        AssetVersion prevLevelVer(kids.back());

        levInputs.push_back(prevLevelVer.Ref());
        levInputVers.push_back(prevLevelVer);

        // Note: Before creating a merge inset, we check if the cached alpha
        // blend directory exists for the asset since in GEE-5.x we need to
        // pick up the GEE-4.x Imagery/Terrain Projects (the PacketLevel
        // assets) that have no alpha blend cached.
        const std::string cache_alpha_path =
            prevLevelVer->GetOutputFilename(0) + "/cache_alpha.pack";
        const bool cache_alpha_exist = khExists(cache_alpha_path);

        packetLevelConfig.insets.push_back
          (PacketLevelConfig::Inset(
              std::string() /* dataRP */,
              std::string() /* alphaRP */,
              prevLevelVer.Ref(), /* cached blend */
              cache_alpha_exist ?
                  prevLevelVer.Ref() : SharedString() /* cached blend alpha */));

        curTime = std::chrono::high_resolution_clock::now();
        timeDiff = std::chrono::duration<double>(curTime - prevTime);
        notify(NFY_INFO2, "UpdateChildren finished cacheRaster block for level %d.  %f seconds elapsed",
               level, timeDiff.count());
        prevTime = curTime;
      }

    }

    // get child asset ver
    char subname[32];
    snprintf(subname, sizeof(subname), "packlevel%02d", level);
    MutableAssetVersionD packLevelVer =
      PacketLevelFactory::ReuseOrMakeAndUpdateSubAsset
      (assetRef, type,
       subname,
       levInputs,
       khMetaData(),
       packetLevelConfig,
       levInputVers);

    kids.push_back(packLevelVer);
    curTime = std::chrono::high_resolution_clock::now();
    timeDiff = std::chrono::duration<double>(curTime - prevTime);
    notify(NFY_INFO2, "UpdateChildren finished all work for level %d.  %f seconds elapsed",
           level, timeDiff.count());
    prevTime = curTime;

  } // foreach level

  AddChildren(kids);
  curTime = std::chrono::high_resolution_clock::now();
  timeDiff = std::chrono::duration<double>(curTime - prevTime);
  notify(NFY_INFO2, "UpdateChildren finished adding all children.  %f seconds elapsed",
         timeDiff.count());
}


