// Copyright 2017 Google Inc.
// Copyright 2020 The Open GEE Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Note: need to keep this synced with RasterProject.src
//
// Changes:
// Support for terrain "overlay" projects.
//

#config Name      MercatorRasterProject
#config Base      Composite
#config Config    RasterProjectConfig
#config Subtype   MercatorProject
#config FixedType Imagery


// ===== MercatorRasterProjectAsset.h =====
#include "common/khConstants.h"
#include "common/khStringUtils.h"
#include "autoingest/.idl/storage/RasterProjectConfig.h"
#include "autoingest/.idl/storage/DatedImageryIndexInfo.h"
#include "autoingest/plugins/RasterGEIndexAsset.h"
#include "autoingest/plugins/RasterDBRootAsset.h"
#include "autoingest/plugins/MercatorRasterProductAsset.h"
#include "autoingest/plugins/MapLayerJSAsset.h"

class MercatorRasterProjectAssetVersionImpl {
 public:
  MapLayerJSAssetVersion GetLayerJSVersion(void) const {
    if (children.size() > 2) {
      AssetVersion index(children[2]);
      if (index->subtype == "MapLayerJS") {
        return children[2];
      } else {
        return MapLayerJSAssetVersion();
      }
    } else {
      return MapLayerJSAssetVersion();
    }
  }
  RasterDBRootAssetVersion GetDBRootVersion(void) const {
    if (children.size() > 1) {
      AssetVersion index(children[1]);
      if (index->subtype == "RasterDBRoot") {
        return children[1];
      } else {
        return RasterDBRootAssetVersion();
      }
    } else {
      return RasterDBRootAssetVersion();
    }
  }
  RasterGEIndexAssetVersion GetGEIndexVersion(void) const {
    if (children.size()) {
      AssetVersion index(children[0]);
      if (index->subtype == "RasterGEIndex") {
        return children[0];
      } else {
        return RasterGEIndexAssetVersion();
      }
    } else {
      return RasterGEIndexAssetVersion();
    }
  }
  // Return the most recent acquisition date from the projects.
  // imagery/terrain resources.
  // String is of form "YYYY-MM-DD".
  // If no image resources or dates are available returns "0000-00-00" for
  // "unknown date".
  std::string GetAcquisitionDate(void) const {
    std::string result(kUnknownDate);  // init to unknown
    const std::vector<InsetStackItem>& insets = config.insets;
    for(unsigned int i = 0; i < insets.size(); ++i) {
      // NOTE: the date is stored in the asset, not the version!!!
      MercatorRasterProductAsset resource(insets[i].dataAsset);
      std::string resource_date = resource->GetAcquisitionDate();
      if (resource_date != kUnknownDate) {
        if (result == kUnknownDate || resource_date.compare(result) > 0) {
          result = resource_date;
        }
      }
    }
    return result;
  }

  // Add the dated imagery indexes to the dated_imagery_indexes vector.
  // Assign the channel id for each index starting with the initial_channel_id.
  void GetDatedImageryInfo(std::uint32_t initial_channel_id,
                           std::vector<DatedImageryIndexInfo>*
                           dated_imagery_indexes) const {
    if (dated_imagery_indexes == NULL)
      return;
    std::uint32_t channel_id = initial_channel_id;
    // The first 3 children are reserved, the rest are dated imagery indexes.
    for(unsigned int i = 3; i < children.size(); ++i) {
      RasterGEIndexAssetVersion index(children[i]);
      std::string index_ref(index->GetRef());
      std::string date_string(index->config.date_string_);
      std::string index_file = index->GetOutputFilename(0);
      DatedImageryIndexInfo info(index_ref, date_string, channel_id++);
      dated_imagery_indexes->push_back(info);
    }
  }

  // Return the asset version for the specified DatedImagery Index.
  // The Dated Imagery indexes are children 3..N, but the index i is expected
  // in the range of 0...N-3.
  // If i is outside the valid range, an empty RasterGEIndexAssetVersion
  // is returned.
  RasterGEIndexAssetVersion GetDatedImageryAssetVersion(std::uint32_t i) const {
    i += 3;  // Put i in the range of 3..N
    if (i >= 3 && i < children.size())
      return children[i];
    return RasterGEIndexAssetVersion();
  }
};

// ===== MercatorRasterProjectAsset.cpp =====



// ===== MercatorRasterProjectAssetD.h =====
#include "fusion/autoingest/sysman/InsetInfo.h"
#include <limits>
#include "autoingest/plugins/MercatorRasterProductAsset.h"

class MercatorRasterProjectAssetImplD {
 protected:
  void AddInsets(const std::vector<RasterProjectModifyRequest::Item> &items);
  void SyncInputRefs(void);

  bool NeedStackUpdate(void) const;
  void UpdateStack(void);

  // this is const so it doesn't need a MutableHandle, if it needs to
  // modify itself, it will create the mutable handle
  // returns true if something changed
  bool FixConfigBeforeUpdateCheck(void) const;
  void PostUpdate(void) { IncrementIndexVersion(); }

 public:
  void IncrementIndexVersion(void) {
    // quad tree packets store unsigned short for tile versions
    config.indexVersion = (config.indexVersion + 1) %
                          std::numeric_limits<unsigned short>::max();
  }

  static void HandleEditRequest(const RasterProjectEditRequest &);
  static void HandleNewRequest(const RasterProjectModifyRequest &);
  static void HandleModifyRequest(const RasterProjectModifyRequest &);
  static void HandleAddToRequest(const RasterProjectModifyRequest &);
  static void HandleDropFromRequest(const RasterProjectDropFromRequest &);
};

class MercatorRasterProjectAssetVersionImplD {
 public:
  virtual void DependentChildren(std::vector<SharedString> &out) const;

 protected:
  // This will make my children after my inputs have succeeded
  virtual void DelayedBuildChildren(void);
 private:
  // Utility to build a single RasterGEIndex given a vector of InsetInfo.
  // Returns the version of the new geindex.
  std::uint32_t BuildIndex(
      const khTilespace &tilespace,
      const std::vector<InsetInfo<MercatorRasterProductAssetVersion> >& inset_infos);
  // Utility to load all the InsetInfos for the project.
  void LoadInsetInfoForIndexing(
      const khTilespace &tilespace,
      std::vector<InsetInfo<MercatorRasterProductAssetVersion> >* inset_infos,
      std::set<std::uint32_t>* used_provider_ids);

 public:
  template <class T>
  void LoadInsetInfo(const khTilespace &tilespace,
                     unsigned int beginCovLevel,
                     unsigned int endCovLevel,
                     std::vector<T> &insets) const;
  void LoadSimpleInsetInfo(
      const khTilespace &tilespace,
      std::vector<SimpleInsetInfo<MercatorRasterProductAssetVersion> > &insets,
      unsigned int &maxClientImageryLevel) const;
  virtual bool MustForceUpdate(void) const;
};


// ===== MercatorRasterProjectAssetD.cpp =====
#include "autoingest/sysman/plugins/MercatorRasterProductAssetD.h"
#include "autoingest/sysman/plugins/RasterGEIndexAssetD.h"
#include "autoingest/sysman/plugins/PacketGenAssetD.h"
#include "autoingest/sysman/plugins/RasterDBRootAssetD.h"
#include "autoingest/sysman/plugins/MapLayerJSAssetD.h"
#include "autoingest/Misc.h"
#include "autoingest/sysman/.idl/FusionUniqueId.h"
#include <set>
#include <algorithm>
#include "fusion/khraster/khRasterProduct.h"
#include "common/khTileAddr.h"
#include "common/khConstants.h"
#include <third_party/rfc_uuid/uuid.h>


void MercatorRasterProjectAssetImplD::AddInsets(
    const std::vector<RasterProjectModifyRequest::Item> &items) {
  // make a set of those that I already have
  std::set<std::string> have;

  for (const auto& inset : config.insets) {
    have.insert(inset.dataAsset);
  }

  // process each of the items to add
  for (const auto& item : items) {
    // error if there's anything I already have
    if (have.find(item.dataAsset) != have.end()) {
      throw khException(kh::tr("Project already has inset '%1'")
                        .arg(item.dataAsset.c_str()));
    }

    // figure out what its levels should be
    unsigned int effectivemax = ComputeEffectiveMaxLevel(item);

    // walk backwards until we find where to insert it
    std::vector<InsetStackItem>::reverse_iterator where;
    for (where = config.insets.rbegin(); where != config.insets.rend();
         ++where) {
      if (where->maxlevel <= effectivemax)
        break;
    }

    // now put it where it belongs
    // Remember: since 'where' is a reverse iterator, 'where.base()' is
    // one after 'where' (in the forward sense). Since insert is insert
    // before, where.base is exactly what we want.
    config.insets.insert(where.base(), InsetStackItem(item.dataAsset,
                                                      effectivemax,
                                                      item.overridemax));

    // update my "have" set so I won't try to add the same one again
    have.insert(item.dataAsset);
  }

  SyncInputRefs();
}


void MercatorRasterProjectAssetImplD::SyncInputRefs(void) {
  // update my inputs based on which layers have assetRefs
  inputs.clear();
   for (const auto& inset : config.insets) {
    inputs.push_back(inset.dataAsset);
  }
}


bool MercatorRasterProjectAssetImplD::FixConfigBeforeUpdateCheck(void) const {
  bool changed = false;
  if (config.fuid_channel_ == 0) {
    MutableMercatorRasterProjectAssetD self(GetRef());
    self->config.fuid_channel_ = FusionUniqueId::Get(FusionUniqueId::Channel);
    self->config.AssignUuidIfEmpty();
    changed = true;
  } else if (config.asset_uuid_ == "") {
    MutableMercatorRasterProjectAssetD self(GetRef());
    self->config.AssignUuidIfEmpty();
    changed = true;
  }
  if (NeedStackUpdate()) {
    MutableMercatorRasterProjectAssetD self(GetRef());
    self->UpdateStack();
    changed = true;
  }
  return changed;
}

bool MercatorRasterProjectAssetImplD::NeedStackUpdate(void) const {
  unsigned int newmax[config.insets.size()];
  for (unsigned int i = 0; i < config.insets.size(); ++i) {
    unsigned int effectivemax = ComputeEffectiveMaxLevel(config.insets[i]);

    if (effectivemax != config.insets[i].maxlevel) {
      // The effective max has changed, we must update
      return true;
    }

    if ((i > 0) && (effectivemax < newmax[i-1])) {
      // The stack is out of order, we must update
      return true;
    }
    newmax[i] = effectivemax;
  }

  return false;
}

void MercatorRasterProjectAssetImplD::UpdateStack(void) {
  // see if the effective maxlevel has changed for anything in inset stack
  bool changed = false;
  for (auto& inset : config.insets) {
    unsigned int effectivemax = ComputeEffectiveMaxLevel(inset);
    if (effectivemax != inset.maxlevel) {
      inset.maxlevel = effectivemax;
      changed = true;
    }
  }

  // walk backwards through the stack and make sure that everybody's
  // in the right place
  for (int i = config.insets.size() - 2; i >= 0; --i) {
    if (config.insets[i].maxlevel > config.insets[i+1].maxlevel) {
      unsigned int j = i+2;
      for (; j < config.insets.size(); ++j) {
        if (config.insets[i].maxlevel <=
            config.insets[j].maxlevel) {
          break;
        }
      }

      // extract it and put it where I want it
      InsetStackItem tomove = config.insets[i];
      config.insets.erase(config.insets.begin()+i);
      config.insets.insert(config.insets.begin()+j-1, tomove);

      changed = true;
    }
  }

  if (changed) {
    SyncInputRefs();
  }
}


void MercatorRasterProjectAssetImplD::HandleEditRequest(
    const RasterProjectEditRequest &req) {
  // Make sure the assetRef's are valid.
  for (const auto& inset : req.config.insets) {
    ValidateRefForInput<MercatorRasterProductType>(inset.dataAsset);
  }

  // Find/make our target project.
  std::string projname =
    khEnsureExtension(req.assetname,
                      AssetDefs::FileExtension(req.type,
                                               kMercatorProjectSubtype));

  // Will be filled in later.
  std::vector<SharedString> inputs;

  // Custom FindMake - modified to set/preserve indexVersion & fuid_channel_.
  MutableMercatorRasterProjectAssetD project =
      Find<MercatorRasterProjectType>(projname);
  if (project) {
    // It is a regular (editing the same asset) or "SaveAs" re-writing edit
    // request.

    // If this edit request is going to set the fuid_channel_ back to zero,
    // recover the previous version of asset config.
    // Make a copy we can play with.
    RasterProjectConfig projConfig = req.config;
    if (projConfig.fuid_channel_ == 0) {
      projConfig.fuid_channel_ = project->config.fuid_channel_;
    }
    // Similarly recover the asset_uuid from previous version of the asset
    // config.
    if (projConfig.asset_uuid_.empty()) {
      projConfig.asset_uuid_ = project->config.asset_uuid_;
    }
    project->config.is_timemachine_project_ =
        projConfig.is_timemachine_project_;

    // We must preserve the indexVersion since the GUI doesn't/can't.
    // TODO: we really should split this RasterProjectConfig into two pieces.
    projConfig.indexVersion = project->config.indexVersion;
    project->Modify(inputs, req.meta, projConfig);
  } else {
    // It is a "Save" or "SaveAs" edit request when creating a new asset.
    assert(req.config.indexVersion == 1);
    project = Make<MercatorRasterProjectType>(projname, inputs,
                                                 req.meta, req.config);
  }

  if (!project)
    throw khException(kh::tr("Unable to create %1 project %2")
                      .arg(ToQString(req.type), ToQString(projname)));

  project->UpdateStack();

  // Note: UpdateStack() only calls SyncInputRefs if it has to modify
  // the stack. This function needs to make sure SyncInputRefs is always called.
  project->SyncInputRefs();
}


void MercatorRasterProjectAssetImplD::HandleNewRequest(
    const RasterProjectModifyRequest &req) {
  // verify the assets before I create anything
  for (const auto& item : req.items) {
    ValidateRefForInput<MercatorRasterProductType>(item.dataAsset);
  }

  // normalize the supplied asset name
  std::string projname =
    AssetDefs::NormalizeAssetName(req.assetname, req.type,
                                  kMercatorProjectSubtype);


  if (Find<MercatorRasterProjectType>(projname)) {
    throw khException(kh::tr("%1 project %2 already exists")
                      .arg(ToQString(req.type), ToQString(projname)));
  } else {
    // make it
    RasterProjectConfig projConfig(req.type);
    MutableMercatorRasterProjectAssetD project =
      Make<MercatorRasterProjectType>(projname,
                                 std::vector<SharedString>(),
                                 khMetaData(),
                                 projConfig);

    project->AddInsets(req.items);
  }
}


void MercatorRasterProjectAssetImplD::HandleModifyRequest(
    const RasterProjectModifyRequest &req) {
  // verify the assets before I do anything else
  for (const auto& item : req.items) {
    ValidateRefForInput<MercatorRasterProductType>(item.dataAsset);
  }

  // find it and make the change
  MutableMercatorRasterProjectAssetD project;
  if ((project = Find<MercatorRasterProjectType>(req.assetname))) {
    // blow away old insets
    project->config.insets.clear();
    // define new ones
    project->AddInsets(req.items);
  } else {
    throw khException(kh::tr("No %1 project named %2")
                      .arg(ToQString(req.type), ToQString(req.assetname)));
  }
}


void MercatorRasterProjectAssetImplD::HandleAddToRequest(
    const RasterProjectModifyRequest &req) {
  // verify the assets before I do anything else
  for (const auto& item : req.items) {
    ValidateRefForInput<MercatorRasterProductType>(item.dataAsset);
  }

  // find it and make the change
  MutableMercatorRasterProjectAssetD project;
  if ((project = Find<MercatorRasterProjectType>(req.assetname))) {
    // make sure my existing insets are still in order before adding more
    // a new version of a product asset could invalidate
    // my stacking order
    project->UpdateStack();

    // define new ones
    project->AddInsets(req.items);
  } else {
    throw khException(kh::tr("No %1 project named %2")
                      .arg(ToQString(req.type), ToQString(req.assetname)));
  }
}


void MercatorRasterProjectAssetImplD::HandleDropFromRequest(
    const RasterProjectDropFromRequest &req) {
  // find the project
  MutableMercatorRasterProjectAssetD project;
  if (!(project = Find<MercatorRasterProjectType>(req.assetname))) {
    throw khException(kh::tr("No %1 project named %2")
                      .arg(ToQString(req.type), ToQString(req.assetname)));
  }

  // check for valid asset refs
  std::set<std::string> todrop;
  for (const auto& r : req.productRefs) {
    if (std::find_if(project->config.insets.begin(),
                     project->config.insets.end(),
                     mem_var_pred_ref<std::equal_to>
                     (&InsetStackItem::dataAsset, r)) ==
        project->config.insets.end()) {
      throw khException(kh::tr("Project doesn't have inset '%1'")
                        .arg(r.c_str()));
    } else {
      todrop.insert(r);
    }

  }

  // generate a list of the ones we want to keep and stuff it back into the
  // config
  std::vector<InsetStackItem> tokeep;
  tokeep.reserve(project->config.insets.size());
  for (std::vector<InsetStackItem>::const_iterator inset =
         project->config.insets.begin();
       inset != project->config.insets.end(); ++inset) {
    if (todrop.find(inset->dataAsset) == todrop.end()) {
      // this one's not in the list to drop, so copy it over
      tokeep.push_back(*inset);
    }
  }
  project->config.insets = tokeep;
  project->SyncInputRefs();
}



void MercatorRasterProjectAssetVersionImplD::DependentChildren(
    std::vector<SharedString> &out) const {
  if (children.size()) {
    // my direct children are my index and optionally a copyright
    std::copy(children.begin(), children.end(), back_inserter(out));

    // additionally, my indexes' inputs are my sub assets as well
    for(unsigned int i = 0; i < children.size(); ++i) {
      AssetVersion index(children[i]);
      if (index->subtype == "RasterGEIndex") {
        index->GetInputs(back_inserter(out));
      }
    }
  }
}

// Don't do anything for UpdateChildren - we defer to DelayedBuildChildren
void MercatorRasterProjectAssetVersionImplD::UpdateChildren(void) {
  const unsigned int numInsets = inputs.size();

  if (numInsets == 0) {
    throw khException(kh::tr("No insets defined for project %1.\n"
                             "Cannot build").arg(GetRef().toString().c_str()));
  }
}

template <class T>
void MercatorRasterProjectAssetVersionImplD::LoadInsetInfo(
    const khTilespace &tilespace,
    unsigned int beginCovLevel,
    unsigned int endCovLevel,
    std::vector<T> &insets) const {
  // Load my input versions (will reuse list populated by caller)
  InputVersionGuard guard(this);

  unsigned int numInsets = inputs.size();
  insets.reserve(numInsets);
  for (unsigned int i = 0; i < numInsets; ++i) {
    insets.push_back(T
                     (tilespace,
                      guard->inputvers[i].Ref(),
                      guard->inputvers[i]->children[0],
                      config.insets[i].maxlevel,
                      beginCovLevel,
                      endCovLevel));
  }
}

void MercatorRasterProjectAssetVersionImplD::LoadSimpleInsetInfo(
    const khTilespace &tilespace,
    std::vector<SimpleInsetInfo<MercatorRasterProductAssetVersion> > &insets,
    unsigned int &maxClientImageryLevel) const {
  LoadInsetInfo(tilespace, 0, 0, insets);

  maxClientImageryLevel = ProductToImageryLevel(config.insets.back().maxlevel);
}

bool MercatorRasterProjectAssetVersionImplD::MustForceUpdate(void) const {
  if (children.size()) {
    // my first child is my index
    AssetVersion index = children[0];

    // Make sure the index is the new RasterGEIndex (not the old RasterKHDB)
    if (index->subtype != "RasterGEIndex") {
      return true;
    }
  }
  return false;
}


// ***** explicit instantiations *****
template
void MercatorRasterProjectAssetVersionImplD::LoadInsetInfo<
  SimpleInsetInfo<MercatorRasterProductAssetVersion> >(
    const khTilespace &tilespace,
    unsigned int beginCovLevel,
    unsigned int endCovLevel,
    std::vector<SimpleInsetInfo<
      MercatorRasterProductAssetVersion> > &insets) const;

template
void MercatorRasterProjectAssetVersionImplD::LoadInsetInfo<
  InsetInfo<MercatorRasterProductAssetVersion> > (
    const khTilespace &tilespace,
    unsigned int beginCovLevel,
    unsigned int endCovLevel,
    std::vector<InsetInfo<
      MercatorRasterProductAssetVersion> > &insets) const;

void MercatorRasterProjectAssetVersionImplD::DelayedBuildChildren(void) {
  std::string assetRef = GetAssetRef();

  // short circuit on degenerate case. Do this so the rest of the code
  // can assume that there is at least one inset.
  const unsigned int numInsets = inputs.size();
  if (numInsets == 0) {
    throw khException(kh::tr("No insets defined for project %1.\n"
                             "Cannot build").arg(GetRef().toString().c_str()));
  }

  // sanity check in case the previous logic to ensure a valid channel id
  // fails
  if (config.fuid_channel_ == 0) {
    throw khException(kh::tr("Internal Error: No channel id for %1")
                      .arg(GetRef().toString().c_str()));
  }

  if (config.asset_uuid_ == "") {
    throw khException(kh::tr("Internal Error: No UUID for %1")
                      .arg(GetRef().toString().c_str()));
  }


  // Load my input versions (will reuse list populated by caller)
  InputVersionGuard guard(this);

  // figure out which tilespace to work in
  const khTilespace &tilespace((type == AssetDefs::Imagery) ?
                               ClientImageryTilespaceMercator :
                               ClientTmeshTilespaceMercator);

  // TODO:  fix test for timemachine authorization
  bool create_timemachine = config.is_timemachine_project_;  // && timemachine enabled
  // Load InsetInfo and provider id's just once.
  // TimeMachine will create N geindex's so we don't want to duplicate work
  // if possible.
  std::vector<InsetInfo<MercatorRasterProductAssetVersion> > inset_infos;
  std::set<std::uint32_t> used_provider_ids;
  LoadInsetInfoForIndexing(tilespace, &inset_infos, &used_provider_ids);

  if (create_timemachine && inset_infos.size() > 1) {
    // First sort the layers by date, then level
    //   order is : oldest first then lowest res first.
    // Leave the base globe layer as the last Inset.
    std::vector<InsetInfo<MercatorRasterProductAssetVersion> >::iterator iter =
        inset_infos.begin();
    // Set the base layer to be the oldest date.
    iter->date_string_ = kTimeMachineOldestDateString;
    std::sort(iter, inset_infos.end(),
              SimpleInsetInfo<MercatorRasterProductAssetVersion>::Compare);

    // For debugging, print a list of the sorted insets.
    notify(NFY_DEBUG,
       "TimeMachine Imagery Insets sorted by date then level:\n");
    for(unsigned int i = 0; i < inset_infos.size(); ++i) {
      notify(NFY_DEBUG,
             "  Historical Inset: %d %s, level %d, start date: %s\n",
             i,
             inset_infos[i].resource_->GetRef().toString().c_str(),
             inset_infos[i].effectiveMaxLevel,
             inset_infos[i].date_string_.c_str());
    }
  }
  // ---------------------------
  // make the Top Level Imagery index
  // Always build the topmost index 1st.
  // needs to be children[0]...code above assumes this (not nice).
  // ---------------------------
  std::uint32_t geindex_version = BuildIndex(tilespace, inset_infos);

  // ---------------------------
  // make RasterDBRoot sub asset
  // needs to be children[1]...code above assumes this (not nice).
  // ---------------------------
  RasterDBRootAssetConfig dbrootConfig;
  dbrootConfig.layers_.resize(1);
  dbrootConfig.layers_[0].legend_     = config.legend;
  dbrootConfig.layers_[0].asset_uuid_ = config.asset_uuid_;
  dbrootConfig.layers_[0].channel_id_ =
    (type == (AssetDefs::Imagery))
    ? kGEImageryChannelId
    : kGETerrainChannelId;
  dbrootConfig.used_provider_ids_ = used_provider_ids;

  MutableAssetVersionD dbroot =
    FindMakeAndUpdateSubAsset<RasterDBRootType>
                 (assetRef,
                  type,
                  "dbroot",
                  std::vector<SharedString>(),
                  khMetaData(),
                  dbrootConfig,
                  std::vector<AssetVersion>());
  AddChild(dbroot);


  // **********************************
  // create my Map JS layer definitions - only for imagery
  // needs to be children[2]...code above assumes this (not nice).
  // **********************************
  if (type == AssetDefs::Imagery) {
    std::string layerJSAssetName(MapLayerJSFactory::SubAssetName(assetRef,
                                                                 "layerjs"));
    MapLayerJSConfig layerJSConfig;
    layerJSConfig.layers_.push_back(
        MapLayerJSConfig::Layer(
            MapLayerJSConfig::Layer::Imagery,
            MapLayerJSConfig::Layer::MercatorProjection,
            config.fuid_channel_,
            geindex_version,
            config.legend));
    MutableAssetVersionD layerjs =
      FindMakeAndUpdate<MapLayerJSType>
                        (layerJSAssetName,
                         std::vector<SharedString>(),
                         khMetaData(),
                         layerJSConfig,
                         std::vector<AssetVersion>());
    AddChild(layerjs);
  }

  // ---------------------------
  // make the Dated Imagery Layers indexes
  // needs to be children[3]...code above assumes this (not nice).
  // ---------------------------
  if (create_timemachine && inset_infos.size() > 1) {
    // For timemachine, we want to generate the remaining date layers by peeling
    // off the insets for each date.
    std::vector<InsetInfo<
      MercatorRasterProductAssetVersion> >::const_reverse_iterator last_iter =
          inset_infos.rbegin();
    std::string previous_date = last_iter->date_string_;
    inset_infos.pop_back();  // Remove the first inset as we've
                             // generated that index already.
    while(inset_infos.size() > 0) {  // We want to generate a TM layer for
                                     // the base map (which should be the last
                                     // inset in the list.
      last_iter = inset_infos.rbegin();
      const std::string& date = last_iter->date_string_;
      if (date != previous_date) {
        BuildIndex(tilespace, inset_infos);
      }
      previous_date = date;
      inset_infos.pop_back();  // Remove the last inset
    }
  }
}

void MercatorRasterProjectAssetVersionImplD::LoadInsetInfoForIndexing(
    const khTilespace &tilespace,
    std::vector<InsetInfo<MercatorRasterProductAssetVersion> >* inset_infos,
    std::set<std::uint32_t>* used_provider_ids) {
  // get the range of levels that we're going to generate
  const unsigned int beginProjectLevel =
      (type == AssetDefs::Imagery) ? StartImageryLevel :
         ((config.is_overlay_terrain_project_ &&
           config.overlay_terrain_start_level_ > StartTmeshLevel) ?
          config.overlay_terrain_start_level_ : StartTmeshLevel);

  // "+1" since endLevel is "one beyond" max for constructor khInsetCoverage.
  // The endProjectLevel is used below for create the khInsetCoverage-object
  // in InsetInfo-constructor.
  const unsigned int endProjectLevel =
    TranslateTileLevel(RasterProductTilespaceMercator,
                       config.insets.back().maxlevel + 1,
                       tilespace);

  // Load more info about all of the project's insets
  LoadInsetInfo(tilespace, beginProjectLevel, endProjectLevel, *inset_infos);

  // make an array of all the resource version refs
  // this is needed by the DBRoot generator
  // while we're at it makes the map of fuid -> provider id for the indexer
  for (const auto& i : *inset_infos) {
    if (i.resource_->config.provider_id_ != 0) {
      used_provider_ids->insert(i.resource_->config.provider_id_);
    }
  }
}

 std::uint32_t MercatorRasterProjectAssetVersionImplD::BuildIndex(
    const khTilespace &tilespace,
    const std::vector<InsetInfo<
      MercatorRasterProductAssetVersion> >& inset_infos) {
  // Check that we have at least one inset.
  const unsigned int numInsets = inset_infos.size();
  if (numInsets == 0) {
    throw khException(kh::tr("Attempt to build index with too few "
                             "insets for project: %1.\n"
                             "Cannot build").arg(GetRef().toString().c_str()));
  }

  const auto last_iter = inset_infos.rbegin();
  const std::string& date = last_iter->date_string_;
  notify(NFY_DEBUG, "Building GERasterIndex: %llu insets, level %d for %s\n",
    static_cast<unsigned long long>(inset_infos.size()),
    last_iter->effectiveMaxLevel, date.c_str());

  // get the range of levels that we're going to generate
  const unsigned int beginProjectLevel =
      (type == AssetDefs::Imagery) ? StartImageryLevel :
         ((config.is_overlay_terrain_project_ &&
           config.overlay_terrain_start_level_ > StartTmeshLevel) ?
         config.overlay_terrain_start_level_ : StartTmeshLevel);

  // All levels at a resolution lower than the fullresLevel of our lowest
  // resolution inset can be minified instead of blended. This increases
  // speed, reduces grey line artifacts around insets, and generally
  // increases low res image quality.
  const unsigned int beginMinifyLevel  = (MiscConfig::Instance().UseMinification
                                        ? beginProjectLevel
                                        : 0);
  const unsigned int endMinifyLevel    = (MiscConfig::Instance().UseMinification
                                        ? inset_infos[0].effectiveMaxLevel
                                        : 0);

  // Calc the info about what work to do
  std::vector<PacketGenInfo> genInfo;
  CalcPacketGenInfo(tilespace, type, inset_infos,
                    beginProjectLevel,
                    genInfo,
                    0 /* maxLevelDelta - always 0 here, only differs for SS*/,
                    config.is_overlay_terrain_project_,
                    config.overlay_terrain_resources_min_level_);

  // ----------
  // Skipping transparent tiles _could_ cause problems with the way the
  // client currently required full resolution coverage for levels of
  // detail. Always emitting square regions will also make future indexing
  // optimizations easier.
  // ----------



  // lets see which levels we can allow to skip transparent tiles.
  // We can only do this for imagery, the client can't magnify low res
  // meshes to fill in for missing high res ones.
  // We are only allowed to skip transparent tiles if no other inset has
  // cut it's blend levels short because we're going to do work for it.
  if (type == AssetDefs::Imagery) {
    // first we know that we don't want skip tiles during minification
    // so set each inset to start after that

    for (auto& i : genInfo) {
        i.beginSkipTransparentLevel =
        std::max(endMinifyLevel, i.coverage.beginLevel());
    }

    // Now let's go see which insets had their work coverage narrowed
    for (unsigned int i = 0; i < genInfo.size(); ++i) {
      unsigned int narrowedBegin = genInfo[i].coverage.beginLevel();
      if (narrowedBegin > beginProjectLevel) {
        // this inset's coverage got narrowed - we need to adjust
        // the skip transparent levels for those after it
        for (unsigned int j = i+1; j < genInfo.size(); ++j) {

          // NOTE:
          // Since all the genInfos' coverages were initially
          // created with the same level ranges, we know that we
          // can do the levelExtents indexing below w/o worrying
          // about stepping off either end of the coverage levels.

          // We check each level deferred by the narrowed inset
          // that this inset was planning on skipping
          unsigned int beginCheckLevel =
            genInfo[j].beginSkipTransparentLevel;
          unsigned int endCheckLevel = narrowedBegin;
          for (unsigned int checkLevel = beginCheckLevel;
               checkLevel < endCheckLevel; ++checkLevel) {
            if (genInfo[j].coverage.hasLevel(checkLevel) &&
                (genInfo[j].coverage.levelExtents(checkLevel)
                 .intersects
                 (genInfo[i].coverage.levelExtents(checkLevel)))) {
              genInfo[j].beginSkipTransparentLevel =
                checkLevel+1;
            } else {
              // due to stepout and minification logic,
              // we know that if this level doesn't intersect
              // then none of the following (higher res) ones
              // will intersect either.
              break;
            }
          }
        }
      }
    }
  }

  // make a copy of the inset_infos w/ pointers. The FindNeeded*
  // routines want pointers.
  std::vector<const InsetInfo<
    MercatorRasterProductAssetVersion> *> insetInfoPtrs;
  insetInfoPtrs.reserve(inset_infos.size());

  for (const auto& i : inset_infos) {
      insetInfoPtrs.push_back(&i);
  }

  // create my children giving them each a bigger piece of the stack
  std::vector<SharedString> packgenkids;
  std::vector<std::string> packgenassets;
  std::vector<AssetVersion> packgenvers;
  packgenkids.reserve(numInsets);
  packgenassets.reserve(numInsets);
  packgenvers.reserve(numInsets);

  for (unsigned int i = 0; i < genInfo.size(); ++i) {
    // Check if I even need to do any packet generation at all
    // Maybe the other insets will completely replace everything
    // that this one would generate
    if (genInfo[i].coverage.numLevels() == 0)
      continue;


    // Determine which insets (0 .. i) intersect this coverage area.
    std::vector< unsigned int>  neededIndexes;
    neededIndexes.reserve(i);

    overlapEnvelope<MercatorRasterProductAssetVersion> env (
        type, insetInfoPtrs, i,
        beginMinifyLevel, endMinifyLevel, i);

    std::shared_ptr<OverlapCalculator<MercatorRasterProductAssetVersion>> calc =
        std::make_shared<OverlapCalculator<MercatorRasterProductAssetVersion>>(env);
    neededIndexes = std::move(calc->PreprocessForInset(genInfo[i].coverage));
    neededIndexes.push_back(i); // each inset always intersects itself


    // calculate the level range that will be minified
    unsigned int effectiveBeginMinifyLevel = (MiscConfig::Instance().UseMinification
                                      ? std::max(genInfo[i].coverage.beginLevel(), beginMinifyLevel)
                                      : 0);
    unsigned int effectiveEndMinifyLevel = (MiscConfig::Instance().UseMinification
                                    ? std::min(genInfo[i].coverage.endLevel(), endMinifyLevel)
                                    : 0);

    // Build a PacketGenConfig
    PacketGenConfig packetGenConfig;
    packetGenConfig.coverage  = genInfo[i].coverage;
    packetGenConfig.beginMinifyLevel = beginMinifyLevel;
    packetGenConfig.endMinifyLevel   = endMinifyLevel;
    packetGenConfig.cacheRaster      = !inset_infos[i].alphaRPFile.empty();
    packetGenConfig.beginSkipTransparentLevel =
      genInfo[i].beginSkipTransparentLevel;
    packetGenConfig.useOpaqueTopInsetInsteadOfMerge = true;
    packetGenConfig.insets.reserve(neededIndexes.size());

    for (const auto& idx : neededIndexes) {
      const PacketGenInfo &otherGenInfo(genInfo[idx]);

      // +1 below since we minify from the next level
      bool otherWillContribToMinify =
        otherGenInfo.coverage.intersectsLevels
        (effectiveBeginMinifyLevel+1,
         effectiveEndMinifyLevel+1);

      // see if we want to depend on the packgen for this guy
      // packetgenverref will only be populated if the other one
      // actually cached raster blends.
      std::string packgenVerRef;
      if (!otherGenInfo.packetgenverref.empty() &&
          otherWillContribToMinify) {
        packgenVerRef = otherGenInfo.packetgenverref;
      }

      packetGenConfig.insets.push_back
        (PacketGenConfig::Inset
         (inset_infos[idx].combinedrp_.Ref(),
          packgenVerRef));
    }

    // Build a PacketGenExtraUpdateArg
    PacketGenExtraUpdateArg<MercatorRasterProductAssetVersion> extraArg;
    extraArg.insetInfo.reserve(neededIndexes.size());
    extraArg.genInfo.reserve(neededIndexes.size());
    extraArg.calc = calc;
    for (const auto& idx : neededIndexes) {
      extraArg.insetInfo.push_back(&inset_infos[idx]);
      extraArg.genInfo.push_back(&genInfo[idx]);
    }

      // reuse or make a new PacketGenAssetVersion
      MutableAssetVersionD packgen =
        ReuseOrMakeAndUpdate<PacketGenType>(genInfo[i].assetname,
                                               type,
                                               khMetaData(),
                                               packetGenConfig,
                                               extraArg);

    if (packetGenConfig.cacheRaster) {
      // Extract the PacketLevel children from the new version and store
      // them in my genInfo. My later children will use these to help
      // build their own Packetlevel asset versions
      genInfo[i].PopulatePacketLevels(packgen);
    }

    // remember this new PacketGen version
    packgenkids.push_back(packgen->GetRef());
    packgenassets.push_back(packgen->GetAssetRef());
    packgenvers.push_back(packgen);
  }


  // ------------------------
  // make index sub asset
  // ------------------------
  std::string assetRef = GetAssetRef();
  std::string dbname = khDropExtension(khBasename(assetRef));
  RasterGEIndexConfig geindexConfig;
  geindexConfig.db_name_ = dbname;
  //  figure out the packetvers for the geindex
  unsigned int indexVer = config.indexVersion;
  bool tryReuse = true;
  // For time machine, dated imagery indexes,
  // use "YYYY/MM/DD/[MS/]geindex..." for the index path. [MS/] is optional.
  // If date is undefined, use "geindex..."
  // Using the date is a little arbitrary but provides a way to store
  // lots of indexes without flooding a single directory.
  std::string subpath = "geindex";
  if (!date.empty() && date != kUnknownDate) {
    struct tm time = {0};
    if (ParseUTCTime(date, &time)) {
      std::string date_path = khComposeTimePath(time);
      subpath = khComposePath(date_path, subpath);
      geindexConfig.date_string_ = GetUTCTimeString(time);
    } else {
      notify(NFY_WARN, "Building index sub asset: Unable to parse a Date - "
             "interpret it as Unknown.");
    }
  }
  std::string geindexAssetName(
    RasterGEIndexFactory::SubAssetName(assetRef, type, subpath));
  if (indexVer == 0) {
    // zero is a sentinal value that means we've wrapped and
    // need to completely re-index.

    // clear the sentinal
    MutableMercatorRasterProjectAssetD asset(GetAssetRef());
    indexVer = asset->config.indexVersion = config.indexVersion = 1;

    tryReuse = false;
  }
  geindexConfig.index_version_ = indexVer;


  // Fill geindexConfig packetvers and reuse indexVersions if possible
  // We build the config with our LevelPack grandkids
  // and reuse as aggressively as we can
  unsigned int asset_idx = 0;
  assert(packgenvers.size() == packgenassets.size());
  geindexConfig.packet_insets_.reserve(packgenvers.size());

  for (const auto& packgenver : packgenvers) {
    // Check if terrain inset has type "Filling" then do not add it into
    // GEIndex-build.
    if (AssetDefs::Terrain == type && config.is_overlay_terrain_project_) {
      AssetNameEqualToPred assetname_equal_pred(packgenassets[asset_idx]);
      std::vector<PacketGenInfo>::iterator genInfoIt =
          std::find_if(genInfo.begin(), genInfo.end(),
                       assetname_equal_pred);
      // packgenvers is subset of genInfo;
      assert(genInfoIt != genInfo.end());

      if (kFillingTerrainInset == genInfoIt->terrain_inset_type) {
        notify(NFY_DEBUG, "Skip \"Filling\"-terrain inset: %s",
               genInfoIt->assetname.toString().c_str());
        continue;  // Skip "Filling" terrain inset.
      }
    }

    if (packgenver->children.size()) {
      geindexConfig.packet_insets_.push_back(RasterPacketInset());
      geindexConfig.packet_insets_.back().levels_.reserve(
          packgenver->children.size());
      for (const auto &packlevelref : packgenver->children) {
        geindexConfig.packet_insets_.back().levels_.push_back(
            RasterPacketLevelVersion(packlevelref, indexVer));
      }
    }
    ++asset_idx;
  }
  if (tryReuse) {
    RasterGEIndexAssetD asset(geindexAssetName);
    if (asset) {
      asset->ReuseOldPacketVers(geindexConfig);
    }
  }
  MutableRasterGEIndexAssetVersionD geindex =
    FindMakeAndUpdate<RasterGEIndexType>
                         (geindexAssetName,
                          type,
                          packgenkids,
                          khMetaData(),
                          geindexConfig,
                          packgenvers);
  AddChild(geindex);
  return geindex->config.index_version_;
}
